/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 140:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(596);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 3722:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(140);
const file_command_1 = __nccwpck_require__(2197);
const utils_1 = __nccwpck_require__(596);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const uuid_1 = __nccwpck_require__(5650);
const oidc_utils_1 = __nccwpck_require__(5395);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = `ghadelimiter_${uuid_1.v4()}`;
        // These should realistically never happen, but just in case someone finds a way to exploit uuid generation let's not allow keys or values that contain the delimiter.
        if (name.includes(delimiter)) {
            throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
        }
        if (convertedVal.includes(delimiter)) {
            throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
        }
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(9475);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(9475);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(1528);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 2197:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(596);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 5395:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(3774);
const auth_1 = __nccwpck_require__(6187);
const core_1 = __nccwpck_require__(3722);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 1528:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 9475:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 596:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 6187:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 3774:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(7650));
const tunnel = __importStar(__nccwpck_require__(9866));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7650:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 1925:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference path="../shims-public.d.ts" />
const listenersMap = new WeakMap();
const abortedMap = new WeakMap();
/**
 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
 *
 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
 * cannot or will not ever be cancelled.
 *
 * @example
 * Abort without timeout
 * ```ts
 * await doAsyncWork(AbortSignal.none);
 * ```
 */
class AbortSignal {
    constructor() {
        /**
         * onabort event listener.
         */
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
    }
    /**
     * Status of whether aborted or not.
     *
     * @readonly
     */
    get aborted() {
        if (!abortedMap.has(this)) {
            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
    }
    /**
     * Creates a new AbortSignal instance that will never be aborted.
     *
     * @readonly
     */
    static get none() {
        return new AbortSignal();
    }
    /**
     * Added new "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be added
     */
    addEventListener(
    // tslint:disable-next-line:variable-name
    _type, listener) {
        if (!listenersMap.has(this)) {
            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
    }
    /**
     * Remove "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be removed
     */
    removeEventListener(
    // tslint:disable-next-line:variable-name
    _type, listener) {
        if (!listenersMap.has(this)) {
            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
            listeners.splice(index, 1);
        }
    }
    /**
     * Dispatches a synthetic event to the AbortSignal.
     */
    dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
}
/**
 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
 * Will try to trigger abort event for all linked AbortSignal nodes.
 *
 * - If there is a timeout, the timer will be cancelled.
 * - If aborted is true, nothing will happen.
 *
 * @internal
 */
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
function abortSignal(signal) {
    if (signal.aborted) {
        return;
    }
    if (signal.onabort) {
        signal.onabort.call(signal);
    }
    const listeners = listenersMap.get(signal);
    if (listeners) {
        // Create a copy of listeners so mutations to the array
        // (e.g. via removeListener calls) don't affect the listeners
        // we invoke.
        listeners.slice().forEach((listener) => {
            listener.call(signal, { type: "abort" });
        });
    }
    abortedMap.set(signal, true);
}

// Copyright (c) Microsoft Corporation.
/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */
class AbortError extends Error {
    constructor(message) {
        super(message);
        this.name = "AbortError";
    }
}
/**
 * An AbortController provides an AbortSignal and the associated controls to signal
 * that an asynchronous operation should be aborted.
 *
 * @example
 * Abort an operation when another event fires
 * ```ts
 * const controller = new AbortController();
 * const signal = controller.signal;
 * doAsyncWork(signal);
 * button.addEventListener('click', () => controller.abort());
 * ```
 *
 * @example
 * Share aborter cross multiple operations in 30s
 * ```ts
 * // Upload the same data to 2 different data centers at the same time,
 * // abort another when any of them is finished
 * const controller = AbortController.withTimeout(30 * 1000);
 * doAsyncWork(controller.signal).then(controller.abort);
 * doAsyncWork(controller.signal).then(controller.abort);
 *```
 *
 * @example
 * Cascaded aborting
 * ```ts
 * // All operations can't take more than 30 seconds
 * const aborter = Aborter.timeout(30 * 1000);
 *
 * // Following 2 operations can't take more than 25 seconds
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * ```
 */
class AbortController {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(parentSignals) {
        this._signal = new AbortSignal();
        if (!parentSignals) {
            return;
        }
        // coerce parentSignals into an array
        if (!Array.isArray(parentSignals)) {
            // eslint-disable-next-line prefer-rest-params
            parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
            // if the parent signal has already had abort() called,
            // then call abort on this signal as well.
            if (parentSignal.aborted) {
                this.abort();
            }
            else {
                // when the parent signal aborts, this signal should as well.
                parentSignal.addEventListener("abort", () => {
                    this.abort();
                });
            }
        }
    }
    /**
     * The AbortSignal associated with this controller that will signal aborted
     * when the abort method is called on this controller.
     *
     * @readonly
     */
    get signal() {
        return this._signal;
    }
    /**
     * Signal that any operations passed this controller's associated abort signal
     * to cancel any remaining work and throw an `AbortError`.
     */
    abort() {
        abortSignal(this._signal);
    }
    /**
     * Creates a new AbortSignal instance that will abort after the provided ms.
     * @param ms - Elapsed time in milliseconds to trigger an abort.
     */
    static timeout(ms) {
        const signal = new AbortSignal();
        const timer = setTimeout(abortSignal, ms, signal);
        // Prevent the active Timer from keeping the Node.js event loop active.
        if (typeof timer.unref === "function") {
            timer.unref();
        }
        return signal;
    }
}

exports.AbortController = AbortController;
exports.AbortError = AbortError;
exports.AbortSignal = AbortSignal;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 5550:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var tslib = __nccwpck_require__(1861);
var coreClient = __nccwpck_require__(9626);
var coreRestPipeline = __nccwpck_require__(6938);
var coreLro = __nccwpck_require__(8584);

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ResourceNotRenewableReason} that the service accepts. */
exports.KnownResourceNotRenewableReason = void 0;
(function (KnownResourceNotRenewableReason) {
    /** RegistrationStatusNotSupportedForRenewal */
    KnownResourceNotRenewableReason["RegistrationStatusNotSupportedForRenewal"] = "RegistrationStatusNotSupportedForRenewal";
    /** ExpirationNotInRenewalTimeRange */
    KnownResourceNotRenewableReason["ExpirationNotInRenewalTimeRange"] = "ExpirationNotInRenewalTimeRange";
    /** SubscriptionNotActive */
    KnownResourceNotRenewableReason["SubscriptionNotActive"] = "SubscriptionNotActive";
})(exports.KnownResourceNotRenewableReason || (exports.KnownResourceNotRenewableReason = {}));
/** Known values of {@link LoadBalancingMode} that the service accepts. */
exports.KnownLoadBalancingMode = void 0;
(function (KnownLoadBalancingMode) {
    /** None */
    KnownLoadBalancingMode["None"] = "None";
    /** Web */
    KnownLoadBalancingMode["Web"] = "Web";
    /** Publishing */
    KnownLoadBalancingMode["Publishing"] = "Publishing";
    /** WebPublishing */
    KnownLoadBalancingMode["WebPublishing"] = "Web, Publishing";
})(exports.KnownLoadBalancingMode || (exports.KnownLoadBalancingMode = {}));
/** Known values of {@link UpgradePreference} that the service accepts. */
exports.KnownUpgradePreference = void 0;
(function (KnownUpgradePreference) {
    /** No preference on when this App Service Environment will be upgraded */
    KnownUpgradePreference["None"] = "None";
    /** This App Service Environment will be upgraded before others in the same region that have Upgrade Preference 'Late' */
    KnownUpgradePreference["Early"] = "Early";
    /** This App Service Environment will be upgraded after others in the same region that have Upgrade Preference 'Early' */
    KnownUpgradePreference["Late"] = "Late";
    /** ASEv3 only. Once an upgrade is available, this App Service Environment will wait 10 days for the upgrade to be manually initiated. After 10 days the upgrade will begin automatically */
    KnownUpgradePreference["Manual"] = "Manual";
})(exports.KnownUpgradePreference || (exports.KnownUpgradePreference = {}));
/** Known values of {@link UpgradeAvailability} that the service accepts. */
exports.KnownUpgradeAvailability = void 0;
(function (KnownUpgradeAvailability) {
    /** No upgrade is currently available for this App Service Environment */
    KnownUpgradeAvailability["None"] = "None";
    /** An upgrade is ready to be manually initiated on this App Service Environment */
    KnownUpgradeAvailability["Ready"] = "Ready";
})(exports.KnownUpgradeAvailability || (exports.KnownUpgradeAvailability = {}));
/** Known values of {@link ScmType} that the service accepts. */
exports.KnownScmType = void 0;
(function (KnownScmType) {
    /** None */
    KnownScmType["None"] = "None";
    /** Dropbox */
    KnownScmType["Dropbox"] = "Dropbox";
    /** Tfs */
    KnownScmType["Tfs"] = "Tfs";
    /** LocalGit */
    KnownScmType["LocalGit"] = "LocalGit";
    /** GitHub */
    KnownScmType["GitHub"] = "GitHub";
    /** CodePlexGit */
    KnownScmType["CodePlexGit"] = "CodePlexGit";
    /** CodePlexHg */
    KnownScmType["CodePlexHg"] = "CodePlexHg";
    /** BitbucketGit */
    KnownScmType["BitbucketGit"] = "BitbucketGit";
    /** BitbucketHg */
    KnownScmType["BitbucketHg"] = "BitbucketHg";
    /** ExternalGit */
    KnownScmType["ExternalGit"] = "ExternalGit";
    /** ExternalHg */
    KnownScmType["ExternalHg"] = "ExternalHg";
    /** OneDrive */
    KnownScmType["OneDrive"] = "OneDrive";
    /** VSO */
    KnownScmType["VSO"] = "VSO";
    /** Vstsrm */
    KnownScmType["Vstsrm"] = "VSTSRM";
})(exports.KnownScmType || (exports.KnownScmType = {}));
/** Known values of {@link IpFilterTag} that the service accepts. */
exports.KnownIpFilterTag = void 0;
(function (KnownIpFilterTag) {
    /** Default */
    KnownIpFilterTag["Default"] = "Default";
    /** XffProxy */
    KnownIpFilterTag["XffProxy"] = "XffProxy";
    /** ServiceTag */
    KnownIpFilterTag["ServiceTag"] = "ServiceTag";
})(exports.KnownIpFilterTag || (exports.KnownIpFilterTag = {}));
/** Known values of {@link SupportedTlsVersions} that the service accepts. */
exports.KnownSupportedTlsVersions = void 0;
(function (KnownSupportedTlsVersions) {
    /** One0 */
    KnownSupportedTlsVersions["One0"] = "1.0";
    /** One1 */
    KnownSupportedTlsVersions["One1"] = "1.1";
    /** One2 */
    KnownSupportedTlsVersions["One2"] = "1.2";
})(exports.KnownSupportedTlsVersions || (exports.KnownSupportedTlsVersions = {}));
/** Known values of {@link FtpsState} that the service accepts. */
exports.KnownFtpsState = void 0;
(function (KnownFtpsState) {
    /** AllAllowed */
    KnownFtpsState["AllAllowed"] = "AllAllowed";
    /** FtpsOnly */
    KnownFtpsState["FtpsOnly"] = "FtpsOnly";
    /** Disabled */
    KnownFtpsState["Disabled"] = "Disabled";
})(exports.KnownFtpsState || (exports.KnownFtpsState = {}));
/** Known values of {@link RouteType} that the service accepts. */
exports.KnownRouteType = void 0;
(function (KnownRouteType) {
    /** Default */
    KnownRouteType["Default"] = "DEFAULT";
    /** Inherited */
    KnownRouteType["Inherited"] = "INHERITED";
    /** Static */
    KnownRouteType["Static"] = "STATIC";
})(exports.KnownRouteType || (exports.KnownRouteType = {}));
/** Known values of {@link ContainerAppProvisioningState} that the service accepts. */
exports.KnownContainerAppProvisioningState = void 0;
(function (KnownContainerAppProvisioningState) {
    /** InProgress */
    KnownContainerAppProvisioningState["InProgress"] = "InProgress";
    /** Succeeded */
    KnownContainerAppProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownContainerAppProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownContainerAppProvisioningState["Canceled"] = "Canceled";
})(exports.KnownContainerAppProvisioningState || (exports.KnownContainerAppProvisioningState = {}));
/** Known values of {@link ActiveRevisionsMode} that the service accepts. */
exports.KnownActiveRevisionsMode = void 0;
(function (KnownActiveRevisionsMode) {
    /** Multiple */
    KnownActiveRevisionsMode["Multiple"] = "multiple";
    /** Single */
    KnownActiveRevisionsMode["Single"] = "single";
})(exports.KnownActiveRevisionsMode || (exports.KnownActiveRevisionsMode = {}));
/** Known values of {@link IngressTransportMethod} that the service accepts. */
exports.KnownIngressTransportMethod = void 0;
(function (KnownIngressTransportMethod) {
    /** Auto */
    KnownIngressTransportMethod["Auto"] = "auto";
    /** Http */
    KnownIngressTransportMethod["Http"] = "http";
    /** Http2 */
    KnownIngressTransportMethod["Http2"] = "http2";
})(exports.KnownIngressTransportMethod || (exports.KnownIngressTransportMethod = {}));
/** Known values of {@link RevisionHealthState} that the service accepts. */
exports.KnownRevisionHealthState = void 0;
(function (KnownRevisionHealthState) {
    /** Healthy */
    KnownRevisionHealthState["Healthy"] = "Healthy";
    /** Unhealthy */
    KnownRevisionHealthState["Unhealthy"] = "Unhealthy";
    /** None */
    KnownRevisionHealthState["None"] = "None";
})(exports.KnownRevisionHealthState || (exports.KnownRevisionHealthState = {}));
/** Known values of {@link RevisionProvisioningState} that the service accepts. */
exports.KnownRevisionProvisioningState = void 0;
(function (KnownRevisionProvisioningState) {
    /** Provisioning */
    KnownRevisionProvisioningState["Provisioning"] = "Provisioning";
    /** Provisioned */
    KnownRevisionProvisioningState["Provisioned"] = "Provisioned";
    /** Failed */
    KnownRevisionProvisioningState["Failed"] = "Failed";
    /** Deprovisioning */
    KnownRevisionProvisioningState["Deprovisioning"] = "Deprovisioning";
    /** Deprovisioned */
    KnownRevisionProvisioningState["Deprovisioned"] = "Deprovisioned";
})(exports.KnownRevisionProvisioningState || (exports.KnownRevisionProvisioningState = {}));
/** Known values of {@link Enum14} that the service accepts. */
exports.KnownEnum14 = void 0;
(function (KnownEnum14) {
    /** Windows */
    KnownEnum14["Windows"] = "Windows";
    /** Linux */
    KnownEnum14["Linux"] = "Linux";
    /** WindowsFunctions */
    KnownEnum14["WindowsFunctions"] = "WindowsFunctions";
    /** LinuxFunctions */
    KnownEnum14["LinuxFunctions"] = "LinuxFunctions";
    /** All */
    KnownEnum14["All"] = "All";
})(exports.KnownEnum14 || (exports.KnownEnum14 = {}));
/** Known values of {@link Enum15} that the service accepts. */
exports.KnownEnum15 = void 0;
(function (KnownEnum15) {
    /** Windows */
    KnownEnum15["Windows"] = "Windows";
    /** Linux */
    KnownEnum15["Linux"] = "Linux";
    /** All */
    KnownEnum15["All"] = "All";
})(exports.KnownEnum15 || (exports.KnownEnum15 = {}));
/** Known values of {@link Enum16} that the service accepts. */
exports.KnownEnum16 = void 0;
(function (KnownEnum16) {
    /** Windows */
    KnownEnum16["Windows"] = "Windows";
    /** Linux */
    KnownEnum16["Linux"] = "Linux";
    /** All */
    KnownEnum16["All"] = "All";
})(exports.KnownEnum16 || (exports.KnownEnum16 = {}));
/** Known values of {@link Enum17} that the service accepts. */
exports.KnownEnum17 = void 0;
(function (KnownEnum17) {
    /** Windows */
    KnownEnum17["Windows"] = "Windows";
    /** Linux */
    KnownEnum17["Linux"] = "Linux";
    /** All */
    KnownEnum17["All"] = "All";
})(exports.KnownEnum17 || (exports.KnownEnum17 = {}));
/** Known values of {@link Enum18} that the service accepts. */
exports.KnownEnum18 = void 0;
(function (KnownEnum18) {
    /** Windows */
    KnownEnum18["Windows"] = "Windows";
    /** Linux */
    KnownEnum18["Linux"] = "Linux";
    /** All */
    KnownEnum18["All"] = "All";
})(exports.KnownEnum18 || (exports.KnownEnum18 = {}));
/** Known values of {@link Enum19} that the service accepts. */
exports.KnownEnum19 = void 0;
(function (KnownEnum19) {
    /** Windows */
    KnownEnum19["Windows"] = "Windows";
    /** Linux */
    KnownEnum19["Linux"] = "Linux";
    /** WindowsFunctions */
    KnownEnum19["WindowsFunctions"] = "WindowsFunctions";
    /** LinuxFunctions */
    KnownEnum19["LinuxFunctions"] = "LinuxFunctions";
    /** All */
    KnownEnum19["All"] = "All";
})(exports.KnownEnum19 || (exports.KnownEnum19 = {}));
/** Known values of {@link ResourceScopeType} that the service accepts. */
exports.KnownResourceScopeType = void 0;
(function (KnownResourceScopeType) {
    /** ServerFarm */
    KnownResourceScopeType["ServerFarm"] = "ServerFarm";
    /** Subscription */
    KnownResourceScopeType["Subscription"] = "Subscription";
    /** WebSite */
    KnownResourceScopeType["WebSite"] = "WebSite";
})(exports.KnownResourceScopeType || (exports.KnownResourceScopeType = {}));
/** Known values of {@link CheckNameResourceTypes} that the service accepts. */
exports.KnownCheckNameResourceTypes = void 0;
(function (KnownCheckNameResourceTypes) {
    /** Site */
    KnownCheckNameResourceTypes["Site"] = "Site";
    /** Slot */
    KnownCheckNameResourceTypes["Slot"] = "Slot";
    /** HostingEnvironment */
    KnownCheckNameResourceTypes["HostingEnvironment"] = "HostingEnvironment";
    /** PublishingUser */
    KnownCheckNameResourceTypes["PublishingUser"] = "PublishingUser";
    /** MicrosoftWebSites */
    KnownCheckNameResourceTypes["MicrosoftWebSites"] = "Microsoft.Web/sites";
    /** MicrosoftWebSitesSlots */
    KnownCheckNameResourceTypes["MicrosoftWebSitesSlots"] = "Microsoft.Web/sites/slots";
    /** MicrosoftWebHostingEnvironments */
    KnownCheckNameResourceTypes["MicrosoftWebHostingEnvironments"] = "Microsoft.Web/hostingEnvironments";
    /** MicrosoftWebPublishingUsers */
    KnownCheckNameResourceTypes["MicrosoftWebPublishingUsers"] = "Microsoft.Web/publishingUsers";
})(exports.KnownCheckNameResourceTypes || (exports.KnownCheckNameResourceTypes = {}));
/** Known values of {@link InAvailabilityReasonType} that the service accepts. */
exports.KnownInAvailabilityReasonType = void 0;
(function (KnownInAvailabilityReasonType) {
    /** Invalid */
    KnownInAvailabilityReasonType["Invalid"] = "Invalid";
    /** AlreadyExists */
    KnownInAvailabilityReasonType["AlreadyExists"] = "AlreadyExists";
})(exports.KnownInAvailabilityReasonType || (exports.KnownInAvailabilityReasonType = {}));
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** Free */
    KnownSkuName["Free"] = "Free";
    /** Shared */
    KnownSkuName["Shared"] = "Shared";
    /** Basic */
    KnownSkuName["Basic"] = "Basic";
    /** Standard */
    KnownSkuName["Standard"] = "Standard";
    /** Premium */
    KnownSkuName["Premium"] = "Premium";
    /** Dynamic */
    KnownSkuName["Dynamic"] = "Dynamic";
    /** Isolated */
    KnownSkuName["Isolated"] = "Isolated";
    /** IsolatedV2 */
    KnownSkuName["IsolatedV2"] = "IsolatedV2";
    /** PremiumV2 */
    KnownSkuName["PremiumV2"] = "PremiumV2";
    /** PremiumV3 */
    KnownSkuName["PremiumV3"] = "PremiumV3";
    /** PremiumContainer */
    KnownSkuName["PremiumContainer"] = "PremiumContainer";
    /** ElasticPremium */
    KnownSkuName["ElasticPremium"] = "ElasticPremium";
    /** ElasticIsolated */
    KnownSkuName["ElasticIsolated"] = "ElasticIsolated";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link ValidateResourceTypes} that the service accepts. */
exports.KnownValidateResourceTypes = void 0;
(function (KnownValidateResourceTypes) {
    /** ServerFarm */
    KnownValidateResourceTypes["ServerFarm"] = "ServerFarm";
    /** Site */
    KnownValidateResourceTypes["Site"] = "Site";
    /** MicrosoftWebHostingEnvironments */
    KnownValidateResourceTypes["MicrosoftWebHostingEnvironments"] = "Microsoft.Web/hostingEnvironments";
})(exports.KnownValidateResourceTypes || (exports.KnownValidateResourceTypes = {}));
/** Known values of {@link EnterpriseGradeCdnStatus} that the service accepts. */
exports.KnownEnterpriseGradeCdnStatus = void 0;
(function (KnownEnterpriseGradeCdnStatus) {
    /** Enabled */
    KnownEnterpriseGradeCdnStatus["Enabled"] = "Enabled";
    /** Enabling */
    KnownEnterpriseGradeCdnStatus["Enabling"] = "Enabling";
    /** Disabled */
    KnownEnterpriseGradeCdnStatus["Disabled"] = "Disabled";
    /** Disabling */
    KnownEnterpriseGradeCdnStatus["Disabling"] = "Disabling";
})(exports.KnownEnterpriseGradeCdnStatus || (exports.KnownEnterpriseGradeCdnStatus = {}));
/** Known values of {@link BuildStatus} that the service accepts. */
exports.KnownBuildStatus = void 0;
(function (KnownBuildStatus) {
    /** WaitingForDeployment */
    KnownBuildStatus["WaitingForDeployment"] = "WaitingForDeployment";
    /** Uploading */
    KnownBuildStatus["Uploading"] = "Uploading";
    /** Deploying */
    KnownBuildStatus["Deploying"] = "Deploying";
    /** Ready */
    KnownBuildStatus["Ready"] = "Ready";
    /** Failed */
    KnownBuildStatus["Failed"] = "Failed";
    /** Deleting */
    KnownBuildStatus["Deleting"] = "Deleting";
    /** Detached */
    KnownBuildStatus["Detached"] = "Detached";
})(exports.KnownBuildStatus || (exports.KnownBuildStatus = {}));
/** Known values of {@link TriggerTypes} that the service accepts. */
exports.KnownTriggerTypes = void 0;
(function (KnownTriggerTypes) {
    /** HttpTrigger */
    KnownTriggerTypes["HttpTrigger"] = "HttpTrigger";
    /** Unknown */
    KnownTriggerTypes["Unknown"] = "Unknown";
})(exports.KnownTriggerTypes || (exports.KnownTriggerTypes = {}));
/** Known values of {@link CustomDomainStatus} that the service accepts. */
exports.KnownCustomDomainStatus = void 0;
(function (KnownCustomDomainStatus) {
    /** RetrievingValidationToken */
    KnownCustomDomainStatus["RetrievingValidationToken"] = "RetrievingValidationToken";
    /** Validating */
    KnownCustomDomainStatus["Validating"] = "Validating";
    /** Adding */
    KnownCustomDomainStatus["Adding"] = "Adding";
    /** Ready */
    KnownCustomDomainStatus["Ready"] = "Ready";
    /** Failed */
    KnownCustomDomainStatus["Failed"] = "Failed";
    /** Deleting */
    KnownCustomDomainStatus["Deleting"] = "Deleting";
    /** Unhealthy */
    KnownCustomDomainStatus["Unhealthy"] = "Unhealthy";
})(exports.KnownCustomDomainStatus || (exports.KnownCustomDomainStatus = {}));
/** Known values of {@link DatabaseType} that the service accepts. */
exports.KnownDatabaseType = void 0;
(function (KnownDatabaseType) {
    /** SqlAzure */
    KnownDatabaseType["SqlAzure"] = "SqlAzure";
    /** MySql */
    KnownDatabaseType["MySql"] = "MySql";
    /** LocalMySql */
    KnownDatabaseType["LocalMySql"] = "LocalMySql";
    /** PostgreSql */
    KnownDatabaseType["PostgreSql"] = "PostgreSql";
})(exports.KnownDatabaseType || (exports.KnownDatabaseType = {}));
/** Known values of {@link DeploymentBuildStatus} that the service accepts. */
exports.KnownDeploymentBuildStatus = void 0;
(function (KnownDeploymentBuildStatus) {
    /** TimedOut */
    KnownDeploymentBuildStatus["TimedOut"] = "TimedOut";
    /** RuntimeFailed */
    KnownDeploymentBuildStatus["RuntimeFailed"] = "RuntimeFailed";
    /** BuildAborted */
    KnownDeploymentBuildStatus["BuildAborted"] = "BuildAborted";
    /** BuildFailed */
    KnownDeploymentBuildStatus["BuildFailed"] = "BuildFailed";
    /** BuildRequestReceived */
    KnownDeploymentBuildStatus["BuildRequestReceived"] = "BuildRequestReceived";
    /** BuildPending */
    KnownDeploymentBuildStatus["BuildPending"] = "BuildPending";
    /** BuildInProgress */
    KnownDeploymentBuildStatus["BuildInProgress"] = "BuildInProgress";
    /** BuildSuccessful */
    KnownDeploymentBuildStatus["BuildSuccessful"] = "BuildSuccessful";
    /** PostBuildRestartRequired */
    KnownDeploymentBuildStatus["PostBuildRestartRequired"] = "PostBuildRestartRequired";
    /** StartPolling */
    KnownDeploymentBuildStatus["StartPolling"] = "StartPolling";
    /** StartPollingWithRestart */
    KnownDeploymentBuildStatus["StartPollingWithRestart"] = "StartPollingWithRestart";
    /** RuntimeStarting */
    KnownDeploymentBuildStatus["RuntimeStarting"] = "RuntimeStarting";
    /** RuntimeSuccessful */
    KnownDeploymentBuildStatus["RuntimeSuccessful"] = "RuntimeSuccessful";
})(exports.KnownDeploymentBuildStatus || (exports.KnownDeploymentBuildStatus = {}));
/** Known values of {@link PublishingProfileFormat} that the service accepts. */
exports.KnownPublishingProfileFormat = void 0;
(function (KnownPublishingProfileFormat) {
    /** FileZilla3 */
    KnownPublishingProfileFormat["FileZilla3"] = "FileZilla3";
    /** WebDeploy */
    KnownPublishingProfileFormat["WebDeploy"] = "WebDeploy";
    /** Ftp */
    KnownPublishingProfileFormat["Ftp"] = "Ftp";
})(exports.KnownPublishingProfileFormat || (exports.KnownPublishingProfileFormat = {}));
/** Known values of {@link KeyType} that the service accepts. */
exports.KnownKeyType = void 0;
(function (KnownKeyType) {
    /** NotSpecified */
    KnownKeyType["NotSpecified"] = "NotSpecified";
    /** Primary */
    KnownKeyType["Primary"] = "Primary";
    /** Secondary */
    KnownKeyType["Secondary"] = "Secondary";
})(exports.KnownKeyType || (exports.KnownKeyType = {}));
/** Known values of {@link WorkflowStatus} that the service accepts. */
exports.KnownWorkflowStatus = void 0;
(function (KnownWorkflowStatus) {
    /** NotSpecified */
    KnownWorkflowStatus["NotSpecified"] = "NotSpecified";
    /** Paused */
    KnownWorkflowStatus["Paused"] = "Paused";
    /** Running */
    KnownWorkflowStatus["Running"] = "Running";
    /** Waiting */
    KnownWorkflowStatus["Waiting"] = "Waiting";
    /** Succeeded */
    KnownWorkflowStatus["Succeeded"] = "Succeeded";
    /** Skipped */
    KnownWorkflowStatus["Skipped"] = "Skipped";
    /** Suspended */
    KnownWorkflowStatus["Suspended"] = "Suspended";
    /** Cancelled */
    KnownWorkflowStatus["Cancelled"] = "Cancelled";
    /** Failed */
    KnownWorkflowStatus["Failed"] = "Failed";
    /** Faulted */
    KnownWorkflowStatus["Faulted"] = "Faulted";
    /** TimedOut */
    KnownWorkflowStatus["TimedOut"] = "TimedOut";
    /** Aborted */
    KnownWorkflowStatus["Aborted"] = "Aborted";
    /** Ignored */
    KnownWorkflowStatus["Ignored"] = "Ignored";
})(exports.KnownWorkflowStatus || (exports.KnownWorkflowStatus = {}));
/** Known values of {@link ParameterType} that the service accepts. */
exports.KnownParameterType = void 0;
(function (KnownParameterType) {
    /** NotSpecified */
    KnownParameterType["NotSpecified"] = "NotSpecified";
    /** String */
    KnownParameterType["String"] = "String";
    /** SecureString */
    KnownParameterType["SecureString"] = "SecureString";
    /** Int */
    KnownParameterType["Int"] = "Int";
    /** Float */
    KnownParameterType["Float"] = "Float";
    /** Bool */
    KnownParameterType["Bool"] = "Bool";
    /** Array */
    KnownParameterType["Array"] = "Array";
    /** Object */
    KnownParameterType["Object"] = "Object";
    /** SecureObject */
    KnownParameterType["SecureObject"] = "SecureObject";
})(exports.KnownParameterType || (exports.KnownParameterType = {}));
/** Known values of {@link WorkflowTriggerProvisioningState} that the service accepts. */
exports.KnownWorkflowTriggerProvisioningState = void 0;
(function (KnownWorkflowTriggerProvisioningState) {
    /** NotSpecified */
    KnownWorkflowTriggerProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownWorkflowTriggerProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownWorkflowTriggerProvisioningState["Running"] = "Running";
    /** Ready */
    KnownWorkflowTriggerProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownWorkflowTriggerProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownWorkflowTriggerProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownWorkflowTriggerProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownWorkflowTriggerProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownWorkflowTriggerProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownWorkflowTriggerProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownWorkflowTriggerProvisioningState["Succeeded"] = "Succeeded";
    /** Moving */
    KnownWorkflowTriggerProvisioningState["Moving"] = "Moving";
    /** Updating */
    KnownWorkflowTriggerProvisioningState["Updating"] = "Updating";
    /** Registering */
    KnownWorkflowTriggerProvisioningState["Registering"] = "Registering";
    /** Registered */
    KnownWorkflowTriggerProvisioningState["Registered"] = "Registered";
    /** Unregistering */
    KnownWorkflowTriggerProvisioningState["Unregistering"] = "Unregistering";
    /** Unregistered */
    KnownWorkflowTriggerProvisioningState["Unregistered"] = "Unregistered";
    /** Completed */
    KnownWorkflowTriggerProvisioningState["Completed"] = "Completed";
})(exports.KnownWorkflowTriggerProvisioningState || (exports.KnownWorkflowTriggerProvisioningState = {}));
/** Known values of {@link WorkflowState} that the service accepts. */
exports.KnownWorkflowState = void 0;
(function (KnownWorkflowState) {
    /** NotSpecified */
    KnownWorkflowState["NotSpecified"] = "NotSpecified";
    /** Completed */
    KnownWorkflowState["Completed"] = "Completed";
    /** Enabled */
    KnownWorkflowState["Enabled"] = "Enabled";
    /** Disabled */
    KnownWorkflowState["Disabled"] = "Disabled";
    /** Deleted */
    KnownWorkflowState["Deleted"] = "Deleted";
    /** Suspended */
    KnownWorkflowState["Suspended"] = "Suspended";
})(exports.KnownWorkflowState || (exports.KnownWorkflowState = {}));
/** Known values of {@link RecurrenceFrequency} that the service accepts. */
exports.KnownRecurrenceFrequency = void 0;
(function (KnownRecurrenceFrequency) {
    /** NotSpecified */
    KnownRecurrenceFrequency["NotSpecified"] = "NotSpecified";
    /** Second */
    KnownRecurrenceFrequency["Second"] = "Second";
    /** Minute */
    KnownRecurrenceFrequency["Minute"] = "Minute";
    /** Hour */
    KnownRecurrenceFrequency["Hour"] = "Hour";
    /** Day */
    KnownRecurrenceFrequency["Day"] = "Day";
    /** Week */
    KnownRecurrenceFrequency["Week"] = "Week";
    /** Month */
    KnownRecurrenceFrequency["Month"] = "Month";
    /** Year */
    KnownRecurrenceFrequency["Year"] = "Year";
})(exports.KnownRecurrenceFrequency || (exports.KnownRecurrenceFrequency = {}));
/** Known values of {@link WorkflowProvisioningState} that the service accepts. */
exports.KnownWorkflowProvisioningState = void 0;
(function (KnownWorkflowProvisioningState) {
    /** NotSpecified */
    KnownWorkflowProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownWorkflowProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownWorkflowProvisioningState["Running"] = "Running";
    /** Ready */
    KnownWorkflowProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownWorkflowProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownWorkflowProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownWorkflowProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownWorkflowProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownWorkflowProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownWorkflowProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownWorkflowProvisioningState["Succeeded"] = "Succeeded";
    /** Moving */
    KnownWorkflowProvisioningState["Moving"] = "Moving";
    /** Updating */
    KnownWorkflowProvisioningState["Updating"] = "Updating";
    /** Registering */
    KnownWorkflowProvisioningState["Registering"] = "Registering";
    /** Registered */
    KnownWorkflowProvisioningState["Registered"] = "Registered";
    /** Unregistering */
    KnownWorkflowProvisioningState["Unregistering"] = "Unregistering";
    /** Unregistered */
    KnownWorkflowProvisioningState["Unregistered"] = "Unregistered";
    /** Completed */
    KnownWorkflowProvisioningState["Completed"] = "Completed";
    /** Renewing */
    KnownWorkflowProvisioningState["Renewing"] = "Renewing";
    /** Pending */
    KnownWorkflowProvisioningState["Pending"] = "Pending";
    /** Waiting */
    KnownWorkflowProvisioningState["Waiting"] = "Waiting";
    /** InProgress */
    KnownWorkflowProvisioningState["InProgress"] = "InProgress";
})(exports.KnownWorkflowProvisioningState || (exports.KnownWorkflowProvisioningState = {}));
/** Known values of {@link OpenAuthenticationProviderType} that the service accepts. */
exports.KnownOpenAuthenticationProviderType = void 0;
(function (KnownOpenAuthenticationProviderType) {
    /** AAD */
    KnownOpenAuthenticationProviderType["AAD"] = "AAD";
})(exports.KnownOpenAuthenticationProviderType || (exports.KnownOpenAuthenticationProviderType = {}));
/** Known values of {@link WorkflowSkuName} that the service accepts. */
exports.KnownWorkflowSkuName = void 0;
(function (KnownWorkflowSkuName) {
    /** NotSpecified */
    KnownWorkflowSkuName["NotSpecified"] = "NotSpecified";
    /** Free */
    KnownWorkflowSkuName["Free"] = "Free";
    /** Shared */
    KnownWorkflowSkuName["Shared"] = "Shared";
    /** Basic */
    KnownWorkflowSkuName["Basic"] = "Basic";
    /** Standard */
    KnownWorkflowSkuName["Standard"] = "Standard";
    /** Premium */
    KnownWorkflowSkuName["Premium"] = "Premium";
})(exports.KnownWorkflowSkuName || (exports.KnownWorkflowSkuName = {}));
/** Known values of {@link Kind} that the service accepts. */
exports.KnownKind = void 0;
(function (KnownKind) {
    /** Stateful */
    KnownKind["Stateful"] = "Stateful";
    /** Stateless */
    KnownKind["Stateless"] = "Stateless";
})(exports.KnownKind || (exports.KnownKind = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AppServiceCertificateOrderCollection = {
    serializedName: "AppServiceCertificateOrderCollection",
    type: {
        name: "Composite",
        className: "AppServiceCertificateOrderCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServiceCertificateOrder",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceCertificateOrder"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppServiceCertificate = {
    serializedName: "AppServiceCertificate",
    type: {
        name: "Composite",
        className: "AppServiceCertificate",
        modelProperties: {
            keyVaultId: {
                serializedName: "keyVaultId",
                xmlName: "keyVaultId",
                type: {
                    name: "String"
                }
            },
            keyVaultSecretName: {
                serializedName: "keyVaultSecretName",
                xmlName: "keyVaultSecretName",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown"
                    ]
                }
            }
        }
    }
};
const CertificateDetails = {
    serializedName: "CertificateDetails",
    type: {
        name: "Composite",
        className: "CertificateDetails",
        modelProperties: {
            version: {
                serializedName: "version",
                readOnly: true,
                xmlName: "version",
                type: {
                    name: "Number"
                }
            },
            serialNumber: {
                serializedName: "serialNumber",
                readOnly: true,
                xmlName: "serialNumber",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                readOnly: true,
                xmlName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            subject: {
                serializedName: "subject",
                readOnly: true,
                xmlName: "subject",
                type: {
                    name: "String"
                }
            },
            notBefore: {
                serializedName: "notBefore",
                readOnly: true,
                xmlName: "notBefore",
                type: {
                    name: "DateTime"
                }
            },
            notAfter: {
                serializedName: "notAfter",
                readOnly: true,
                xmlName: "notAfter",
                type: {
                    name: "DateTime"
                }
            },
            signatureAlgorithm: {
                serializedName: "signatureAlgorithm",
                readOnly: true,
                xmlName: "signatureAlgorithm",
                type: {
                    name: "String"
                }
            },
            issuer: {
                serializedName: "issuer",
                readOnly: true,
                xmlName: "issuer",
                type: {
                    name: "String"
                }
            },
            rawData: {
                serializedName: "rawData",
                readOnly: true,
                xmlName: "rawData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateOrderContact = {
    serializedName: "CertificateOrderContact",
    type: {
        name: "Composite",
        className: "CertificateOrderContact",
        modelProperties: {
            email: {
                serializedName: "email",
                xmlName: "email",
                type: {
                    name: "String"
                }
            },
            nameFirst: {
                serializedName: "nameFirst",
                xmlName: "nameFirst",
                type: {
                    name: "String"
                }
            },
            nameLast: {
                serializedName: "nameLast",
                xmlName: "nameLast",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                xmlName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    serializedName: "Resource",
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DefaultErrorResponse = {
    serializedName: "DefaultErrorResponse",
    type: {
        name: "Composite",
        className: "DefaultErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "DefaultErrorResponseError"
                }
            }
        }
    }
};
const DefaultErrorResponseError = {
    serializedName: "DefaultErrorResponseError",
    type: {
        name: "Composite",
        className: "DefaultErrorResponseError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                xmlName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "DefaultErrorResponseErrorDetailsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DefaultErrorResponseErrorDetailsItem"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                readOnly: true,
                xmlName: "innererror",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefaultErrorResponseErrorDetailsItem = {
    serializedName: "DefaultErrorResponseErrorDetailsItem",
    type: {
        name: "Composite",
        className: "DefaultErrorResponseErrorDetailsItem",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                xmlName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyOnlyResource = {
    serializedName: "ProxyOnlyResource",
    type: {
        name: "Composite",
        className: "ProxyOnlyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppServiceCertificateCollection = {
    serializedName: "AppServiceCertificateCollection",
    type: {
        name: "Composite",
        className: "AppServiceCertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServiceCertificateResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceCertificateResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NameIdentifier = {
    serializedName: "NameIdentifier",
    type: {
        name: "Composite",
        className: "NameIdentifier",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteSealRequest = {
    serializedName: "SiteSealRequest",
    type: {
        name: "Composite",
        className: "SiteSealRequest",
        modelProperties: {
            lightTheme: {
                serializedName: "lightTheme",
                xmlName: "lightTheme",
                type: {
                    name: "Boolean"
                }
            },
            locale: {
                serializedName: "locale",
                xmlName: "locale",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteSeal = {
    serializedName: "SiteSeal",
    type: {
        name: "Composite",
        className: "SiteSeal",
        modelProperties: {
            html: {
                serializedName: "html",
                required: true,
                xmlName: "html",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateOrderAction = {
    serializedName: "CertificateOrderAction",
    type: {
        name: "Composite",
        className: "CertificateOrderAction",
        modelProperties: {
            actionType: {
                serializedName: "actionType",
                readOnly: true,
                xmlName: "actionType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "CertificateIssued",
                        "CertificateOrderCanceled",
                        "CertificateOrderCreated",
                        "CertificateRevoked",
                        "DomainValidationComplete",
                        "FraudDetected",
                        "OrgNameChange",
                        "OrgValidationComplete",
                        "SanDrop",
                        "FraudCleared",
                        "CertificateExpired",
                        "CertificateExpirationWarning",
                        "FraudDocumentationRequired",
                        "Unknown"
                    ]
                }
            },
            createdAt: {
                serializedName: "createdAt",
                readOnly: true,
                xmlName: "createdAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CertificateEmail = {
    serializedName: "CertificateEmail",
    type: {
        name: "Composite",
        className: "CertificateEmail",
        modelProperties: {
            emailId: {
                serializedName: "emailId",
                xmlName: "emailId",
                type: {
                    name: "String"
                }
            },
            timeStamp: {
                serializedName: "timeStamp",
                xmlName: "timeStamp",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DetectorResponseCollection = {
    serializedName: "DetectorResponseCollection",
    type: {
        name: "Composite",
        className: "DetectorResponseCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DetectorResponse",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorResponse"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DetectorInfo = {
    serializedName: "DetectorInfo",
    type: {
        name: "Composite",
        className: "DetectorInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            author: {
                serializedName: "author",
                readOnly: true,
                xmlName: "author",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                readOnly: true,
                xmlName: "category",
                type: {
                    name: "String"
                }
            },
            supportTopicList: {
                serializedName: "supportTopicList",
                readOnly: true,
                xmlName: "supportTopicList",
                xmlElementName: "SupportTopic",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SupportTopic"
                        }
                    }
                }
            },
            analysisType: {
                serializedName: "analysisType",
                readOnly: true,
                xmlName: "analysisType",
                xmlElementName: "DetectorInfoAnalysisTypeItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["Detector", "Analysis", "CategoryOverview"]
                }
            },
            score: {
                serializedName: "score",
                readOnly: true,
                xmlName: "score",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SupportTopic = {
    serializedName: "SupportTopic",
    type: {
        name: "Composite",
        className: "SupportTopic",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            pesId: {
                serializedName: "pesId",
                readOnly: true,
                xmlName: "pesId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticData = {
    serializedName: "DiagnosticData",
    type: {
        name: "Composite",
        className: "DiagnosticData",
        modelProperties: {
            table: {
                serializedName: "table",
                xmlName: "table",
                type: {
                    name: "Composite",
                    className: "DataTableResponseObject"
                }
            },
            renderingProperties: {
                serializedName: "renderingProperties",
                xmlName: "renderingProperties",
                type: {
                    name: "Composite",
                    className: "Rendering"
                }
            }
        }
    }
};
const DataTableResponseObject = {
    serializedName: "DataTableResponseObject",
    type: {
        name: "Composite",
        className: "DataTableResponseObject",
        modelProperties: {
            tableName: {
                serializedName: "tableName",
                xmlName: "tableName",
                type: {
                    name: "String"
                }
            },
            columns: {
                serializedName: "columns",
                xmlName: "columns",
                xmlElementName: "DataTableResponseColumn",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataTableResponseColumn"
                        }
                    }
                }
            },
            rows: {
                serializedName: "rows",
                xmlName: "rows",
                xmlElementName: "DataTableResponseObjectRowsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const DataTableResponseColumn = {
    serializedName: "DataTableResponseColumn",
    type: {
        name: "Composite",
        className: "DataTableResponseColumn",
        modelProperties: {
            columnName: {
                serializedName: "columnName",
                xmlName: "columnName",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                xmlName: "dataType",
                type: {
                    name: "String"
                }
            },
            columnType: {
                serializedName: "columnType",
                xmlName: "columnType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Rendering = {
    serializedName: "Rendering",
    type: {
        name: "Composite",
        className: "Rendering",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "NoGraph",
                        "Table",
                        "TimeSeries",
                        "TimeSeriesPerInstance",
                        "PieChart",
                        "DataSummary",
                        "Email",
                        "Insights",
                        "DynamicInsight",
                        "Markdown",
                        "Detector",
                        "DropDown",
                        "Card",
                        "Solution",
                        "Guage",
                        "Form",
                        "ChangeSets",
                        "ChangeAnalysisOnboarding",
                        "ChangesView",
                        "AppInsight",
                        "DependencyGraph",
                        "DownTime",
                        "SummaryCard",
                        "SearchComponent",
                        "AppInsightEnablement"
                    ]
                }
            },
            title: {
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Status = {
    serializedName: "Status",
    type: {
        name: "Composite",
        className: "Status",
        modelProperties: {
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            statusId: {
                serializedName: "statusId",
                xmlName: "statusId",
                type: {
                    name: "Enum",
                    allowedValues: ["Critical", "Warning", "Info", "Success", "None"]
                }
            }
        }
    }
};
const DataProviderMetadata = {
    serializedName: "DataProviderMetadata",
    type: {
        name: "Composite",
        className: "DataProviderMetadata",
        modelProperties: {
            providerName: {
                serializedName: "providerName",
                xmlName: "providerName",
                type: {
                    name: "String"
                }
            },
            propertyBag: {
                serializedName: "propertyBag",
                readOnly: true,
                xmlName: "propertyBag",
                xmlElementName: "KeyValuePairStringObject",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValuePairStringObject"
                        }
                    }
                }
            }
        }
    }
};
const KeyValuePairStringObject = {
    serializedName: "KeyValuePairStringObject",
    type: {
        name: "Composite",
        className: "KeyValuePairStringObject",
        modelProperties: {
            key: {
                serializedName: "key",
                readOnly: true,
                xmlName: "key",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const QueryUtterancesResults = {
    serializedName: "QueryUtterancesResults",
    type: {
        name: "Composite",
        className: "QueryUtterancesResults",
        modelProperties: {
            query: {
                serializedName: "query",
                xmlName: "query",
                type: {
                    name: "String"
                }
            },
            results: {
                serializedName: "results",
                xmlName: "results",
                xmlElementName: "QueryUtterancesResult",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryUtterancesResult"
                        }
                    }
                }
            }
        }
    }
};
const QueryUtterancesResult = {
    serializedName: "QueryUtterancesResult",
    type: {
        name: "Composite",
        className: "QueryUtterancesResult",
        modelProperties: {
            sampleUtterance: {
                serializedName: "sampleUtterance",
                xmlName: "sampleUtterance",
                type: {
                    name: "Composite",
                    className: "SampleUtterance"
                }
            },
            score: {
                serializedName: "score",
                xmlName: "score",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SampleUtterance = {
    serializedName: "SampleUtterance",
    type: {
        name: "Composite",
        className: "SampleUtterance",
        modelProperties: {
            text: {
                serializedName: "text",
                xmlName: "text",
                type: {
                    name: "String"
                }
            },
            links: {
                serializedName: "links",
                xmlName: "links",
                xmlElementName: "SampleUtteranceLinksItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            qid: {
                serializedName: "qid",
                xmlName: "qid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmOperationCollection = {
    serializedName: "CsmOperationCollection",
    type: {
        name: "Composite",
        className: "CsmOperationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmOperationDescription",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmOperationDescription"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmOperationDescription = {
    serializedName: "CsmOperationDescription",
    type: {
        name: "Composite",
        className: "CsmOperationDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                xmlName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                xmlName: "display",
                type: {
                    name: "Composite",
                    className: "CsmOperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                xmlName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "CsmOperationDescriptionProperties"
                }
            }
        }
    }
};
const CsmOperationDisplay = {
    serializedName: "CsmOperationDisplay",
    type: {
        name: "Composite",
        className: "CsmOperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                xmlName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                xmlName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                xmlName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmOperationDescriptionProperties = {
    serializedName: "CsmOperationDescriptionProperties",
    type: {
        name: "Composite",
        className: "CsmOperationDescriptionProperties",
        modelProperties: {
            serviceSpecification: {
                serializedName: "serviceSpecification",
                xmlName: "serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const ServiceSpecification = {
    serializedName: "ServiceSpecification",
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                xmlName: "metricSpecifications",
                xmlElementName: "MetricSpecification",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                xmlName: "logSpecifications",
                xmlElementName: "LogSpecification",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    serializedName: "MetricSpecification",
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                xmlName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                xmlName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            supportsInstanceLevelAggregation: {
                serializedName: "supportsInstanceLevelAggregation",
                xmlName: "supportsInstanceLevelAggregation",
                type: {
                    name: "Boolean"
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                xmlName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                xmlName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                xmlName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                xmlName: "metricFilterPattern",
                type: {
                    name: "String"
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                xmlName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            isInternal: {
                serializedName: "isInternal",
                xmlName: "isInternal",
                type: {
                    name: "Boolean"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                xmlName: "dimensions",
                xmlElementName: "Dimension",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            },
            category: {
                serializedName: "category",
                xmlName: "category",
                type: {
                    name: "String"
                }
            },
            availabilities: {
                serializedName: "availabilities",
                xmlName: "availabilities",
                xmlElementName: "MetricAvailability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricAvailability"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                xmlName: "supportedTimeGrainTypes",
                xmlElementName: "MetricSpecificationSupportedTimeGrainTypesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                xmlName: "supportedAggregationTypes",
                xmlElementName: "MetricSpecificationSupportedAggregationTypesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Dimension = {
    serializedName: "Dimension",
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                xmlName: "internalName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                xmlName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const MetricAvailability = {
    serializedName: "MetricAvailability",
    type: {
        name: "Composite",
        className: "MetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                xmlName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                xmlName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogSpecification = {
    serializedName: "LogSpecification",
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                xmlName: "blobDuration",
                type: {
                    name: "String"
                }
            },
            logFilterPattern: {
                serializedName: "logFilterPattern",
                xmlName: "logFilterPattern",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainAvailabilityCheckResult = {
    serializedName: "DomainAvailabilityCheckResult",
    type: {
        name: "Composite",
        className: "DomainAvailabilityCheckResult",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            available: {
                serializedName: "available",
                xmlName: "available",
                type: {
                    name: "Boolean"
                }
            },
            domainType: {
                serializedName: "domainType",
                xmlName: "domainType",
                type: {
                    name: "Enum",
                    allowedValues: ["Regular", "SoftDeleted"]
                }
            }
        }
    }
};
const DomainCollection = {
    serializedName: "DomainCollection",
    type: {
        name: "Composite",
        className: "DomainCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Domain",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Domain"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Contact = {
    serializedName: "Contact",
    type: {
        name: "Composite",
        className: "Contact",
        modelProperties: {
            addressMailing: {
                serializedName: "addressMailing",
                xmlName: "addressMailing",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            email: {
                serializedName: "email",
                required: true,
                xmlName: "email",
                type: {
                    name: "String"
                }
            },
            fax: {
                serializedName: "fax",
                xmlName: "fax",
                type: {
                    name: "String"
                }
            },
            jobTitle: {
                serializedName: "jobTitle",
                xmlName: "jobTitle",
                type: {
                    name: "String"
                }
            },
            nameFirst: {
                serializedName: "nameFirst",
                required: true,
                xmlName: "nameFirst",
                type: {
                    name: "String"
                }
            },
            nameLast: {
                serializedName: "nameLast",
                required: true,
                xmlName: "nameLast",
                type: {
                    name: "String"
                }
            },
            nameMiddle: {
                serializedName: "nameMiddle",
                xmlName: "nameMiddle",
                type: {
                    name: "String"
                }
            },
            organization: {
                serializedName: "organization",
                xmlName: "organization",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                required: true,
                xmlName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Address = {
    serializedName: "Address",
    type: {
        name: "Composite",
        className: "Address",
        modelProperties: {
            address1: {
                serializedName: "address1",
                required: true,
                xmlName: "address1",
                type: {
                    name: "String"
                }
            },
            address2: {
                serializedName: "address2",
                xmlName: "address2",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                required: true,
                xmlName: "city",
                type: {
                    name: "String"
                }
            },
            country: {
                serializedName: "country",
                required: true,
                xmlName: "country",
                type: {
                    name: "String"
                }
            },
            postalCode: {
                serializedName: "postalCode",
                required: true,
                xmlName: "postalCode",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                required: true,
                xmlName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HostName = {
    serializedName: "HostName",
    type: {
        name: "Composite",
        className: "HostName",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            siteNames: {
                serializedName: "siteNames",
                xmlName: "siteNames",
                xmlElementName: "HostNameSiteNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            azureResourceName: {
                serializedName: "azureResourceName",
                xmlName: "azureResourceName",
                type: {
                    name: "String"
                }
            },
            azureResourceType: {
                serializedName: "azureResourceType",
                xmlName: "azureResourceType",
                type: {
                    name: "Enum",
                    allowedValues: ["Website", "TrafficManager"]
                }
            },
            customHostNameDnsRecordType: {
                serializedName: "customHostNameDnsRecordType",
                xmlName: "customHostNameDnsRecordType",
                type: {
                    name: "Enum",
                    allowedValues: ["CName", "A"]
                }
            },
            hostNameType: {
                serializedName: "hostNameType",
                xmlName: "hostNameType",
                type: {
                    name: "Enum",
                    allowedValues: ["Verified", "Managed"]
                }
            }
        }
    }
};
const DomainPurchaseConsent = {
    serializedName: "DomainPurchaseConsent",
    type: {
        name: "Composite",
        className: "DomainPurchaseConsent",
        modelProperties: {
            agreementKeys: {
                serializedName: "agreementKeys",
                xmlName: "agreementKeys",
                xmlElementName: "DomainPurchaseConsentAgreementKeysItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            agreedBy: {
                serializedName: "agreedBy",
                xmlName: "agreedBy",
                type: {
                    name: "String"
                }
            },
            agreedAt: {
                serializedName: "agreedAt",
                xmlName: "agreedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DomainControlCenterSsoRequest = {
    serializedName: "DomainControlCenterSsoRequest",
    type: {
        name: "Composite",
        className: "DomainControlCenterSsoRequest",
        modelProperties: {
            url: {
                serializedName: "url",
                readOnly: true,
                xmlName: "url",
                type: {
                    name: "String"
                }
            },
            postParameterKey: {
                serializedName: "postParameterKey",
                readOnly: true,
                xmlName: "postParameterKey",
                type: {
                    name: "String"
                }
            },
            postParameterValue: {
                serializedName: "postParameterValue",
                readOnly: true,
                xmlName: "postParameterValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainRecommendationSearchParameters = {
    serializedName: "DomainRecommendationSearchParameters",
    type: {
        name: "Composite",
        className: "DomainRecommendationSearchParameters",
        modelProperties: {
            keywords: {
                serializedName: "keywords",
                xmlName: "keywords",
                type: {
                    name: "String"
                }
            },
            maxDomainRecommendations: {
                serializedName: "maxDomainRecommendations",
                xmlName: "maxDomainRecommendations",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NameIdentifierCollection = {
    serializedName: "NameIdentifierCollection",
    type: {
        name: "Composite",
        className: "NameIdentifierCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "NameIdentifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameIdentifier"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainOwnershipIdentifierCollection = {
    serializedName: "DomainOwnershipIdentifierCollection",
    type: {
        name: "Composite",
        className: "DomainOwnershipIdentifierCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DomainOwnershipIdentifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DomainOwnershipIdentifier"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopLevelDomainCollection = {
    serializedName: "TopLevelDomainCollection",
    type: {
        name: "Composite",
        className: "TopLevelDomainCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TopLevelDomain",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopLevelDomain"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopLevelDomainAgreementOption = {
    serializedName: "TopLevelDomainAgreementOption",
    type: {
        name: "Composite",
        className: "TopLevelDomainAgreementOption",
        modelProperties: {
            includePrivacy: {
                serializedName: "includePrivacy",
                xmlName: "includePrivacy",
                type: {
                    name: "Boolean"
                }
            },
            forTransfer: {
                serializedName: "forTransfer",
                xmlName: "forTransfer",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TldLegalAgreementCollection = {
    serializedName: "TldLegalAgreementCollection",
    type: {
        name: "Composite",
        className: "TldLegalAgreementCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TldLegalAgreement",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TldLegalAgreement"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TldLegalAgreement = {
    serializedName: "TldLegalAgreement",
    type: {
        name: "Composite",
        className: "TldLegalAgreement",
        modelProperties: {
            agreementKey: {
                serializedName: "agreementKey",
                required: true,
                xmlName: "agreementKey",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                required: true,
                xmlName: "title",
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                xmlName: "content",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppServiceEnvironmentCollection = {
    serializedName: "AppServiceEnvironmentCollection",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServiceEnvironmentResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceEnvironmentResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppServiceEnvironment = {
    serializedName: "AppServiceEnvironment",
    type: {
        name: "Composite",
        className: "AppServiceEnvironment",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                xmlName: "status",
                type: {
                    name: "Enum",
                    allowedValues: ["Preparing", "Ready", "Scaling", "Deleting"]
                }
            },
            virtualNetwork: {
                serializedName: "virtualNetwork",
                xmlName: "virtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile"
                }
            },
            internalLoadBalancingMode: {
                serializedName: "internalLoadBalancingMode",
                xmlName: "internalLoadBalancingMode",
                type: {
                    name: "String"
                }
            },
            multiSize: {
                serializedName: "multiSize",
                xmlName: "multiSize",
                type: {
                    name: "String"
                }
            },
            multiRoleCount: {
                serializedName: "multiRoleCount",
                readOnly: true,
                xmlName: "multiRoleCount",
                type: {
                    name: "Number"
                }
            },
            ipsslAddressCount: {
                serializedName: "ipsslAddressCount",
                xmlName: "ipsslAddressCount",
                type: {
                    name: "Number"
                }
            },
            dnsSuffix: {
                serializedName: "dnsSuffix",
                xmlName: "dnsSuffix",
                type: {
                    name: "String"
                }
            },
            maximumNumberOfMachines: {
                serializedName: "maximumNumberOfMachines",
                readOnly: true,
                xmlName: "maximumNumberOfMachines",
                type: {
                    name: "Number"
                }
            },
            frontEndScaleFactor: {
                serializedName: "frontEndScaleFactor",
                xmlName: "frontEndScaleFactor",
                type: {
                    name: "Number"
                }
            },
            suspended: {
                serializedName: "suspended",
                readOnly: true,
                xmlName: "suspended",
                type: {
                    name: "Boolean"
                }
            },
            clusterSettings: {
                serializedName: "clusterSettings",
                xmlName: "clusterSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            },
            userWhitelistedIpRanges: {
                serializedName: "userWhitelistedIpRanges",
                xmlName: "userWhitelistedIpRanges",
                xmlElementName: "AppServiceEnvironmentUserWhitelistedIpRangesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            hasLinuxWorkers: {
                serializedName: "hasLinuxWorkers",
                readOnly: true,
                xmlName: "hasLinuxWorkers",
                type: {
                    name: "Boolean"
                }
            },
            upgradePreference: {
                defaultValue: "None",
                serializedName: "upgradePreference",
                xmlName: "upgradePreference",
                type: {
                    name: "String"
                }
            },
            dedicatedHostCount: {
                serializedName: "dedicatedHostCount",
                xmlName: "dedicatedHostCount",
                type: {
                    name: "Number"
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                xmlName: "zoneRedundant",
                type: {
                    name: "Boolean"
                }
            },
            customDnsSuffixConfiguration: {
                serializedName: "customDnsSuffixConfiguration",
                xmlName: "customDnsSuffixConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDnsSuffixConfiguration"
                }
            },
            networkingConfiguration: {
                serializedName: "networkingConfiguration",
                xmlName: "networkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AseV3NetworkingConfiguration"
                }
            },
            upgradeAvailability: {
                serializedName: "upgradeAvailability",
                readOnly: true,
                xmlName: "upgradeAvailability",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkProfile = {
    serializedName: "VirtualNetworkProfile",
    type: {
        name: "Composite",
        className: "VirtualNetworkProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "subnet",
                xmlName: "subnet",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NameValuePair = {
    serializedName: "NameValuePair",
    type: {
        name: "Composite",
        className: "NameValuePair",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StampCapacityCollection = {
    serializedName: "StampCapacityCollection",
    type: {
        name: "Composite",
        className: "StampCapacityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StampCapacity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StampCapacity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StampCapacity = {
    serializedName: "StampCapacity",
    type: {
        name: "Composite",
        className: "StampCapacity",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            availableCapacity: {
                serializedName: "availableCapacity",
                xmlName: "availableCapacity",
                type: {
                    name: "Number"
                }
            },
            totalCapacity: {
                serializedName: "totalCapacity",
                xmlName: "totalCapacity",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String"
                }
            },
            computeMode: {
                serializedName: "computeMode",
                xmlName: "computeMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Shared", "Dedicated", "Dynamic"]
                }
            },
            workerSize: {
                serializedName: "workerSize",
                xmlName: "workerSize",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Small",
                        "Medium",
                        "Large",
                        "D1",
                        "D2",
                        "D3",
                        "SmallV3",
                        "MediumV3",
                        "LargeV3",
                        "NestedSmall",
                        "NestedSmallLinux",
                        "Default"
                    ]
                }
            },
            workerSizeId: {
                serializedName: "workerSizeId",
                xmlName: "workerSizeId",
                type: {
                    name: "Number"
                }
            },
            excludeFromCapacityAllocation: {
                serializedName: "excludeFromCapacityAllocation",
                xmlName: "excludeFromCapacityAllocation",
                type: {
                    name: "Boolean"
                }
            },
            isApplicableForAllComputeModes: {
                serializedName: "isApplicableForAllComputeModes",
                xmlName: "isApplicableForAllComputeModes",
                type: {
                    name: "Boolean"
                }
            },
            siteMode: {
                serializedName: "siteMode",
                xmlName: "siteMode",
                type: {
                    name: "String"
                }
            },
            isLinux: {
                serializedName: "isLinux",
                xmlName: "isLinux",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualIPMapping = {
    serializedName: "VirtualIPMapping",
    type: {
        name: "Composite",
        className: "VirtualIPMapping",
        modelProperties: {
            virtualIP: {
                serializedName: "virtualIP",
                xmlName: "virtualIP",
                type: {
                    name: "String"
                }
            },
            internalHttpPort: {
                serializedName: "internalHttpPort",
                xmlName: "internalHttpPort",
                type: {
                    name: "Number"
                }
            },
            internalHttpsPort: {
                serializedName: "internalHttpsPort",
                xmlName: "internalHttpsPort",
                type: {
                    name: "Number"
                }
            },
            inUse: {
                serializedName: "inUse",
                xmlName: "inUse",
                type: {
                    name: "Boolean"
                }
            },
            serviceName: {
                serializedName: "serviceName",
                xmlName: "serviceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebAppCollection = {
    serializedName: "WebAppCollection",
    type: {
        name: "Composite",
        className: "WebAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Site",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Site"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HostNameSslState = {
    serializedName: "HostNameSslState",
    type: {
        name: "Composite",
        className: "HostNameSslState",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            sslState: {
                serializedName: "sslState",
                xmlName: "sslState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "SniEnabled", "IpBasedEnabled"]
                }
            },
            virtualIP: {
                serializedName: "virtualIP",
                xmlName: "virtualIP",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                xmlName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            toUpdate: {
                serializedName: "toUpdate",
                xmlName: "toUpdate",
                type: {
                    name: "Boolean"
                }
            },
            hostType: {
                serializedName: "hostType",
                xmlName: "hostType",
                type: {
                    name: "Enum",
                    allowedValues: ["Standard", "Repository"]
                }
            }
        }
    }
};
const SiteConfig = {
    serializedName: "SiteConfig",
    type: {
        name: "Composite",
        className: "SiteConfig",
        modelProperties: {
            numberOfWorkers: {
                serializedName: "numberOfWorkers",
                xmlName: "numberOfWorkers",
                type: {
                    name: "Number"
                }
            },
            defaultDocuments: {
                serializedName: "defaultDocuments",
                xmlName: "defaultDocuments",
                xmlElementName: "SiteConfigDefaultDocumentsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            netFrameworkVersion: {
                defaultValue: "v4.6",
                serializedName: "netFrameworkVersion",
                xmlName: "netFrameworkVersion",
                type: {
                    name: "String"
                }
            },
            phpVersion: {
                serializedName: "phpVersion",
                xmlName: "phpVersion",
                type: {
                    name: "String"
                }
            },
            pythonVersion: {
                serializedName: "pythonVersion",
                xmlName: "pythonVersion",
                type: {
                    name: "String"
                }
            },
            nodeVersion: {
                serializedName: "nodeVersion",
                xmlName: "nodeVersion",
                type: {
                    name: "String"
                }
            },
            powerShellVersion: {
                serializedName: "powerShellVersion",
                xmlName: "powerShellVersion",
                type: {
                    name: "String"
                }
            },
            linuxFxVersion: {
                serializedName: "linuxFxVersion",
                xmlName: "linuxFxVersion",
                type: {
                    name: "String"
                }
            },
            windowsFxVersion: {
                serializedName: "windowsFxVersion",
                xmlName: "windowsFxVersion",
                type: {
                    name: "String"
                }
            },
            requestTracingEnabled: {
                serializedName: "requestTracingEnabled",
                xmlName: "requestTracingEnabled",
                type: {
                    name: "Boolean"
                }
            },
            requestTracingExpirationTime: {
                serializedName: "requestTracingExpirationTime",
                xmlName: "requestTracingExpirationTime",
                type: {
                    name: "DateTime"
                }
            },
            remoteDebuggingEnabled: {
                serializedName: "remoteDebuggingEnabled",
                xmlName: "remoteDebuggingEnabled",
                type: {
                    name: "Boolean"
                }
            },
            remoteDebuggingVersion: {
                serializedName: "remoteDebuggingVersion",
                xmlName: "remoteDebuggingVersion",
                type: {
                    name: "String"
                }
            },
            httpLoggingEnabled: {
                serializedName: "httpLoggingEnabled",
                xmlName: "httpLoggingEnabled",
                type: {
                    name: "Boolean"
                }
            },
            acrUseManagedIdentityCreds: {
                serializedName: "acrUseManagedIdentityCreds",
                xmlName: "acrUseManagedIdentityCreds",
                type: {
                    name: "Boolean"
                }
            },
            acrUserManagedIdentityID: {
                serializedName: "acrUserManagedIdentityID",
                xmlName: "acrUserManagedIdentityID",
                type: {
                    name: "String"
                }
            },
            logsDirectorySizeLimit: {
                serializedName: "logsDirectorySizeLimit",
                xmlName: "logsDirectorySizeLimit",
                type: {
                    name: "Number"
                }
            },
            detailedErrorLoggingEnabled: {
                serializedName: "detailedErrorLoggingEnabled",
                xmlName: "detailedErrorLoggingEnabled",
                type: {
                    name: "Boolean"
                }
            },
            publishingUsername: {
                serializedName: "publishingUsername",
                xmlName: "publishingUsername",
                type: {
                    name: "String"
                }
            },
            appSettings: {
                serializedName: "appSettings",
                xmlName: "appSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            },
            connectionStrings: {
                serializedName: "connectionStrings",
                xmlName: "connectionStrings",
                xmlElementName: "ConnStringInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnStringInfo"
                        }
                    }
                }
            },
            machineKey: {
                serializedName: "machineKey",
                xmlName: "machineKey",
                type: {
                    name: "Composite",
                    className: "SiteMachineKey"
                }
            },
            handlerMappings: {
                serializedName: "handlerMappings",
                xmlName: "handlerMappings",
                xmlElementName: "HandlerMapping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandlerMapping"
                        }
                    }
                }
            },
            documentRoot: {
                serializedName: "documentRoot",
                xmlName: "documentRoot",
                type: {
                    name: "String"
                }
            },
            scmType: {
                serializedName: "scmType",
                xmlName: "scmType",
                type: {
                    name: "String"
                }
            },
            use32BitWorkerProcess: {
                serializedName: "use32BitWorkerProcess",
                xmlName: "use32BitWorkerProcess",
                type: {
                    name: "Boolean"
                }
            },
            webSocketsEnabled: {
                serializedName: "webSocketsEnabled",
                xmlName: "webSocketsEnabled",
                type: {
                    name: "Boolean"
                }
            },
            alwaysOn: {
                serializedName: "alwaysOn",
                xmlName: "alwaysOn",
                type: {
                    name: "Boolean"
                }
            },
            javaVersion: {
                serializedName: "javaVersion",
                xmlName: "javaVersion",
                type: {
                    name: "String"
                }
            },
            javaContainer: {
                serializedName: "javaContainer",
                xmlName: "javaContainer",
                type: {
                    name: "String"
                }
            },
            javaContainerVersion: {
                serializedName: "javaContainerVersion",
                xmlName: "javaContainerVersion",
                type: {
                    name: "String"
                }
            },
            appCommandLine: {
                serializedName: "appCommandLine",
                xmlName: "appCommandLine",
                type: {
                    name: "String"
                }
            },
            managedPipelineMode: {
                serializedName: "managedPipelineMode",
                xmlName: "managedPipelineMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Integrated", "Classic"]
                }
            },
            virtualApplications: {
                serializedName: "virtualApplications",
                xmlName: "virtualApplications",
                xmlElementName: "VirtualApplication",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplication"
                        }
                    }
                }
            },
            loadBalancing: {
                serializedName: "loadBalancing",
                xmlName: "loadBalancing",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "WeightedRoundRobin",
                        "LeastRequests",
                        "LeastResponseTime",
                        "WeightedTotalTraffic",
                        "RequestHash",
                        "PerSiteRoundRobin"
                    ]
                }
            },
            experiments: {
                serializedName: "experiments",
                xmlName: "experiments",
                type: {
                    name: "Composite",
                    className: "Experiments"
                }
            },
            limits: {
                serializedName: "limits",
                xmlName: "limits",
                type: {
                    name: "Composite",
                    className: "SiteLimits"
                }
            },
            autoHealEnabled: {
                serializedName: "autoHealEnabled",
                xmlName: "autoHealEnabled",
                type: {
                    name: "Boolean"
                }
            },
            autoHealRules: {
                serializedName: "autoHealRules",
                xmlName: "autoHealRules",
                type: {
                    name: "Composite",
                    className: "AutoHealRules"
                }
            },
            tracingOptions: {
                serializedName: "tracingOptions",
                xmlName: "tracingOptions",
                type: {
                    name: "String"
                }
            },
            vnetName: {
                serializedName: "vnetName",
                xmlName: "vnetName",
                type: {
                    name: "String"
                }
            },
            vnetRouteAllEnabled: {
                serializedName: "vnetRouteAllEnabled",
                xmlName: "vnetRouteAllEnabled",
                type: {
                    name: "Boolean"
                }
            },
            vnetPrivatePortsCount: {
                serializedName: "vnetPrivatePortsCount",
                xmlName: "vnetPrivatePortsCount",
                type: {
                    name: "Number"
                }
            },
            cors: {
                serializedName: "cors",
                xmlName: "cors",
                type: {
                    name: "Composite",
                    className: "CorsSettings"
                }
            },
            push: {
                serializedName: "push",
                xmlName: "push",
                type: {
                    name: "Composite",
                    className: "PushSettings"
                }
            },
            apiDefinition: {
                serializedName: "apiDefinition",
                xmlName: "apiDefinition",
                type: {
                    name: "Composite",
                    className: "ApiDefinitionInfo"
                }
            },
            apiManagementConfig: {
                serializedName: "apiManagementConfig",
                xmlName: "apiManagementConfig",
                type: {
                    name: "Composite",
                    className: "ApiManagementConfig"
                }
            },
            autoSwapSlotName: {
                serializedName: "autoSwapSlotName",
                xmlName: "autoSwapSlotName",
                type: {
                    name: "String"
                }
            },
            localMySqlEnabled: {
                defaultValue: false,
                serializedName: "localMySqlEnabled",
                xmlName: "localMySqlEnabled",
                type: {
                    name: "Boolean"
                }
            },
            managedServiceIdentityId: {
                serializedName: "managedServiceIdentityId",
                xmlName: "managedServiceIdentityId",
                type: {
                    name: "Number"
                }
            },
            xManagedServiceIdentityId: {
                serializedName: "xManagedServiceIdentityId",
                xmlName: "xManagedServiceIdentityId",
                type: {
                    name: "Number"
                }
            },
            keyVaultReferenceIdentity: {
                serializedName: "keyVaultReferenceIdentity",
                xmlName: "keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            },
            ipSecurityRestrictions: {
                serializedName: "ipSecurityRestrictions",
                xmlName: "ipSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction"
                        }
                    }
                }
            },
            scmIpSecurityRestrictions: {
                serializedName: "scmIpSecurityRestrictions",
                xmlName: "scmIpSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction"
                        }
                    }
                }
            },
            scmIpSecurityRestrictionsUseMain: {
                serializedName: "scmIpSecurityRestrictionsUseMain",
                xmlName: "scmIpSecurityRestrictionsUseMain",
                type: {
                    name: "Boolean"
                }
            },
            http20Enabled: {
                defaultValue: true,
                serializedName: "http20Enabled",
                xmlName: "http20Enabled",
                type: {
                    name: "Boolean"
                }
            },
            minTlsVersion: {
                serializedName: "minTlsVersion",
                xmlName: "minTlsVersion",
                type: {
                    name: "String"
                }
            },
            scmMinTlsVersion: {
                serializedName: "scmMinTlsVersion",
                xmlName: "scmMinTlsVersion",
                type: {
                    name: "String"
                }
            },
            ftpsState: {
                serializedName: "ftpsState",
                xmlName: "ftpsState",
                type: {
                    name: "String"
                }
            },
            preWarmedInstanceCount: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0
                },
                serializedName: "preWarmedInstanceCount",
                xmlName: "preWarmedInstanceCount",
                type: {
                    name: "Number"
                }
            },
            functionAppScaleLimit: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "functionAppScaleLimit",
                xmlName: "functionAppScaleLimit",
                type: {
                    name: "Number"
                }
            },
            healthCheckPath: {
                serializedName: "healthCheckPath",
                xmlName: "healthCheckPath",
                type: {
                    name: "String"
                }
            },
            functionsRuntimeScaleMonitoringEnabled: {
                serializedName: "functionsRuntimeScaleMonitoringEnabled",
                xmlName: "functionsRuntimeScaleMonitoringEnabled",
                type: {
                    name: "Boolean"
                }
            },
            websiteTimeZone: {
                serializedName: "websiteTimeZone",
                xmlName: "websiteTimeZone",
                type: {
                    name: "String"
                }
            },
            minimumElasticInstanceCount: {
                constraints: {
                    InclusiveMaximum: 20,
                    InclusiveMinimum: 0
                },
                serializedName: "minimumElasticInstanceCount",
                xmlName: "minimumElasticInstanceCount",
                type: {
                    name: "Number"
                }
            },
            azureStorageAccounts: {
                serializedName: "azureStorageAccounts",
                xmlName: "azureStorageAccounts",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AzureStorageInfoValue" }
                    }
                }
            },
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                xmlName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnStringInfo = {
    serializedName: "ConnStringInfo",
    type: {
        name: "Composite",
        className: "ConnStringInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            connectionString: {
                serializedName: "connectionString",
                xmlName: "connectionString",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "MySql",
                        "SQLServer",
                        "SQLAzure",
                        "Custom",
                        "NotificationHub",
                        "ServiceBus",
                        "EventHub",
                        "ApiHub",
                        "DocDb",
                        "RedisCache",
                        "PostgreSQL"
                    ]
                }
            }
        }
    }
};
const SiteMachineKey = {
    serializedName: "SiteMachineKey",
    type: {
        name: "Composite",
        className: "SiteMachineKey",
        modelProperties: {
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "String"
                }
            },
            validationKey: {
                serializedName: "validationKey",
                xmlName: "validationKey",
                type: {
                    name: "String"
                }
            },
            decryption: {
                serializedName: "decryption",
                xmlName: "decryption",
                type: {
                    name: "String"
                }
            },
            decryptionKey: {
                serializedName: "decryptionKey",
                xmlName: "decryptionKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HandlerMapping = {
    serializedName: "HandlerMapping",
    type: {
        name: "Composite",
        className: "HandlerMapping",
        modelProperties: {
            extension: {
                serializedName: "extension",
                xmlName: "extension",
                type: {
                    name: "String"
                }
            },
            scriptProcessor: {
                serializedName: "scriptProcessor",
                xmlName: "scriptProcessor",
                type: {
                    name: "String"
                }
            },
            arguments: {
                serializedName: "arguments",
                xmlName: "arguments",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualApplication = {
    serializedName: "VirtualApplication",
    type: {
        name: "Composite",
        className: "VirtualApplication",
        modelProperties: {
            virtualPath: {
                serializedName: "virtualPath",
                xmlName: "virtualPath",
                type: {
                    name: "String"
                }
            },
            physicalPath: {
                serializedName: "physicalPath",
                xmlName: "physicalPath",
                type: {
                    name: "String"
                }
            },
            preloadEnabled: {
                serializedName: "preloadEnabled",
                xmlName: "preloadEnabled",
                type: {
                    name: "Boolean"
                }
            },
            virtualDirectories: {
                serializedName: "virtualDirectories",
                xmlName: "virtualDirectories",
                xmlElementName: "VirtualDirectory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDirectory"
                        }
                    }
                }
            }
        }
    }
};
const VirtualDirectory = {
    serializedName: "VirtualDirectory",
    type: {
        name: "Composite",
        className: "VirtualDirectory",
        modelProperties: {
            virtualPath: {
                serializedName: "virtualPath",
                xmlName: "virtualPath",
                type: {
                    name: "String"
                }
            },
            physicalPath: {
                serializedName: "physicalPath",
                xmlName: "physicalPath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Experiments = {
    serializedName: "Experiments",
    type: {
        name: "Composite",
        className: "Experiments",
        modelProperties: {
            rampUpRules: {
                serializedName: "rampUpRules",
                xmlName: "rampUpRules",
                xmlElementName: "RampUpRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RampUpRule"
                        }
                    }
                }
            }
        }
    }
};
const RampUpRule = {
    serializedName: "RampUpRule",
    type: {
        name: "Composite",
        className: "RampUpRule",
        modelProperties: {
            actionHostName: {
                serializedName: "actionHostName",
                xmlName: "actionHostName",
                type: {
                    name: "String"
                }
            },
            reroutePercentage: {
                serializedName: "reroutePercentage",
                xmlName: "reroutePercentage",
                type: {
                    name: "Number"
                }
            },
            changeStep: {
                serializedName: "changeStep",
                xmlName: "changeStep",
                type: {
                    name: "Number"
                }
            },
            changeIntervalInMinutes: {
                serializedName: "changeIntervalInMinutes",
                xmlName: "changeIntervalInMinutes",
                type: {
                    name: "Number"
                }
            },
            minReroutePercentage: {
                serializedName: "minReroutePercentage",
                xmlName: "minReroutePercentage",
                type: {
                    name: "Number"
                }
            },
            maxReroutePercentage: {
                serializedName: "maxReroutePercentage",
                xmlName: "maxReroutePercentage",
                type: {
                    name: "Number"
                }
            },
            changeDecisionCallbackUrl: {
                serializedName: "changeDecisionCallbackUrl",
                xmlName: "changeDecisionCallbackUrl",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteLimits = {
    serializedName: "SiteLimits",
    type: {
        name: "Composite",
        className: "SiteLimits",
        modelProperties: {
            maxPercentageCpu: {
                serializedName: "maxPercentageCpu",
                xmlName: "maxPercentageCpu",
                type: {
                    name: "Number"
                }
            },
            maxMemoryInMb: {
                serializedName: "maxMemoryInMb",
                xmlName: "maxMemoryInMb",
                type: {
                    name: "Number"
                }
            },
            maxDiskSizeInMb: {
                serializedName: "maxDiskSizeInMb",
                xmlName: "maxDiskSizeInMb",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoHealRules = {
    serializedName: "AutoHealRules",
    type: {
        name: "Composite",
        className: "AutoHealRules",
        modelProperties: {
            triggers: {
                serializedName: "triggers",
                xmlName: "triggers",
                type: {
                    name: "Composite",
                    className: "AutoHealTriggers"
                }
            },
            actions: {
                serializedName: "actions",
                xmlName: "actions",
                type: {
                    name: "Composite",
                    className: "AutoHealActions"
                }
            }
        }
    }
};
const AutoHealTriggers = {
    serializedName: "AutoHealTriggers",
    type: {
        name: "Composite",
        className: "AutoHealTriggers",
        modelProperties: {
            requests: {
                serializedName: "requests",
                xmlName: "requests",
                type: {
                    name: "Composite",
                    className: "RequestsBasedTrigger"
                }
            },
            privateBytesInKB: {
                serializedName: "privateBytesInKB",
                xmlName: "privateBytesInKB",
                type: {
                    name: "Number"
                }
            },
            statusCodes: {
                serializedName: "statusCodes",
                xmlName: "statusCodes",
                xmlElementName: "StatusCodesBasedTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StatusCodesBasedTrigger"
                        }
                    }
                }
            },
            slowRequests: {
                serializedName: "slowRequests",
                xmlName: "slowRequests",
                type: {
                    name: "Composite",
                    className: "SlowRequestsBasedTrigger"
                }
            },
            slowRequestsWithPath: {
                serializedName: "slowRequestsWithPath",
                xmlName: "slowRequestsWithPath",
                xmlElementName: "SlowRequestsBasedTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SlowRequestsBasedTrigger"
                        }
                    }
                }
            },
            statusCodesRange: {
                serializedName: "statusCodesRange",
                xmlName: "statusCodesRange",
                xmlElementName: "StatusCodesRangeBasedTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StatusCodesRangeBasedTrigger"
                        }
                    }
                }
            }
        }
    }
};
const RequestsBasedTrigger = {
    serializedName: "RequestsBasedTrigger",
    type: {
        name: "Composite",
        className: "RequestsBasedTrigger",
        modelProperties: {
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StatusCodesBasedTrigger = {
    serializedName: "StatusCodesBasedTrigger",
    type: {
        name: "Composite",
        className: "StatusCodesBasedTrigger",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "Number"
                }
            },
            subStatus: {
                serializedName: "subStatus",
                xmlName: "subStatus",
                type: {
                    name: "Number"
                }
            },
            win32Status: {
                serializedName: "win32Status",
                xmlName: "win32Status",
                type: {
                    name: "Number"
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SlowRequestsBasedTrigger = {
    serializedName: "SlowRequestsBasedTrigger",
    type: {
        name: "Composite",
        className: "SlowRequestsBasedTrigger",
        modelProperties: {
            timeTaken: {
                serializedName: "timeTaken",
                xmlName: "timeTaken",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StatusCodesRangeBasedTrigger = {
    serializedName: "StatusCodesRangeBasedTrigger",
    type: {
        name: "Composite",
        className: "StatusCodesRangeBasedTrigger",
        modelProperties: {
            statusCodes: {
                serializedName: "statusCodes",
                xmlName: "statusCodes",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoHealActions = {
    serializedName: "AutoHealActions",
    type: {
        name: "Composite",
        className: "AutoHealActions",
        modelProperties: {
            actionType: {
                serializedName: "actionType",
                xmlName: "actionType",
                type: {
                    name: "Enum",
                    allowedValues: ["Recycle", "LogEvent", "CustomAction"]
                }
            },
            customAction: {
                serializedName: "customAction",
                xmlName: "customAction",
                type: {
                    name: "Composite",
                    className: "AutoHealCustomAction"
                }
            },
            minProcessExecutionTime: {
                serializedName: "minProcessExecutionTime",
                xmlName: "minProcessExecutionTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoHealCustomAction = {
    serializedName: "AutoHealCustomAction",
    type: {
        name: "Composite",
        className: "AutoHealCustomAction",
        modelProperties: {
            exe: {
                serializedName: "exe",
                xmlName: "exe",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                xmlName: "parameters",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CorsSettings = {
    serializedName: "CorsSettings",
    type: {
        name: "Composite",
        className: "CorsSettings",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                xmlName: "allowedOrigins",
                xmlElementName: "CorsSettingsAllowedOriginsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportCredentials: {
                serializedName: "supportCredentials",
                xmlName: "supportCredentials",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApiDefinitionInfo = {
    serializedName: "ApiDefinitionInfo",
    type: {
        name: "Composite",
        className: "ApiDefinitionInfo",
        modelProperties: {
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementConfig = {
    serializedName: "ApiManagementConfig",
    type: {
        name: "Composite",
        className: "ApiManagementConfig",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpSecurityRestriction = {
    serializedName: "IpSecurityRestriction",
    type: {
        name: "Composite",
        className: "IpSecurityRestriction",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                xmlName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            subnetMask: {
                serializedName: "subnetMask",
                xmlName: "subnetMask",
                type: {
                    name: "String"
                }
            },
            vnetSubnetResourceId: {
                serializedName: "vnetSubnetResourceId",
                xmlName: "vnetSubnetResourceId",
                type: {
                    name: "String"
                }
            },
            vnetTrafficTag: {
                serializedName: "vnetTrafficTag",
                xmlName: "vnetTrafficTag",
                type: {
                    name: "Number"
                }
            },
            subnetTrafficTag: {
                serializedName: "subnetTrafficTag",
                xmlName: "subnetTrafficTag",
                type: {
                    name: "Number"
                }
            },
            action: {
                serializedName: "action",
                xmlName: "action",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                xmlName: "tag",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                xmlName: "priority",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            }
        }
    }
};
const AzureStorageInfoValue = {
    serializedName: "AzureStorageInfoValue",
    type: {
        name: "Composite",
        className: "AzureStorageInfoValue",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureFiles", "AzureBlob"]
                }
            },
            accountName: {
                serializedName: "accountName",
                xmlName: "accountName",
                type: {
                    name: "String"
                }
            },
            shareName: {
                serializedName: "shareName",
                xmlName: "shareName",
                type: {
                    name: "String"
                }
            },
            accessKey: {
                serializedName: "accessKey",
                xmlName: "accessKey",
                type: {
                    name: "String"
                }
            },
            mountPath: {
                serializedName: "mountPath",
                xmlName: "mountPath",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                xmlName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Ok",
                        "InvalidCredentials",
                        "InvalidShare",
                        "NotValidated"
                    ]
                }
            }
        }
    }
};
const HostingEnvironmentProfile = {
    serializedName: "HostingEnvironmentProfile",
    type: {
        name: "Composite",
        className: "HostingEnvironmentProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloningInfo = {
    serializedName: "CloningInfo",
    type: {
        name: "Composite",
        className: "CloningInfo",
        modelProperties: {
            correlationId: {
                serializedName: "correlationId",
                xmlName: "correlationId",
                type: {
                    name: "Uuid"
                }
            },
            overwrite: {
                serializedName: "overwrite",
                xmlName: "overwrite",
                type: {
                    name: "Boolean"
                }
            },
            cloneCustomHostNames: {
                serializedName: "cloneCustomHostNames",
                xmlName: "cloneCustomHostNames",
                type: {
                    name: "Boolean"
                }
            },
            cloneSourceControl: {
                serializedName: "cloneSourceControl",
                xmlName: "cloneSourceControl",
                type: {
                    name: "Boolean"
                }
            },
            sourceWebAppId: {
                serializedName: "sourceWebAppId",
                required: true,
                xmlName: "sourceWebAppId",
                type: {
                    name: "String"
                }
            },
            sourceWebAppLocation: {
                serializedName: "sourceWebAppLocation",
                xmlName: "sourceWebAppLocation",
                type: {
                    name: "String"
                }
            },
            hostingEnvironment: {
                serializedName: "hostingEnvironment",
                xmlName: "hostingEnvironment",
                type: {
                    name: "String"
                }
            },
            appSettingsOverrides: {
                serializedName: "appSettingsOverrides",
                xmlName: "appSettingsOverrides",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            configureLoadBalancing: {
                serializedName: "configureLoadBalancing",
                xmlName: "configureLoadBalancing",
                type: {
                    name: "Boolean"
                }
            },
            trafficManagerProfileId: {
                serializedName: "trafficManagerProfileId",
                xmlName: "trafficManagerProfileId",
                type: {
                    name: "String"
                }
            },
            trafficManagerProfileName: {
                serializedName: "trafficManagerProfileName",
                xmlName: "trafficManagerProfileName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SlotSwapStatus = {
    serializedName: "SlotSwapStatus",
    type: {
        name: "Composite",
        className: "SlotSwapStatus",
        modelProperties: {
            timestampUtc: {
                serializedName: "timestampUtc",
                readOnly: true,
                xmlName: "timestampUtc",
                type: {
                    name: "DateTime"
                }
            },
            sourceSlotName: {
                serializedName: "sourceSlotName",
                readOnly: true,
                xmlName: "sourceSlotName",
                type: {
                    name: "String"
                }
            },
            destinationSlotName: {
                serializedName: "destinationSlotName",
                readOnly: true,
                xmlName: "destinationSlotName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    serializedName: "ManagedServiceIdentity",
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                xmlName: "tenantId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                xmlName: "principalId",
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                xmlName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    serializedName: "UserAssignedIdentity",
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                xmlName: "principalId",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedLocation = {
    serializedName: "ExtendedLocation",
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HostingEnvironmentDiagnostics = {
    serializedName: "HostingEnvironmentDiagnostics",
    type: {
        name: "Composite",
        className: "HostingEnvironmentDiagnostics",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            diagnosticsOutput: {
                serializedName: "diagnosticsOutput",
                xmlName: "diagnosticsOutput",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InboundEnvironmentEndpointCollection = {
    serializedName: "InboundEnvironmentEndpointCollection",
    type: {
        name: "Composite",
        className: "InboundEnvironmentEndpointCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "InboundEnvironmentEndpoint",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundEnvironmentEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InboundEnvironmentEndpoint = {
    serializedName: "InboundEnvironmentEndpoint",
    type: {
        name: "Composite",
        className: "InboundEnvironmentEndpoint",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                xmlName: "endpoints",
                xmlElementName: "InboundEnvironmentEndpointEndpointsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ports: {
                serializedName: "ports",
                xmlName: "ports",
                xmlElementName: "InboundEnvironmentEndpointPortsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const WorkerPoolCollection = {
    serializedName: "WorkerPoolCollection",
    type: {
        name: "Composite",
        className: "WorkerPoolCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WorkerPoolResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkerPoolResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuDescription = {
    serializedName: "SkuDescription",
    type: {
        name: "Composite",
        className: "SkuDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                xmlName: "tier",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                xmlName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                xmlName: "family",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Number"
                }
            },
            skuCapacity: {
                serializedName: "skuCapacity",
                xmlName: "skuCapacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity"
                }
            },
            locations: {
                serializedName: "locations",
                xmlName: "locations",
                xmlElementName: "SkuDescriptionLocationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                xmlName: "capabilities",
                xmlElementName: "Capability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability"
                        }
                    }
                }
            }
        }
    }
};
const SkuCapacity = {
    serializedName: "SkuCapacity",
    type: {
        name: "Composite",
        className: "SkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                xmlName: "minimum",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                xmlName: "maximum",
                type: {
                    name: "Number"
                }
            },
            elasticMaximum: {
                serializedName: "elasticMaximum",
                xmlName: "elasticMaximum",
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                xmlName: "default",
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                xmlName: "scaleType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Capability = {
    serializedName: "Capability",
    type: {
        name: "Composite",
        className: "Capability",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                xmlName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceMetricDefinitionCollection = {
    serializedName: "ResourceMetricDefinitionCollection",
    type: {
        name: "Composite",
        className: "ResourceMetricDefinitionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceMetricDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceMetricDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceMetricAvailability = {
    serializedName: "ResourceMetricAvailability",
    type: {
        name: "Composite",
        className: "ResourceMetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                xmlName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            retention: {
                serializedName: "retention",
                readOnly: true,
                xmlName: "retention",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuInfoCollection = {
    serializedName: "SkuInfoCollection",
    type: {
        name: "Composite",
        className: "SkuInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SkuInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuInfo = {
    serializedName: "SkuInfo",
    type: {
        name: "Composite",
        className: "SkuInfo",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                xmlName: "resourceType",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription"
                }
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity"
                }
            }
        }
    }
};
const UsageCollection = {
    serializedName: "UsageCollection",
    type: {
        name: "Composite",
        className: "UsageCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Usage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    serializedName: "Operation",
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InProgress",
                        "Failed",
                        "Succeeded",
                        "TimedOut",
                        "Created"
                    ]
                }
            },
            errors: {
                serializedName: "errors",
                xmlName: "errors",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity"
                        }
                    }
                }
            },
            createdTime: {
                serializedName: "createdTime",
                xmlName: "createdTime",
                type: {
                    name: "DateTime"
                }
            },
            modifiedTime: {
                serializedName: "modifiedTime",
                xmlName: "modifiedTime",
                type: {
                    name: "DateTime"
                }
            },
            expirationTime: {
                serializedName: "expirationTime",
                xmlName: "expirationTime",
                type: {
                    name: "DateTime"
                }
            },
            geoMasterOperationId: {
                serializedName: "geoMasterOperationId",
                xmlName: "geoMasterOperationId",
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const ErrorEntity = {
    serializedName: "ErrorEntity",
    type: {
        name: "Composite",
        className: "ErrorEntity",
        modelProperties: {
            extendedCode: {
                serializedName: "extendedCode",
                xmlName: "extendedCode",
                type: {
                    name: "String"
                }
            },
            messageTemplate: {
                serializedName: "messageTemplate",
                xmlName: "messageTemplate",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                xmlName: "parameters",
                xmlElementName: "ErrorEntityParametersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            innerErrors: {
                serializedName: "innerErrors",
                xmlName: "innerErrors",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity"
                        }
                    }
                }
            },
            details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity"
                        }
                    }
                }
            },
            target: {
                serializedName: "target",
                xmlName: "target",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundEnvironmentEndpointCollection = {
    serializedName: "OutboundEnvironmentEndpointCollection",
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpointCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "OutboundEnvironmentEndpoint",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundEnvironmentEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundEnvironmentEndpoint = {
    serializedName: "OutboundEnvironmentEndpoint",
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                xmlName: "category",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                xmlName: "endpoints",
                xmlElementName: "EndpointDependency",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDependency"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDependency = {
    serializedName: "EndpointDependency",
    type: {
        name: "Composite",
        className: "EndpointDependency",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                xmlName: "domainName",
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                xmlName: "endpointDetails",
                xmlElementName: "EndpointDetail",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDetail"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDetail = {
    serializedName: "EndpointDetail",
    type: {
        name: "Composite",
        className: "EndpointDetail",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                xmlName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                xmlName: "port",
                type: {
                    name: "Number"
                }
            },
            latency: {
                serializedName: "latency",
                xmlName: "latency",
                type: {
                    name: "Number"
                }
            },
            isAccessible: {
                serializedName: "isAccessible",
                xmlName: "isAccessible",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PrivateEndpointConnectionCollection = {
    serializedName: "PrivateEndpointConnectionCollection",
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "RemotePrivateEndpointConnectionARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RemotePrivateEndpointConnectionARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArmIdWrapper = {
    serializedName: "ArmIdWrapper",
    type: {
        name: "Composite",
        className: "ArmIdWrapper",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkConnectionState = {
    serializedName: "PrivateLinkConnectionState",
    type: {
        name: "Composite",
        className: "PrivateLinkConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                xmlName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourcesWrapper = {
    serializedName: "PrivateLinkResourcesWrapper",
    type: {
        name: "Composite",
        className: "PrivateLinkResourcesWrapper",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PrivateLinkResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResource = {
    serializedName: "PrivateLinkResource",
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateLinkResourceProperties"
                }
            }
        }
    }
};
const PrivateLinkResourceProperties = {
    serializedName: "PrivateLinkResourceProperties",
    type: {
        name: "Composite",
        className: "PrivateLinkResourceProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                xmlName: "groupId",
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                xmlName: "requiredMembers",
                xmlElementName: "PrivateLinkResourcePropertiesRequiredMembersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                readOnly: true,
                xmlName: "requiredZoneNames",
                xmlElementName: "PrivateLinkResourcePropertiesRequiredZoneNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AppServicePlanCollection = {
    serializedName: "AppServicePlanCollection",
    type: {
        name: "Composite",
        className: "AppServicePlanCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServicePlan",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServicePlan"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KubeEnvironmentProfile = {
    serializedName: "KubeEnvironmentProfile",
    type: {
        name: "Composite",
        className: "KubeEnvironmentProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmUsageQuotaCollection = {
    serializedName: "CsmUsageQuotaCollection",
    type: {
        name: "Composite",
        className: "CsmUsageQuotaCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmUsageQuota",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmUsageQuota"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmUsageQuota = {
    serializedName: "CsmUsageQuota",
    type: {
        name: "Composite",
        className: "CsmUsageQuota",
        modelProperties: {
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String"
                }
            },
            nextResetTime: {
                serializedName: "nextResetTime",
                xmlName: "nextResetTime",
                type: {
                    name: "DateTime"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                xmlName: "currentValue",
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                xmlName: "limit",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "Composite",
                    className: "LocalizableString"
                }
            }
        }
    }
};
const LocalizableString = {
    serializedName: "LocalizableString",
    type: {
        name: "Composite",
        className: "LocalizableString",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                xmlName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceCollection = {
    serializedName: "ResourceCollection",
    type: {
        name: "Composite",
        className: "ResourceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceCollectionValueItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HybridConnectionCollection = {
    serializedName: "HybridConnectionCollection",
    type: {
        name: "Composite",
        className: "HybridConnectionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "HybridConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HybridConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VnetInfo = {
    serializedName: "VnetInfo",
    type: {
        name: "Composite",
        className: "VnetInfo",
        modelProperties: {
            vnetResourceId: {
                serializedName: "vnetResourceId",
                xmlName: "vnetResourceId",
                type: {
                    name: "String"
                }
            },
            certThumbprint: {
                serializedName: "certThumbprint",
                readOnly: true,
                xmlName: "certThumbprint",
                type: {
                    name: "String"
                }
            },
            certBlob: {
                serializedName: "certBlob",
                xmlName: "certBlob",
                type: {
                    name: "String"
                }
            },
            routes: {
                serializedName: "routes",
                readOnly: true,
                xmlName: "routes",
                xmlElementName: "VnetRoute",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetRoute"
                        }
                    }
                }
            },
            resyncRequired: {
                serializedName: "resyncRequired",
                readOnly: true,
                xmlName: "resyncRequired",
                type: {
                    name: "Boolean"
                }
            },
            dnsServers: {
                serializedName: "dnsServers",
                xmlName: "dnsServers",
                type: {
                    name: "String"
                }
            },
            isSwift: {
                serializedName: "isSwift",
                xmlName: "isSwift",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CertificateCollection = {
    serializedName: "CertificateCollection",
    type: {
        name: "Composite",
        className: "CertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Certificate",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppCollection = {
    serializedName: "ContainerAppCollection",
    type: {
        name: "Composite",
        className: "ContainerAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ContainerApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerApp"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Configuration = {
    serializedName: "Configuration",
    type: {
        name: "Composite",
        className: "Configuration",
        modelProperties: {
            secrets: {
                serializedName: "secrets",
                xmlName: "secrets",
                xmlElementName: "Secret",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            activeRevisionsMode: {
                serializedName: "activeRevisionsMode",
                xmlName: "activeRevisionsMode",
                type: {
                    name: "String"
                }
            },
            ingress: {
                serializedName: "ingress",
                xmlName: "ingress",
                type: {
                    name: "Composite",
                    className: "Ingress"
                }
            },
            registries: {
                serializedName: "registries",
                xmlName: "registries",
                xmlElementName: "RegistryCredentials",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegistryCredentials"
                        }
                    }
                }
            }
        }
    }
};
const Secret = {
    serializedName: "Secret",
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Ingress = {
    serializedName: "Ingress",
    type: {
        name: "Composite",
        className: "Ingress",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                readOnly: true,
                xmlName: "fqdn",
                type: {
                    name: "String"
                }
            },
            external: {
                defaultValue: false,
                serializedName: "external",
                xmlName: "external",
                type: {
                    name: "Boolean"
                }
            },
            targetPort: {
                serializedName: "targetPort",
                xmlName: "targetPort",
                type: {
                    name: "Number"
                }
            },
            transport: {
                serializedName: "transport",
                xmlName: "transport",
                type: {
                    name: "String"
                }
            },
            traffic: {
                serializedName: "traffic",
                xmlName: "traffic",
                xmlElementName: "TrafficWeight",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficWeight"
                        }
                    }
                }
            },
            allowInsecure: {
                serializedName: "allowInsecure",
                xmlName: "allowInsecure",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TrafficWeight = {
    serializedName: "TrafficWeight",
    type: {
        name: "Composite",
        className: "TrafficWeight",
        modelProperties: {
            revisionName: {
                serializedName: "revisionName",
                xmlName: "revisionName",
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                xmlName: "weight",
                type: {
                    name: "Number"
                }
            },
            latestRevision: {
                defaultValue: false,
                serializedName: "latestRevision",
                xmlName: "latestRevision",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RegistryCredentials = {
    serializedName: "RegistryCredentials",
    type: {
        name: "Composite",
        className: "RegistryCredentials",
        modelProperties: {
            server: {
                serializedName: "server",
                xmlName: "server",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                xmlName: "username",
                type: {
                    name: "String"
                }
            },
            passwordSecretRef: {
                serializedName: "passwordSecretRef",
                xmlName: "passwordSecretRef",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Template = {
    serializedName: "Template",
    type: {
        name: "Composite",
        className: "Template",
        modelProperties: {
            revisionSuffix: {
                serializedName: "revisionSuffix",
                xmlName: "revisionSuffix",
                type: {
                    name: "String"
                }
            },
            containers: {
                serializedName: "containers",
                xmlName: "containers",
                xmlElementName: "Container",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Container"
                        }
                    }
                }
            },
            scale: {
                serializedName: "scale",
                xmlName: "scale",
                type: {
                    name: "Composite",
                    className: "Scale"
                }
            },
            dapr: {
                serializedName: "dapr",
                xmlName: "dapr",
                type: {
                    name: "Composite",
                    className: "Dapr"
                }
            }
        }
    }
};
const Container = {
    serializedName: "Container",
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: {
            image: {
                serializedName: "image",
                xmlName: "image",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            command: {
                serializedName: "command",
                xmlName: "command",
                xmlElementName: "ContainerCommandItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            args: {
                serializedName: "args",
                xmlName: "args",
                xmlElementName: "ContainerArgsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            env: {
                serializedName: "env",
                xmlName: "env",
                xmlElementName: "EnvironmentVar",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVar"
                        }
                    }
                }
            },
            resources: {
                serializedName: "resources",
                xmlName: "resources",
                type: {
                    name: "Composite",
                    className: "ContainerResources"
                }
            }
        }
    }
};
const EnvironmentVar = {
    serializedName: "EnvironmentVar",
    type: {
        name: "Composite",
        className: "EnvironmentVar",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            secretRef: {
                serializedName: "secretRef",
                xmlName: "secretRef",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerResources = {
    serializedName: "ContainerResources",
    type: {
        name: "Composite",
        className: "ContainerResources",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                xmlName: "cpu",
                type: {
                    name: "Number"
                }
            },
            memory: {
                serializedName: "memory",
                xmlName: "memory",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Scale = {
    serializedName: "Scale",
    type: {
        name: "Composite",
        className: "Scale",
        modelProperties: {
            minReplicas: {
                serializedName: "minReplicas",
                xmlName: "minReplicas",
                type: {
                    name: "Number"
                }
            },
            maxReplicas: {
                serializedName: "maxReplicas",
                xmlName: "maxReplicas",
                type: {
                    name: "Number"
                }
            },
            rules: {
                serializedName: "rules",
                xmlName: "rules",
                xmlElementName: "ScaleRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRule"
                        }
                    }
                }
            }
        }
    }
};
const ScaleRule = {
    serializedName: "ScaleRule",
    type: {
        name: "Composite",
        className: "ScaleRule",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            azureQueue: {
                serializedName: "azureQueue",
                xmlName: "azureQueue",
                type: {
                    name: "Composite",
                    className: "QueueScaleRule"
                }
            },
            custom: {
                serializedName: "custom",
                xmlName: "custom",
                type: {
                    name: "Composite",
                    className: "CustomScaleRule"
                }
            },
            http: {
                serializedName: "http",
                xmlName: "http",
                type: {
                    name: "Composite",
                    className: "HttpScaleRule"
                }
            }
        }
    }
};
const QueueScaleRule = {
    serializedName: "QueueScaleRule",
    type: {
        name: "Composite",
        className: "QueueScaleRule",
        modelProperties: {
            queueName: {
                serializedName: "queueName",
                xmlName: "queueName",
                type: {
                    name: "String"
                }
            },
            queueLength: {
                serializedName: "queueLength",
                xmlName: "queueLength",
                type: {
                    name: "Number"
                }
            },
            auth: {
                serializedName: "auth",
                xmlName: "auth",
                xmlElementName: "ScaleRuleAuth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const ScaleRuleAuth = {
    serializedName: "ScaleRuleAuth",
    type: {
        name: "Composite",
        className: "ScaleRuleAuth",
        modelProperties: {
            secretRef: {
                serializedName: "secretRef",
                xmlName: "secretRef",
                type: {
                    name: "String"
                }
            },
            triggerParameter: {
                serializedName: "triggerParameter",
                xmlName: "triggerParameter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomScaleRule = {
    serializedName: "CustomScaleRule",
    type: {
        name: "Composite",
        className: "CustomScaleRule",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            auth: {
                serializedName: "auth",
                xmlName: "auth",
                xmlElementName: "ScaleRuleAuth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const HttpScaleRule = {
    serializedName: "HttpScaleRule",
    type: {
        name: "Composite",
        className: "HttpScaleRule",
        modelProperties: {
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            auth: {
                serializedName: "auth",
                xmlName: "auth",
                xmlElementName: "ScaleRuleAuth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const Dapr = {
    serializedName: "Dapr",
    type: {
        name: "Composite",
        className: "Dapr",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            appId: {
                serializedName: "appId",
                xmlName: "appId",
                type: {
                    name: "String"
                }
            },
            appPort: {
                serializedName: "appPort",
                xmlName: "appPort",
                type: {
                    name: "Number"
                }
            },
            components: {
                serializedName: "components",
                xmlName: "components",
                xmlElementName: "DaprComponent",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprComponent"
                        }
                    }
                }
            }
        }
    }
};
const DaprComponent = {
    serializedName: "DaprComponent",
    type: {
        name: "Composite",
        className: "DaprComponent",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                xmlName: "version",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                xmlElementName: "DaprMetadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprMetadata"
                        }
                    }
                }
            }
        }
    }
};
const DaprMetadata = {
    serializedName: "DaprMetadata",
    type: {
        name: "Composite",
        className: "DaprMetadata",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            secretRef: {
                serializedName: "secretRef",
                xmlName: "secretRef",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretsCollection = {
    serializedName: "SecretsCollection",
    type: {
        name: "Composite",
        className: "SecretsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ContainerAppSecret",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerAppSecret"
                        }
                    }
                }
            }
        }
    }
};
const ContainerAppSecret = {
    serializedName: "ContainerAppSecret",
    type: {
        name: "Composite",
        className: "ContainerAppSecret",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RevisionCollection = {
    serializedName: "RevisionCollection",
    type: {
        name: "Composite",
        className: "RevisionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Revision",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Revision"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedWebAppCollection = {
    serializedName: "DeletedWebAppCollection",
    type: {
        name: "Composite",
        className: "DeletedWebAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DeletedSite",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSite"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticCategoryCollection = {
    serializedName: "DiagnosticCategoryCollection",
    type: {
        name: "Composite",
        className: "DiagnosticCategoryCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DiagnosticCategory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticCategory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticAnalysisCollection = {
    serializedName: "DiagnosticAnalysisCollection",
    type: {
        name: "Composite",
        className: "DiagnosticAnalysisCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AnalysisDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalysisDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AbnormalTimePeriod = {
    serializedName: "AbnormalTimePeriod",
    type: {
        name: "Composite",
        className: "AbnormalTimePeriod",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            events: {
                serializedName: "events",
                xmlName: "events",
                xmlElementName: "DetectorAbnormalTimePeriod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorAbnormalTimePeriod"
                        }
                    }
                }
            },
            solutions: {
                serializedName: "solutions",
                xmlName: "solutions",
                xmlElementName: "Solution",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Solution"
                        }
                    }
                }
            }
        }
    }
};
const DetectorAbnormalTimePeriod = {
    serializedName: "DetectorAbnormalTimePeriod",
    type: {
        name: "Composite",
        className: "DetectorAbnormalTimePeriod",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                xmlName: "source",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                xmlName: "priority",
                type: {
                    name: "Number"
                }
            },
            metaData: {
                serializedName: "metaData",
                xmlName: "metaData",
                xmlElementName: "DetectorAbnormalTimePeriodMetaDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair"
                                }
                            }
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "ServiceIncident",
                        "AppDeployment",
                        "AppCrash",
                        "RuntimeIssueDetected",
                        "AseDeployment",
                        "UserIssue",
                        "PlatformIssue",
                        "Other"
                    ]
                }
            },
            solutions: {
                serializedName: "solutions",
                xmlName: "solutions",
                xmlElementName: "Solution",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Solution"
                        }
                    }
                }
            }
        }
    }
};
const Solution = {
    serializedName: "Solution",
    type: {
        name: "Composite",
        className: "Solution",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "Number"
                }
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                xmlName: "order",
                type: {
                    name: "Number"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["QuickSolution", "DeepInvestigation", "BestPractices"]
                }
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                xmlElementName: "SolutionDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair"
                                }
                            }
                        }
                    }
                }
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                xmlElementName: "SolutionMetadataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const AnalysisData = {
    serializedName: "AnalysisData",
    type: {
        name: "Composite",
        className: "AnalysisData",
        modelProperties: {
            source: {
                serializedName: "source",
                xmlName: "source",
                type: {
                    name: "String"
                }
            },
            detectorDefinition: {
                serializedName: "detectorDefinition",
                xmlName: "detectorDefinition",
                type: {
                    name: "Composite",
                    className: "DetectorDefinition"
                }
            },
            metrics: {
                serializedName: "metrics",
                xmlName: "metrics",
                xmlElementName: "DiagnosticMetricSet",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticMetricSet"
                        }
                    }
                }
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                xmlElementName: "AnalysisDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair"
                                }
                            }
                        }
                    }
                }
            },
            detectorMetaData: {
                serializedName: "detectorMetaData",
                xmlName: "detectorMetaData",
                type: {
                    name: "Composite",
                    className: "ResponseMetaData"
                }
            }
        }
    }
};
const DetectorDefinition = {
    serializedName: "DetectorDefinition",
    type: {
        name: "Composite",
        className: "DetectorDefinition",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            rank: {
                serializedName: "rank",
                readOnly: true,
                xmlName: "rank",
                type: {
                    name: "Number"
                }
            },
            isEnabled: {
                serializedName: "isEnabled",
                readOnly: true,
                xmlName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DiagnosticMetricSet = {
    serializedName: "DiagnosticMetricSet",
    type: {
        name: "Composite",
        className: "DiagnosticMetricSet",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                xmlName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                xmlName: "values",
                xmlElementName: "DiagnosticMetricSample",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticMetricSample"
                        }
                    }
                }
            }
        }
    }
};
const DiagnosticMetricSample = {
    serializedName: "DiagnosticMetricSample",
    type: {
        name: "Composite",
        className: "DiagnosticMetricSample",
        modelProperties: {
            timestamp: {
                serializedName: "timestamp",
                xmlName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            roleInstance: {
                serializedName: "roleInstance",
                xmlName: "roleInstance",
                type: {
                    name: "String"
                }
            },
            total: {
                serializedName: "total",
                xmlName: "total",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                xmlName: "maximum",
                type: {
                    name: "Number"
                }
            },
            minimum: {
                serializedName: "minimum",
                xmlName: "minimum",
                type: {
                    name: "Number"
                }
            },
            isAggregated: {
                serializedName: "isAggregated",
                xmlName: "isAggregated",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResponseMetaData = {
    serializedName: "ResponseMetaData",
    type: {
        name: "Composite",
        className: "ResponseMetaData",
        modelProperties: {
            dataSource: {
                serializedName: "dataSource",
                xmlName: "dataSource",
                type: {
                    name: "Composite",
                    className: "DataSource"
                }
            }
        }
    }
};
const DataSource = {
    serializedName: "DataSource",
    type: {
        name: "Composite",
        className: "DataSource",
        modelProperties: {
            instructions: {
                serializedName: "instructions",
                xmlName: "instructions",
                xmlElementName: "DataSourceInstructionsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dataSourceUri: {
                serializedName: "dataSourceUri",
                xmlName: "dataSourceUri",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }
        }
    }
};
const DiagnosticDetectorCollection = {
    serializedName: "DiagnosticDetectorCollection",
    type: {
        name: "Composite",
        className: "DiagnosticDetectorCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DetectorDefinitionResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorDefinitionResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KubeEnvironmentCollection = {
    serializedName: "KubeEnvironmentCollection",
    type: {
        name: "Composite",
        className: "KubeEnvironmentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "KubeEnvironment",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KubeEnvironment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArcConfiguration = {
    serializedName: "ArcConfiguration",
    type: {
        name: "Composite",
        className: "ArcConfiguration",
        modelProperties: {
            artifactsStorageType: {
                serializedName: "artifactsStorageType",
                xmlName: "artifactsStorageType",
                type: {
                    name: "Enum",
                    allowedValues: ["LocalNode", "NetworkFileSystem"]
                }
            },
            artifactStorageClassName: {
                serializedName: "artifactStorageClassName",
                xmlName: "artifactStorageClassName",
                type: {
                    name: "String"
                }
            },
            artifactStorageMountPath: {
                serializedName: "artifactStorageMountPath",
                xmlName: "artifactStorageMountPath",
                type: {
                    name: "String"
                }
            },
            artifactStorageNodeName: {
                serializedName: "artifactStorageNodeName",
                xmlName: "artifactStorageNodeName",
                type: {
                    name: "String"
                }
            },
            artifactStorageAccessMode: {
                serializedName: "artifactStorageAccessMode",
                xmlName: "artifactStorageAccessMode",
                type: {
                    name: "String"
                }
            },
            frontEndServiceConfiguration: {
                serializedName: "frontEndServiceConfiguration",
                xmlName: "frontEndServiceConfiguration",
                type: {
                    name: "Composite",
                    className: "FrontEndConfiguration"
                }
            },
            kubeConfig: {
                serializedName: "kubeConfig",
                xmlName: "kubeConfig",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FrontEndConfiguration = {
    serializedName: "FrontEndConfiguration",
    type: {
        name: "Composite",
        className: "FrontEndConfiguration",
        modelProperties: {
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "Enum",
                    allowedValues: ["NodePort", "LoadBalancer"]
                }
            }
        }
    }
};
const AppLogsConfiguration = {
    serializedName: "AppLogsConfiguration",
    type: {
        name: "Composite",
        className: "AppLogsConfiguration",
        modelProperties: {
            destination: {
                serializedName: "destination",
                xmlName: "destination",
                type: {
                    name: "String"
                }
            },
            logAnalyticsConfiguration: {
                serializedName: "logAnalyticsConfiguration",
                xmlName: "logAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "LogAnalyticsConfiguration"
                }
            }
        }
    }
};
const LogAnalyticsConfiguration = {
    serializedName: "LogAnalyticsConfiguration",
    type: {
        name: "Composite",
        className: "LogAnalyticsConfiguration",
        modelProperties: {
            customerId: {
                serializedName: "customerId",
                xmlName: "customerId",
                type: {
                    name: "String"
                }
            },
            sharedKey: {
                serializedName: "sharedKey",
                xmlName: "sharedKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppsConfiguration = {
    serializedName: "ContainerAppsConfiguration",
    type: {
        name: "Composite",
        className: "ContainerAppsConfiguration",
        modelProperties: {
            daprAIInstrumentationKey: {
                serializedName: "daprAIInstrumentationKey",
                xmlName: "daprAIInstrumentationKey",
                type: {
                    name: "String"
                }
            },
            platformReservedCidr: {
                serializedName: "platformReservedCidr",
                xmlName: "platformReservedCidr",
                type: {
                    name: "String"
                }
            },
            platformReservedDnsIP: {
                serializedName: "platformReservedDnsIP",
                xmlName: "platformReservedDnsIP",
                type: {
                    name: "String"
                }
            },
            controlPlaneSubnetResourceId: {
                serializedName: "controlPlaneSubnetResourceId",
                xmlName: "controlPlaneSubnetResourceId",
                type: {
                    name: "String"
                }
            },
            appSubnetResourceId: {
                serializedName: "appSubnetResourceId",
                xmlName: "appSubnetResourceId",
                type: {
                    name: "String"
                }
            },
            dockerBridgeCidr: {
                serializedName: "dockerBridgeCidr",
                xmlName: "dockerBridgeCidr",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationStackCollection = {
    serializedName: "ApplicationStackCollection",
    type: {
        name: "Composite",
        className: "ApplicationStackCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ApplicationStackResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStackResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationStack = {
    serializedName: "ApplicationStack",
    type: {
        name: "Composite",
        className: "ApplicationStack",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                xmlName: "display",
                type: {
                    name: "String"
                }
            },
            dependency: {
                serializedName: "dependency",
                xmlName: "dependency",
                type: {
                    name: "String"
                }
            },
            majorVersions: {
                serializedName: "majorVersions",
                xmlName: "majorVersions",
                xmlElementName: "StackMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackMajorVersion"
                        }
                    }
                }
            },
            frameworks: {
                serializedName: "frameworks",
                xmlName: "frameworks",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack"
                        }
                    }
                }
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                xmlName: "isDeprecated",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack"
                        }
                    }
                }
            }
        }
    }
};
const StackMajorVersion = {
    serializedName: "StackMajorVersion",
    type: {
        name: "Composite",
        className: "StackMajorVersion",
        modelProperties: {
            displayVersion: {
                serializedName: "displayVersion",
                xmlName: "displayVersion",
                type: {
                    name: "String"
                }
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                xmlName: "isDefault",
                type: {
                    name: "Boolean"
                }
            },
            minorVersions: {
                serializedName: "minorVersions",
                xmlName: "minorVersions",
                xmlElementName: "StackMinorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackMinorVersion"
                        }
                    }
                }
            },
            applicationInsights: {
                serializedName: "applicationInsights",
                xmlName: "applicationInsights",
                type: {
                    name: "Boolean"
                }
            },
            isPreview: {
                serializedName: "isPreview",
                xmlName: "isPreview",
                type: {
                    name: "Boolean"
                }
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean"
                }
            },
            isHidden: {
                serializedName: "isHidden",
                xmlName: "isHidden",
                type: {
                    name: "Boolean"
                }
            },
            appSettingsDictionary: {
                serializedName: "appSettingsDictionary",
                xmlName: "appSettingsDictionary",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            siteConfigPropertiesDictionary: {
                serializedName: "siteConfigPropertiesDictionary",
                xmlName: "siteConfigPropertiesDictionary",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const StackMinorVersion = {
    serializedName: "StackMinorVersion",
    type: {
        name: "Composite",
        className: "StackMinorVersion",
        modelProperties: {
            displayVersion: {
                serializedName: "displayVersion",
                xmlName: "displayVersion",
                type: {
                    name: "String"
                }
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                xmlName: "isDefault",
                type: {
                    name: "Boolean"
                }
            },
            isRemoteDebuggingEnabled: {
                serializedName: "isRemoteDebuggingEnabled",
                xmlName: "isRemoteDebuggingEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const FunctionAppStackCollection = {
    serializedName: "FunctionAppStackCollection",
    type: {
        name: "Composite",
        className: "FunctionAppStackCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "FunctionAppStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionAppStack"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionAppMajorVersion = {
    serializedName: "FunctionAppMajorVersion",
    type: {
        name: "Composite",
        className: "FunctionAppMajorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            minorVersions: {
                serializedName: "minorVersions",
                readOnly: true,
                xmlName: "minorVersions",
                xmlElementName: "FunctionAppMinorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionAppMinorVersion"
                        }
                    }
                }
            }
        }
    }
};
const FunctionAppMinorVersion = {
    serializedName: "FunctionAppMinorVersion",
    type: {
        name: "Composite",
        className: "FunctionAppMinorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            stackSettings: {
                serializedName: "stackSettings",
                xmlName: "stackSettings",
                type: {
                    name: "Composite",
                    className: "FunctionAppRuntimes"
                }
            }
        }
    }
};
const FunctionAppRuntimes = {
    serializedName: "FunctionAppRuntimes",
    type: {
        name: "Composite",
        className: "FunctionAppRuntimes",
        modelProperties: {
            linuxRuntimeSettings: {
                serializedName: "linuxRuntimeSettings",
                xmlName: "linuxRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "FunctionAppRuntimeSettings"
                }
            },
            windowsRuntimeSettings: {
                serializedName: "windowsRuntimeSettings",
                xmlName: "windowsRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "FunctionAppRuntimeSettings"
                }
            }
        }
    }
};
const FunctionAppRuntimeSettings = {
    serializedName: "FunctionAppRuntimeSettings",
    type: {
        name: "Composite",
        className: "FunctionAppRuntimeSettings",
        modelProperties: {
            runtimeVersion: {
                serializedName: "runtimeVersion",
                readOnly: true,
                xmlName: "runtimeVersion",
                type: {
                    name: "String"
                }
            },
            remoteDebuggingSupported: {
                serializedName: "remoteDebuggingSupported",
                readOnly: true,
                xmlName: "remoteDebuggingSupported",
                type: {
                    name: "Boolean"
                }
            },
            appInsightsSettings: {
                serializedName: "appInsightsSettings",
                xmlName: "appInsightsSettings",
                type: {
                    name: "Composite",
                    className: "AppInsightsWebAppStackSettings"
                }
            },
            gitHubActionSettings: {
                serializedName: "gitHubActionSettings",
                xmlName: "gitHubActionSettings",
                type: {
                    name: "Composite",
                    className: "GitHubActionWebAppStackSettings"
                }
            },
            appSettingsDictionary: {
                serializedName: "appSettingsDictionary",
                readOnly: true,
                xmlName: "appSettingsDictionary",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            siteConfigPropertiesDictionary: {
                serializedName: "siteConfigPropertiesDictionary",
                xmlName: "siteConfigPropertiesDictionary",
                type: {
                    name: "Composite",
                    className: "SiteConfigPropertiesDictionary"
                }
            },
            supportedFunctionsExtensionVersions: {
                serializedName: "supportedFunctionsExtensionVersions",
                readOnly: true,
                xmlName: "supportedFunctionsExtensionVersions",
                xmlElementName: "FunctionAppRuntimeSettingsSupportedFunctionsExtensionVersionsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean"
                }
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean"
                }
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean"
                }
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean"
                }
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                readOnly: true,
                xmlName: "isDefault",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AppInsightsWebAppStackSettings = {
    serializedName: "AppInsightsWebAppStackSettings",
    type: {
        name: "Composite",
        className: "AppInsightsWebAppStackSettings",
        modelProperties: {
            isSupported: {
                serializedName: "isSupported",
                readOnly: true,
                xmlName: "isSupported",
                type: {
                    name: "Boolean"
                }
            },
            isDefaultOff: {
                serializedName: "isDefaultOff",
                readOnly: true,
                xmlName: "isDefaultOff",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const GitHubActionWebAppStackSettings = {
    serializedName: "GitHubActionWebAppStackSettings",
    type: {
        name: "Composite",
        className: "GitHubActionWebAppStackSettings",
        modelProperties: {
            isSupported: {
                serializedName: "isSupported",
                readOnly: true,
                xmlName: "isSupported",
                type: {
                    name: "Boolean"
                }
            },
            supportedVersion: {
                serializedName: "supportedVersion",
                readOnly: true,
                xmlName: "supportedVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteConfigPropertiesDictionary = {
    serializedName: "SiteConfigPropertiesDictionary",
    type: {
        name: "Composite",
        className: "SiteConfigPropertiesDictionary",
        modelProperties: {
            use32BitWorkerProcess: {
                serializedName: "use32BitWorkerProcess",
                readOnly: true,
                xmlName: "use32BitWorkerProcess",
                type: {
                    name: "Boolean"
                }
            },
            linuxFxVersion: {
                serializedName: "linuxFxVersion",
                readOnly: true,
                xmlName: "linuxFxVersion",
                type: {
                    name: "String"
                }
            },
            javaVersion: {
                serializedName: "javaVersion",
                readOnly: true,
                xmlName: "javaVersion",
                type: {
                    name: "String"
                }
            },
            powerShellVersion: {
                serializedName: "powerShellVersion",
                readOnly: true,
                xmlName: "powerShellVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebAppStackCollection = {
    serializedName: "WebAppStackCollection",
    type: {
        name: "Composite",
        className: "WebAppStackCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WebAppStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebAppStack"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebAppMajorVersion = {
    serializedName: "WebAppMajorVersion",
    type: {
        name: "Composite",
        className: "WebAppMajorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            minorVersions: {
                serializedName: "minorVersions",
                readOnly: true,
                xmlName: "minorVersions",
                xmlElementName: "WebAppMinorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebAppMinorVersion"
                        }
                    }
                }
            }
        }
    }
};
const WebAppMinorVersion = {
    serializedName: "WebAppMinorVersion",
    type: {
        name: "Composite",
        className: "WebAppMinorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            stackSettings: {
                serializedName: "stackSettings",
                xmlName: "stackSettings",
                type: {
                    name: "Composite",
                    className: "WebAppRuntimes"
                }
            }
        }
    }
};
const WebAppRuntimes = {
    serializedName: "WebAppRuntimes",
    type: {
        name: "Composite",
        className: "WebAppRuntimes",
        modelProperties: {
            linuxRuntimeSettings: {
                serializedName: "linuxRuntimeSettings",
                xmlName: "linuxRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "WebAppRuntimeSettings"
                }
            },
            windowsRuntimeSettings: {
                serializedName: "windowsRuntimeSettings",
                xmlName: "windowsRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "WebAppRuntimeSettings"
                }
            },
            linuxContainerSettings: {
                serializedName: "linuxContainerSettings",
                xmlName: "linuxContainerSettings",
                type: {
                    name: "Composite",
                    className: "LinuxJavaContainerSettings"
                }
            },
            windowsContainerSettings: {
                serializedName: "windowsContainerSettings",
                xmlName: "windowsContainerSettings",
                type: {
                    name: "Composite",
                    className: "WindowsJavaContainerSettings"
                }
            }
        }
    }
};
const WebAppRuntimeSettings = {
    serializedName: "WebAppRuntimeSettings",
    type: {
        name: "Composite",
        className: "WebAppRuntimeSettings",
        modelProperties: {
            runtimeVersion: {
                serializedName: "runtimeVersion",
                readOnly: true,
                xmlName: "runtimeVersion",
                type: {
                    name: "String"
                }
            },
            remoteDebuggingSupported: {
                serializedName: "remoteDebuggingSupported",
                readOnly: true,
                xmlName: "remoteDebuggingSupported",
                type: {
                    name: "Boolean"
                }
            },
            appInsightsSettings: {
                serializedName: "appInsightsSettings",
                xmlName: "appInsightsSettings",
                type: {
                    name: "Composite",
                    className: "AppInsightsWebAppStackSettings"
                }
            },
            gitHubActionSettings: {
                serializedName: "gitHubActionSettings",
                xmlName: "gitHubActionSettings",
                type: {
                    name: "Composite",
                    className: "GitHubActionWebAppStackSettings"
                }
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean"
                }
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean"
                }
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean"
                }
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean"
                }
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const LinuxJavaContainerSettings = {
    serializedName: "LinuxJavaContainerSettings",
    type: {
        name: "Composite",
        className: "LinuxJavaContainerSettings",
        modelProperties: {
            java11Runtime: {
                serializedName: "java11Runtime",
                readOnly: true,
                xmlName: "java11Runtime",
                type: {
                    name: "String"
                }
            },
            java8Runtime: {
                serializedName: "java8Runtime",
                readOnly: true,
                xmlName: "java8Runtime",
                type: {
                    name: "String"
                }
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean"
                }
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean"
                }
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean"
                }
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean"
                }
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const WindowsJavaContainerSettings = {
    serializedName: "WindowsJavaContainerSettings",
    type: {
        name: "Composite",
        className: "WindowsJavaContainerSettings",
        modelProperties: {
            javaContainer: {
                serializedName: "javaContainer",
                readOnly: true,
                xmlName: "javaContainer",
                type: {
                    name: "String"
                }
            },
            javaContainerVersion: {
                serializedName: "javaContainerVersion",
                readOnly: true,
                xmlName: "javaContainerVersion",
                type: {
                    name: "String"
                }
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean"
                }
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean"
                }
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean"
                }
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean"
                }
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RecommendationCollection = {
    serializedName: "RecommendationCollection",
    type: {
        name: "Composite",
        className: "RecommendationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Recommendation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Recommendation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceHealthMetadataCollection = {
    serializedName: "ResourceHealthMetadataCollection",
    type: {
        name: "Composite",
        className: "ResourceHealthMetadataCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceHealthMetadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceHealthMetadata"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceControlCollection = {
    serializedName: "SourceControlCollection",
    type: {
        name: "Composite",
        className: "SourceControlCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SourceControl",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceControl"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BillingMeterCollection = {
    serializedName: "BillingMeterCollection",
    type: {
        name: "Composite",
        className: "BillingMeterCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "BillingMeter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BillingMeter"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceNameAvailabilityRequest = {
    serializedName: "ResourceNameAvailabilityRequest",
    type: {
        name: "Composite",
        className: "ResourceNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            typeParam: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            isFqdn: {
                serializedName: "isFqdn",
                xmlName: "isFqdn",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResourceNameAvailability = {
    serializedName: "ResourceNameAvailability",
    type: {
        name: "Composite",
        className: "ResourceNameAvailability",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                xmlName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                xmlName: "reason",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomHostnameSitesCollection = {
    serializedName: "CustomHostnameSitesCollection",
    type: {
        name: "Composite",
        className: "CustomHostnameSitesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CustomHostnameSites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomHostnameSites"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentLocations = {
    serializedName: "DeploymentLocations",
    type: {
        name: "Composite",
        className: "DeploymentLocations",
        modelProperties: {
            locations: {
                serializedName: "locations",
                xmlName: "locations",
                xmlElementName: "GeoRegion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoRegion"
                        }
                    }
                }
            },
            hostingEnvironments: {
                serializedName: "hostingEnvironments",
                xmlName: "hostingEnvironments",
                xmlElementName: "AppServiceEnvironment",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceEnvironment"
                        }
                    }
                }
            },
            hostingEnvironmentDeploymentInfos: {
                serializedName: "hostingEnvironmentDeploymentInfos",
                xmlName: "hostingEnvironmentDeploymentInfos",
                xmlElementName: "HostingEnvironmentDeploymentInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostingEnvironmentDeploymentInfo"
                        }
                    }
                }
            }
        }
    }
};
const HostingEnvironmentDeploymentInfo = {
    serializedName: "HostingEnvironmentDeploymentInfo",
    type: {
        name: "Composite",
        className: "HostingEnvironmentDeploymentInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeoRegionCollection = {
    serializedName: "GeoRegionCollection",
    type: {
        name: "Composite",
        className: "GeoRegionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "GeoRegion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoRegion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentifierCollection = {
    serializedName: "IdentifierCollection",
    type: {
        name: "Composite",
        className: "IdentifierCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Identifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Identifier"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PremierAddOnOfferCollection = {
    serializedName: "PremierAddOnOfferCollection",
    type: {
        name: "Composite",
        className: "PremierAddOnOfferCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PremierAddOnOffer",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PremierAddOnOffer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuInfos = {
    serializedName: "SkuInfos",
    type: {
        name: "Composite",
        className: "SkuInfos",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                xmlName: "resourceType",
                type: {
                    name: "String"
                }
            },
            skus: {
                serializedName: "skus",
                xmlName: "skus",
                xmlElementName: "GlobalCsmSkuDescription",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GlobalCsmSkuDescription"
                        }
                    }
                }
            }
        }
    }
};
const GlobalCsmSkuDescription = {
    serializedName: "GlobalCsmSkuDescription",
    type: {
        name: "Composite",
        className: "GlobalCsmSkuDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                xmlName: "tier",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                xmlName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                xmlName: "family",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity"
                }
            },
            locations: {
                serializedName: "locations",
                xmlName: "locations",
                xmlElementName: "GlobalCsmSkuDescriptionLocationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                xmlName: "capabilities",
                xmlElementName: "Capability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability"
                        }
                    }
                }
            }
        }
    }
};
const CsmMoveResourceEnvelope = {
    serializedName: "CsmMoveResourceEnvelope",
    type: {
        name: "Composite",
        className: "CsmMoveResourceEnvelope",
        modelProperties: {
            targetResourceGroup: {
                constraints: {
                    Pattern: new RegExp(" ^[-\\w\\._\\(\\)]+[^\\.]$"),
                    MaxLength: 90,
                    MinLength: 1
                },
                serializedName: "targetResourceGroup",
                xmlName: "targetResourceGroup",
                type: {
                    name: "String"
                }
            },
            resources: {
                serializedName: "resources",
                xmlName: "resources",
                xmlElementName: "CsmMoveResourceEnvelopeResourcesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ValidateRequest = {
    serializedName: "ValidateRequest",
    type: {
        name: "Composite",
        className: "ValidateRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String"
                }
            },
            skuName: {
                serializedName: "properties.skuName",
                xmlName: "properties.skuName",
                type: {
                    name: "String"
                }
            },
            needLinuxWorkers: {
                serializedName: "properties.needLinuxWorkers",
                xmlName: "properties.needLinuxWorkers",
                type: {
                    name: "Boolean"
                }
            },
            isSpot: {
                serializedName: "properties.isSpot",
                xmlName: "properties.isSpot",
                type: {
                    name: "Boolean"
                }
            },
            capacity: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "properties.capacity",
                xmlName: "properties.capacity",
                type: {
                    name: "Number"
                }
            },
            hostingEnvironment: {
                serializedName: "properties.hostingEnvironment",
                xmlName: "properties.hostingEnvironment",
                type: {
                    name: "String"
                }
            },
            isXenon: {
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean"
                }
            },
            containerRegistryBaseUrl: {
                serializedName: "properties.containerRegistryBaseUrl",
                xmlName: "properties.containerRegistryBaseUrl",
                type: {
                    name: "String"
                }
            },
            containerRegistryUsername: {
                serializedName: "properties.containerRegistryUsername",
                xmlName: "properties.containerRegistryUsername",
                type: {
                    name: "String"
                }
            },
            containerRegistryPassword: {
                serializedName: "properties.containerRegistryPassword",
                xmlName: "properties.containerRegistryPassword",
                type: {
                    name: "String"
                }
            },
            containerImageRepository: {
                serializedName: "properties.containerImageRepository",
                xmlName: "properties.containerImageRepository",
                type: {
                    name: "String"
                }
            },
            containerImageTag: {
                serializedName: "properties.containerImageTag",
                xmlName: "properties.containerImageTag",
                type: {
                    name: "String"
                }
            },
            containerImagePlatform: {
                serializedName: "properties.containerImagePlatform",
                xmlName: "properties.containerImagePlatform",
                type: {
                    name: "String"
                }
            },
            appServiceEnvironment: {
                serializedName: "properties.appServiceEnvironment",
                xmlName: "properties.appServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "AppServiceEnvironment"
                }
            }
        }
    }
};
const ValidateResponse = {
    serializedName: "ValidateResponse",
    type: {
        name: "Composite",
        className: "ValidateResponse",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ValidateResponseError"
                }
            }
        }
    }
};
const ValidateResponseError = {
    serializedName: "ValidateResponseError",
    type: {
        name: "Composite",
        className: "ValidateResponseError",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteBuildProperties = {
    serializedName: "StaticSiteBuildProperties",
    type: {
        name: "Composite",
        className: "StaticSiteBuildProperties",
        modelProperties: {
            appLocation: {
                serializedName: "appLocation",
                xmlName: "appLocation",
                type: {
                    name: "String"
                }
            },
            apiLocation: {
                serializedName: "apiLocation",
                xmlName: "apiLocation",
                type: {
                    name: "String"
                }
            },
            appArtifactLocation: {
                serializedName: "appArtifactLocation",
                xmlName: "appArtifactLocation",
                type: {
                    name: "String"
                }
            },
            outputLocation: {
                serializedName: "outputLocation",
                xmlName: "outputLocation",
                type: {
                    name: "String"
                }
            },
            appBuildCommand: {
                serializedName: "appBuildCommand",
                xmlName: "appBuildCommand",
                type: {
                    name: "String"
                }
            },
            apiBuildCommand: {
                serializedName: "apiBuildCommand",
                xmlName: "apiBuildCommand",
                type: {
                    name: "String"
                }
            },
            skipGithubActionWorkflowGeneration: {
                serializedName: "skipGithubActionWorkflowGeneration",
                xmlName: "skipGithubActionWorkflowGeneration",
                type: {
                    name: "Boolean"
                }
            },
            githubActionSecretNameOverride: {
                serializedName: "githubActionSecretNameOverride",
                xmlName: "githubActionSecretNameOverride",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteCollection = {
    serializedName: "StaticSiteCollection",
    type: {
        name: "Composite",
        className: "StaticSiteCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResponseMessageEnvelopeRemotePrivateEndpointConnection = {
    serializedName: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
    type: {
        name: "Composite",
        className: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            plan: {
                serializedName: "plan",
                xmlName: "plan",
                type: {
                    name: "Composite",
                    className: "ArmPlan"
                }
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "RemotePrivateEndpointConnection"
                }
            },
            sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription"
                }
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorEntity"
                }
            },
            identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            },
            zones: {
                serializedName: "zones",
                xmlName: "zones",
                xmlElementName: "ResponseMessageEnvelopeRemotePrivateEndpointConnectionZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ArmPlan = {
    serializedName: "ArmPlan",
    type: {
        name: "Composite",
        className: "ArmPlan",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                xmlName: "publisher",
                type: {
                    name: "String"
                }
            },
            product: {
                serializedName: "product",
                xmlName: "product",
                type: {
                    name: "String"
                }
            },
            promotionCode: {
                serializedName: "promotionCode",
                xmlName: "promotionCode",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                xmlName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteTemplateOptions = {
    serializedName: "StaticSiteTemplateOptions",
    type: {
        name: "Composite",
        className: "StaticSiteTemplateOptions",
        modelProperties: {
            templateRepositoryUrl: {
                serializedName: "templateRepositoryUrl",
                xmlName: "templateRepositoryUrl",
                type: {
                    name: "String"
                }
            },
            owner: {
                serializedName: "owner",
                xmlName: "owner",
                type: {
                    name: "String"
                }
            },
            repositoryName: {
                serializedName: "repositoryName",
                xmlName: "repositoryName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            isPrivate: {
                serializedName: "isPrivate",
                xmlName: "isPrivate",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const StaticSiteLinkedBackend = {
    serializedName: "StaticSiteLinkedBackend",
    type: {
        name: "Composite",
        className: "StaticSiteLinkedBackend",
        modelProperties: {
            backendResourceId: {
                serializedName: "backendResourceId",
                xmlName: "backendResourceId",
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                xmlName: "region",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                readOnly: true,
                xmlName: "createdOn",
                type: {
                    name: "DateTime"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteUserCollection = {
    serializedName: "StaticSiteUserCollection",
    type: {
        name: "Composite",
        className: "StaticSiteUserCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteUserARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteBuildCollection = {
    serializedName: "StaticSiteBuildCollection",
    type: {
        name: "Composite",
        className: "StaticSiteBuildCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteBuildARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteBuildARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteFunctionOverviewCollection = {
    serializedName: "StaticSiteFunctionOverviewCollection",
    type: {
        name: "Composite",
        className: "StaticSiteFunctionOverviewCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteFunctionOverviewARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteFunctionOverviewARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteUserProvidedFunctionAppsCollection = {
    serializedName: "StaticSiteUserProvidedFunctionAppsCollection",
    type: {
        name: "Composite",
        className: "StaticSiteUserProvidedFunctionAppsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteUserProvidedFunctionAppARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionAppARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteCustomDomainOverviewCollection = {
    serializedName: "StaticSiteCustomDomainOverviewCollection",
    type: {
        name: "Composite",
        className: "StaticSiteCustomDomainOverviewCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteCustomDomainOverviewARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteCustomDomainOverviewARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticSiteLinkedBackendsCollection = {
    serializedName: "StaticSiteLinkedBackendsCollection",
    type: {
        name: "Composite",
        className: "StaticSiteLinkedBackendsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteLinkedBackendARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackendARMResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmSlotEntity = {
    serializedName: "CsmSlotEntity",
    type: {
        name: "Composite",
        className: "CsmSlotEntity",
        modelProperties: {
            targetSlot: {
                serializedName: "targetSlot",
                required: true,
                xmlName: "targetSlot",
                type: {
                    name: "String"
                }
            },
            preserveVnet: {
                serializedName: "preserveVnet",
                required: true,
                xmlName: "preserveVnet",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const BackupSchedule = {
    serializedName: "BackupSchedule",
    type: {
        name: "Composite",
        className: "BackupSchedule",
        modelProperties: {
            frequencyInterval: {
                defaultValue: 7,
                serializedName: "frequencyInterval",
                required: true,
                xmlName: "frequencyInterval",
                type: {
                    name: "Number"
                }
            },
            frequencyUnit: {
                defaultValue: "Day",
                serializedName: "frequencyUnit",
                required: true,
                xmlName: "frequencyUnit",
                type: {
                    name: "Enum",
                    allowedValues: ["Day", "Hour"]
                }
            },
            keepAtLeastOneBackup: {
                defaultValue: true,
                serializedName: "keepAtLeastOneBackup",
                required: true,
                xmlName: "keepAtLeastOneBackup",
                type: {
                    name: "Boolean"
                }
            },
            retentionPeriodInDays: {
                defaultValue: 30,
                serializedName: "retentionPeriodInDays",
                required: true,
                xmlName: "retentionPeriodInDays",
                type: {
                    name: "Number"
                }
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            lastExecutionTime: {
                serializedName: "lastExecutionTime",
                readOnly: true,
                xmlName: "lastExecutionTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DatabaseBackupSetting = {
    serializedName: "DatabaseBackupSetting",
    type: {
        name: "Composite",
        className: "DatabaseBackupSetting",
        modelProperties: {
            databaseType: {
                serializedName: "databaseType",
                required: true,
                xmlName: "databaseType",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            connectionStringName: {
                serializedName: "connectionStringName",
                xmlName: "connectionStringName",
                type: {
                    name: "String"
                }
            },
            connectionString: {
                serializedName: "connectionString",
                xmlName: "connectionString",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupItemCollection = {
    serializedName: "BackupItemCollection",
    type: {
        name: "Composite",
        className: "BackupItemCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "BackupItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublishingCredentialsPoliciesCollection = {
    serializedName: "PublishingCredentialsPoliciesCollection",
    type: {
        name: "Composite",
        className: "PublishingCredentialsPoliciesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmPublishingCredentialsPoliciesEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmPublishingCredentialsPoliciesEntity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteConfigResourceCollection = {
    serializedName: "SiteConfigResourceCollection",
    type: {
        name: "Composite",
        className: "SiteConfigResourceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteConfigResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteConfigResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthPlatform = {
    serializedName: "AuthPlatform",
    type: {
        name: "Composite",
        className: "AuthPlatform",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String"
                }
            },
            configFilePath: {
                serializedName: "configFilePath",
                xmlName: "configFilePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GlobalValidation = {
    serializedName: "GlobalValidation",
    type: {
        name: "Composite",
        className: "GlobalValidation",
        modelProperties: {
            requireAuthentication: {
                serializedName: "requireAuthentication",
                xmlName: "requireAuthentication",
                type: {
                    name: "Boolean"
                }
            },
            unauthenticatedClientAction: {
                serializedName: "unauthenticatedClientAction",
                xmlName: "unauthenticatedClientAction",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "RedirectToLoginPage",
                        "AllowAnonymous",
                        "Return401",
                        "Return403"
                    ]
                }
            },
            redirectToProvider: {
                serializedName: "redirectToProvider",
                xmlName: "redirectToProvider",
                type: {
                    name: "String"
                }
            },
            excludedPaths: {
                serializedName: "excludedPaths",
                xmlName: "excludedPaths",
                xmlElementName: "GlobalValidationExcludedPathsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const IdentityProviders = {
    serializedName: "IdentityProviders",
    type: {
        name: "Composite",
        className: "IdentityProviders",
        modelProperties: {
            azureActiveDirectory: {
                serializedName: "azureActiveDirectory",
                xmlName: "azureActiveDirectory",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectory"
                }
            },
            facebook: {
                serializedName: "facebook",
                xmlName: "facebook",
                type: {
                    name: "Composite",
                    className: "Facebook"
                }
            },
            gitHub: {
                serializedName: "gitHub",
                xmlName: "gitHub",
                type: {
                    name: "Composite",
                    className: "GitHub"
                }
            },
            google: {
                serializedName: "google",
                xmlName: "google",
                type: {
                    name: "Composite",
                    className: "Google"
                }
            },
            legacyMicrosoftAccount: {
                serializedName: "legacyMicrosoftAccount",
                xmlName: "legacyMicrosoftAccount",
                type: {
                    name: "Composite",
                    className: "LegacyMicrosoftAccount"
                }
            },
            twitter: {
                serializedName: "twitter",
                xmlName: "twitter",
                type: {
                    name: "Composite",
                    className: "Twitter"
                }
            },
            apple: {
                serializedName: "apple",
                xmlName: "apple",
                type: {
                    name: "Composite",
                    className: "Apple"
                }
            },
            azureStaticWebApps: {
                serializedName: "azureStaticWebApps",
                xmlName: "azureStaticWebApps",
                type: {
                    name: "Composite",
                    className: "AzureStaticWebApps"
                }
            },
            customOpenIdConnectProviders: {
                serializedName: "customOpenIdConnectProviders",
                xmlName: "customOpenIdConnectProviders",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "CustomOpenIdConnectProvider"
                        }
                    }
                }
            }
        }
    }
};
const AzureActiveDirectory = {
    serializedName: "AzureActiveDirectory",
    type: {
        name: "Composite",
        className: "AzureActiveDirectory",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryRegistration"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryLogin"
                }
            },
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryValidation"
                }
            },
            isAutoProvisioned: {
                serializedName: "isAutoProvisioned",
                xmlName: "isAutoProvisioned",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AzureActiveDirectoryRegistration = {
    serializedName: "AzureActiveDirectoryRegistration",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryRegistration",
        modelProperties: {
            openIdIssuer: {
                serializedName: "openIdIssuer",
                xmlName: "openIdIssuer",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            },
            clientSecretCertificateThumbprint: {
                serializedName: "clientSecretCertificateThumbprint",
                xmlName: "clientSecretCertificateThumbprint",
                type: {
                    name: "String"
                }
            },
            clientSecretCertificateSubjectAlternativeName: {
                serializedName: "clientSecretCertificateSubjectAlternativeName",
                xmlName: "clientSecretCertificateSubjectAlternativeName",
                type: {
                    name: "String"
                }
            },
            clientSecretCertificateIssuer: {
                serializedName: "clientSecretCertificateIssuer",
                xmlName: "clientSecretCertificateIssuer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureActiveDirectoryLogin = {
    serializedName: "AzureActiveDirectoryLogin",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryLogin",
        modelProperties: {
            loginParameters: {
                serializedName: "loginParameters",
                xmlName: "loginParameters",
                xmlElementName: "AzureActiveDirectoryLoginParametersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            disableWWWAuthenticate: {
                serializedName: "disableWWWAuthenticate",
                xmlName: "disableWWWAuthenticate",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AzureActiveDirectoryValidation = {
    serializedName: "AzureActiveDirectoryValidation",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryValidation",
        modelProperties: {
            jwtClaimChecks: {
                serializedName: "jwtClaimChecks",
                xmlName: "jwtClaimChecks",
                type: {
                    name: "Composite",
                    className: "JwtClaimChecks"
                }
            },
            allowedAudiences: {
                serializedName: "allowedAudiences",
                xmlName: "allowedAudiences",
                xmlElementName: "AzureActiveDirectoryValidationAllowedAudiencesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            defaultAuthorizationPolicy: {
                serializedName: "defaultAuthorizationPolicy",
                xmlName: "defaultAuthorizationPolicy",
                type: {
                    name: "Composite",
                    className: "DefaultAuthorizationPolicy"
                }
            }
        }
    }
};
const JwtClaimChecks = {
    serializedName: "JwtClaimChecks",
    type: {
        name: "Composite",
        className: "JwtClaimChecks",
        modelProperties: {
            allowedGroups: {
                serializedName: "allowedGroups",
                xmlName: "allowedGroups",
                xmlElementName: "JwtClaimChecksAllowedGroupsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedClientApplications: {
                serializedName: "allowedClientApplications",
                xmlName: "allowedClientApplications",
                xmlElementName: "JwtClaimChecksAllowedClientApplicationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DefaultAuthorizationPolicy = {
    serializedName: "DefaultAuthorizationPolicy",
    type: {
        name: "Composite",
        className: "DefaultAuthorizationPolicy",
        modelProperties: {
            allowedPrincipals: {
                serializedName: "allowedPrincipals",
                xmlName: "allowedPrincipals",
                type: {
                    name: "Composite",
                    className: "AllowedPrincipals"
                }
            },
            allowedApplications: {
                serializedName: "allowedApplications",
                xmlName: "allowedApplications",
                xmlElementName: "DefaultAuthorizationPolicyAllowedApplicationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AllowedPrincipals = {
    serializedName: "AllowedPrincipals",
    type: {
        name: "Composite",
        className: "AllowedPrincipals",
        modelProperties: {
            groups: {
                serializedName: "groups",
                xmlName: "groups",
                xmlElementName: "AllowedPrincipalsGroupsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            identities: {
                serializedName: "identities",
                xmlName: "identities",
                xmlElementName: "AllowedPrincipalsIdentitiesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Facebook = {
    serializedName: "Facebook",
    type: {
        name: "Composite",
        className: "Facebook",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AppRegistration"
                }
            },
            graphApiVersion: {
                serializedName: "graphApiVersion",
                xmlName: "graphApiVersion",
                type: {
                    name: "String"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            }
        }
    }
};
const AppRegistration = {
    serializedName: "AppRegistration",
    type: {
        name: "Composite",
        className: "AppRegistration",
        modelProperties: {
            appId: {
                serializedName: "appId",
                xmlName: "appId",
                type: {
                    name: "String"
                }
            },
            appSecretSettingName: {
                serializedName: "appSecretSettingName",
                xmlName: "appSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoginScopes = {
    serializedName: "LoginScopes",
    type: {
        name: "Composite",
        className: "LoginScopes",
        modelProperties: {
            scopes: {
                serializedName: "scopes",
                xmlName: "scopes",
                xmlElementName: "LoginScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const GitHub = {
    serializedName: "GitHub",
    type: {
        name: "Composite",
        className: "GitHub",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            }
        }
    }
};
const ClientRegistration = {
    serializedName: "ClientRegistration",
    type: {
        name: "Composite",
        className: "ClientRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Google = {
    serializedName: "Google",
    type: {
        name: "Composite",
        className: "Google",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            },
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "Composite",
                    className: "AllowedAudiencesValidation"
                }
            }
        }
    }
};
const AllowedAudiencesValidation = {
    serializedName: "AllowedAudiencesValidation",
    type: {
        name: "Composite",
        className: "AllowedAudiencesValidation",
        modelProperties: {
            allowedAudiences: {
                serializedName: "allowedAudiences",
                xmlName: "allowedAudiences",
                xmlElementName: "AllowedAudiencesValidationAllowedAudiencesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const LegacyMicrosoftAccount = {
    serializedName: "LegacyMicrosoftAccount",
    type: {
        name: "Composite",
        className: "LegacyMicrosoftAccount",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            },
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "Composite",
                    className: "AllowedAudiencesValidation"
                }
            }
        }
    }
};
const Twitter = {
    serializedName: "Twitter",
    type: {
        name: "Composite",
        className: "Twitter",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "TwitterRegistration"
                }
            }
        }
    }
};
const TwitterRegistration = {
    serializedName: "TwitterRegistration",
    type: {
        name: "Composite",
        className: "TwitterRegistration",
        modelProperties: {
            consumerKey: {
                serializedName: "consumerKey",
                xmlName: "consumerKey",
                type: {
                    name: "String"
                }
            },
            consumerSecretSettingName: {
                serializedName: "consumerSecretSettingName",
                xmlName: "consumerSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Apple = {
    serializedName: "Apple",
    type: {
        name: "Composite",
        className: "Apple",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AppleRegistration"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            }
        }
    }
};
const AppleRegistration = {
    serializedName: "AppleRegistration",
    type: {
        name: "Composite",
        className: "AppleRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureStaticWebApps = {
    serializedName: "AzureStaticWebApps",
    type: {
        name: "Composite",
        className: "AzureStaticWebApps",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AzureStaticWebAppsRegistration"
                }
            }
        }
    }
};
const AzureStaticWebAppsRegistration = {
    serializedName: "AzureStaticWebAppsRegistration",
    type: {
        name: "Composite",
        className: "AzureStaticWebAppsRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomOpenIdConnectProvider = {
    serializedName: "CustomOpenIdConnectProvider",
    type: {
        name: "Composite",
        className: "CustomOpenIdConnectProvider",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectRegistration"
                }
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectLogin"
                }
            }
        }
    }
};
const OpenIdConnectRegistration = {
    serializedName: "OpenIdConnectRegistration",
    type: {
        name: "Composite",
        className: "OpenIdConnectRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientCredential: {
                serializedName: "clientCredential",
                xmlName: "clientCredential",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectClientCredential"
                }
            },
            openIdConnectConfiguration: {
                serializedName: "openIdConnectConfiguration",
                xmlName: "openIdConnectConfiguration",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectConfig"
                }
            }
        }
    }
};
const OpenIdConnectClientCredential = {
    serializedName: "OpenIdConnectClientCredential",
    type: {
        name: "Composite",
        className: "OpenIdConnectClientCredential",
        modelProperties: {
            method: {
                defaultValue: "ClientSecretPost",
                isConstant: true,
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectConfig = {
    serializedName: "OpenIdConnectConfig",
    type: {
        name: "Composite",
        className: "OpenIdConnectConfig",
        modelProperties: {
            authorizationEndpoint: {
                serializedName: "authorizationEndpoint",
                xmlName: "authorizationEndpoint",
                type: {
                    name: "String"
                }
            },
            tokenEndpoint: {
                serializedName: "tokenEndpoint",
                xmlName: "tokenEndpoint",
                type: {
                    name: "String"
                }
            },
            issuer: {
                serializedName: "issuer",
                xmlName: "issuer",
                type: {
                    name: "String"
                }
            },
            certificationUri: {
                serializedName: "certificationUri",
                xmlName: "certificationUri",
                type: {
                    name: "String"
                }
            },
            wellKnownOpenIdConfiguration: {
                serializedName: "wellKnownOpenIdConfiguration",
                xmlName: "wellKnownOpenIdConfiguration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectLogin = {
    serializedName: "OpenIdConnectLogin",
    type: {
        name: "Composite",
        className: "OpenIdConnectLogin",
        modelProperties: {
            nameClaimType: {
                serializedName: "nameClaimType",
                xmlName: "nameClaimType",
                type: {
                    name: "String"
                }
            },
            scopes: {
                serializedName: "scopes",
                xmlName: "scopes",
                xmlElementName: "OpenIdConnectLoginScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Login = {
    serializedName: "Login",
    type: {
        name: "Composite",
        className: "Login",
        modelProperties: {
            routes: {
                serializedName: "routes",
                xmlName: "routes",
                type: {
                    name: "Composite",
                    className: "LoginRoutes"
                }
            },
            tokenStore: {
                serializedName: "tokenStore",
                xmlName: "tokenStore",
                type: {
                    name: "Composite",
                    className: "TokenStore"
                }
            },
            preserveUrlFragmentsForLogins: {
                serializedName: "preserveUrlFragmentsForLogins",
                xmlName: "preserveUrlFragmentsForLogins",
                type: {
                    name: "Boolean"
                }
            },
            allowedExternalRedirectUrls: {
                serializedName: "allowedExternalRedirectUrls",
                xmlName: "allowedExternalRedirectUrls",
                xmlElementName: "LoginAllowedExternalRedirectUrlsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cookieExpiration: {
                serializedName: "cookieExpiration",
                xmlName: "cookieExpiration",
                type: {
                    name: "Composite",
                    className: "CookieExpiration"
                }
            },
            nonce: {
                serializedName: "nonce",
                xmlName: "nonce",
                type: {
                    name: "Composite",
                    className: "Nonce"
                }
            }
        }
    }
};
const LoginRoutes = {
    serializedName: "LoginRoutes",
    type: {
        name: "Composite",
        className: "LoginRoutes",
        modelProperties: {
            logoutEndpoint: {
                serializedName: "logoutEndpoint",
                xmlName: "logoutEndpoint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TokenStore = {
    serializedName: "TokenStore",
    type: {
        name: "Composite",
        className: "TokenStore",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            tokenRefreshExtensionHours: {
                serializedName: "tokenRefreshExtensionHours",
                xmlName: "tokenRefreshExtensionHours",
                type: {
                    name: "Number"
                }
            },
            fileSystem: {
                serializedName: "fileSystem",
                xmlName: "fileSystem",
                type: {
                    name: "Composite",
                    className: "FileSystemTokenStore"
                }
            },
            azureBlobStorage: {
                serializedName: "azureBlobStorage",
                xmlName: "azureBlobStorage",
                type: {
                    name: "Composite",
                    className: "BlobStorageTokenStore"
                }
            }
        }
    }
};
const FileSystemTokenStore = {
    serializedName: "FileSystemTokenStore",
    type: {
        name: "Composite",
        className: "FileSystemTokenStore",
        modelProperties: {
            directory: {
                serializedName: "directory",
                xmlName: "directory",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobStorageTokenStore = {
    serializedName: "BlobStorageTokenStore",
    type: {
        name: "Composite",
        className: "BlobStorageTokenStore",
        modelProperties: {
            sasUrlSettingName: {
                serializedName: "sasUrlSettingName",
                xmlName: "sasUrlSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CookieExpiration = {
    serializedName: "CookieExpiration",
    type: {
        name: "Composite",
        className: "CookieExpiration",
        modelProperties: {
            convention: {
                serializedName: "convention",
                xmlName: "convention",
                type: {
                    name: "Enum",
                    allowedValues: ["FixedTime", "IdentityProviderDerived"]
                }
            },
            timeToExpiration: {
                serializedName: "timeToExpiration",
                xmlName: "timeToExpiration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Nonce = {
    serializedName: "Nonce",
    type: {
        name: "Composite",
        className: "Nonce",
        modelProperties: {
            validateNonce: {
                serializedName: "validateNonce",
                xmlName: "validateNonce",
                type: {
                    name: "Boolean"
                }
            },
            nonceExpirationInterval: {
                serializedName: "nonceExpirationInterval",
                xmlName: "nonceExpirationInterval",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HttpSettings = {
    serializedName: "HttpSettings",
    type: {
        name: "Composite",
        className: "HttpSettings",
        modelProperties: {
            requireHttps: {
                serializedName: "requireHttps",
                xmlName: "requireHttps",
                type: {
                    name: "Boolean"
                }
            },
            routes: {
                serializedName: "routes",
                xmlName: "routes",
                type: {
                    name: "Composite",
                    className: "HttpSettingsRoutes"
                }
            },
            forwardProxy: {
                serializedName: "forwardProxy",
                xmlName: "forwardProxy",
                type: {
                    name: "Composite",
                    className: "ForwardProxy"
                }
            }
        }
    }
};
const HttpSettingsRoutes = {
    serializedName: "HttpSettingsRoutes",
    type: {
        name: "Composite",
        className: "HttpSettingsRoutes",
        modelProperties: {
            apiPrefix: {
                serializedName: "apiPrefix",
                xmlName: "apiPrefix",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ForwardProxy = {
    serializedName: "ForwardProxy",
    type: {
        name: "Composite",
        className: "ForwardProxy",
        modelProperties: {
            convention: {
                serializedName: "convention",
                xmlName: "convention",
                type: {
                    name: "Enum",
                    allowedValues: ["NoProxy", "Standard", "Custom"]
                }
            },
            customHostHeaderName: {
                serializedName: "customHostHeaderName",
                xmlName: "customHostHeaderName",
                type: {
                    name: "String"
                }
            },
            customProtoHeaderName: {
                serializedName: "customProtoHeaderName",
                xmlName: "customProtoHeaderName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiKVReferenceCollection = {
    serializedName: "ApiKVReferenceCollection",
    type: {
        name: "Composite",
        className: "ApiKVReferenceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ApiKVReference",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiKVReference"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnStringValueTypePair = {
    serializedName: "ConnStringValueTypePair",
    type: {
        name: "Composite",
        className: "ConnStringValueTypePair",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "MySql",
                        "SQLServer",
                        "SQLAzure",
                        "Custom",
                        "NotificationHub",
                        "ServiceBus",
                        "EventHub",
                        "ApiHub",
                        "DocDb",
                        "RedisCache",
                        "PostgreSQL"
                    ]
                }
            }
        }
    }
};
const ApplicationLogsConfig = {
    serializedName: "ApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "ApplicationLogsConfig",
        modelProperties: {
            fileSystem: {
                serializedName: "fileSystem",
                xmlName: "fileSystem",
                type: {
                    name: "Composite",
                    className: "FileSystemApplicationLogsConfig"
                }
            },
            azureTableStorage: {
                serializedName: "azureTableStorage",
                xmlName: "azureTableStorage",
                type: {
                    name: "Composite",
                    className: "AzureTableStorageApplicationLogsConfig"
                }
            },
            azureBlobStorage: {
                serializedName: "azureBlobStorage",
                xmlName: "azureBlobStorage",
                type: {
                    name: "Composite",
                    className: "AzureBlobStorageApplicationLogsConfig"
                }
            }
        }
    }
};
const FileSystemApplicationLogsConfig = {
    serializedName: "FileSystemApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "FileSystemApplicationLogsConfig",
        modelProperties: {
            level: {
                serializedName: "level",
                xmlName: "level",
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "Verbose", "Information", "Warning", "Error"]
                }
            }
        }
    }
};
const AzureTableStorageApplicationLogsConfig = {
    serializedName: "AzureTableStorageApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "AzureTableStorageApplicationLogsConfig",
        modelProperties: {
            level: {
                serializedName: "level",
                xmlName: "level",
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "Verbose", "Information", "Warning", "Error"]
                }
            },
            sasUrl: {
                serializedName: "sasUrl",
                required: true,
                xmlName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureBlobStorageApplicationLogsConfig = {
    serializedName: "AzureBlobStorageApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "AzureBlobStorageApplicationLogsConfig",
        modelProperties: {
            level: {
                serializedName: "level",
                xmlName: "level",
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "Verbose", "Information", "Warning", "Error"]
                }
            },
            sasUrl: {
                serializedName: "sasUrl",
                xmlName: "sasUrl",
                type: {
                    name: "String"
                }
            },
            retentionInDays: {
                serializedName: "retentionInDays",
                xmlName: "retentionInDays",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HttpLogsConfig = {
    serializedName: "HttpLogsConfig",
    type: {
        name: "Composite",
        className: "HttpLogsConfig",
        modelProperties: {
            fileSystem: {
                serializedName: "fileSystem",
                xmlName: "fileSystem",
                type: {
                    name: "Composite",
                    className: "FileSystemHttpLogsConfig"
                }
            },
            azureBlobStorage: {
                serializedName: "azureBlobStorage",
                xmlName: "azureBlobStorage",
                type: {
                    name: "Composite",
                    className: "AzureBlobStorageHttpLogsConfig"
                }
            }
        }
    }
};
const FileSystemHttpLogsConfig = {
    serializedName: "FileSystemHttpLogsConfig",
    type: {
        name: "Composite",
        className: "FileSystemHttpLogsConfig",
        modelProperties: {
            retentionInMb: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 25
                },
                serializedName: "retentionInMb",
                xmlName: "retentionInMb",
                type: {
                    name: "Number"
                }
            },
            retentionInDays: {
                serializedName: "retentionInDays",
                xmlName: "retentionInDays",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AzureBlobStorageHttpLogsConfig = {
    serializedName: "AzureBlobStorageHttpLogsConfig",
    type: {
        name: "Composite",
        className: "AzureBlobStorageHttpLogsConfig",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                xmlName: "sasUrl",
                type: {
                    name: "String"
                }
            },
            retentionInDays: {
                serializedName: "retentionInDays",
                xmlName: "retentionInDays",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EnabledConfig = {
    serializedName: "EnabledConfig",
    type: {
        name: "Composite",
        className: "EnabledConfig",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SiteConfigurationSnapshotInfoCollection = {
    serializedName: "SiteConfigurationSnapshotInfoCollection",
    type: {
        name: "Composite",
        className: "SiteConfigurationSnapshotInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteConfigurationSnapshotInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteConfigurationSnapshotInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContinuousWebJobCollection = {
    serializedName: "ContinuousWebJobCollection",
    type: {
        name: "Composite",
        className: "ContinuousWebJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ContinuousWebJob",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContinuousWebJob"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmDeploymentStatusCollection = {
    serializedName: "CsmDeploymentStatusCollection",
    type: {
        name: "Composite",
        className: "CsmDeploymentStatusCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmDeploymentStatus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmDeploymentStatus"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentCollection = {
    serializedName: "DeploymentCollection",
    type: {
        name: "Composite",
        className: "DeploymentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Deployment",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Deployment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MSDeployLogEntry = {
    serializedName: "MSDeployLogEntry",
    type: {
        name: "Composite",
        className: "MSDeployLogEntry",
        modelProperties: {
            time: {
                serializedName: "time",
                readOnly: true,
                xmlName: "time",
                type: {
                    name: "DateTime"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["Message", "Warning", "Error"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionEnvelopeCollection = {
    serializedName: "FunctionEnvelopeCollection",
    type: {
        name: "Composite",
        className: "FunctionEnvelopeCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "FunctionEnvelope",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionEnvelope"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyInfo = {
    serializedName: "KeyInfo",
    type: {
        name: "Composite",
        className: "KeyInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionSecrets = {
    serializedName: "FunctionSecrets",
    type: {
        name: "Composite",
        className: "FunctionSecrets",
        modelProperties: {
            key: {
                serializedName: "key",
                xmlName: "key",
                type: {
                    name: "String"
                }
            },
            triggerUrl: {
                serializedName: "trigger_url",
                xmlName: "trigger_url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HostKeys = {
    serializedName: "HostKeys",
    type: {
        name: "Composite",
        className: "HostKeys",
        modelProperties: {
            masterKey: {
                serializedName: "masterKey",
                xmlName: "masterKey",
                type: {
                    name: "String"
                }
            },
            functionKeys: {
                serializedName: "functionKeys",
                xmlName: "functionKeys",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemKeys: {
                serializedName: "systemKeys",
                xmlName: "systemKeys",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const HostNameBindingCollection = {
    serializedName: "HostNameBindingCollection",
    type: {
        name: "Composite",
        className: "HostNameBindingCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "HostNameBinding",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostNameBinding"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebAppInstanceStatusCollection = {
    serializedName: "WebAppInstanceStatusCollection",
    type: {
        name: "Composite",
        className: "WebAppInstanceStatusCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WebSiteInstanceStatus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebSiteInstanceStatus"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerInfo = {
    serializedName: "ContainerInfo",
    type: {
        name: "Composite",
        className: "ContainerInfo",
        modelProperties: {
            currentTimeStamp: {
                serializedName: "currentTimeStamp",
                xmlName: "currentTimeStamp",
                type: {
                    name: "DateTime"
                }
            },
            previousTimeStamp: {
                serializedName: "previousTimeStamp",
                xmlName: "previousTimeStamp",
                type: {
                    name: "DateTime"
                }
            },
            currentCpuStats: {
                serializedName: "currentCpuStats",
                xmlName: "currentCpuStats",
                type: {
                    name: "Composite",
                    className: "ContainerCpuStatistics"
                }
            },
            previousCpuStats: {
                serializedName: "previousCpuStats",
                xmlName: "previousCpuStats",
                type: {
                    name: "Composite",
                    className: "ContainerCpuStatistics"
                }
            },
            memoryStats: {
                serializedName: "memoryStats",
                xmlName: "memoryStats",
                type: {
                    name: "Composite",
                    className: "ContainerMemoryStatistics"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            eth0: {
                serializedName: "eth0",
                xmlName: "eth0",
                type: {
                    name: "Composite",
                    className: "ContainerNetworkInterfaceStatistics"
                }
            }
        }
    }
};
const ContainerCpuStatistics = {
    serializedName: "ContainerCpuStatistics",
    type: {
        name: "Composite",
        className: "ContainerCpuStatistics",
        modelProperties: {
            cpuUsage: {
                serializedName: "cpuUsage",
                xmlName: "cpuUsage",
                type: {
                    name: "Composite",
                    className: "ContainerCpuUsage"
                }
            },
            systemCpuUsage: {
                serializedName: "systemCpuUsage",
                xmlName: "systemCpuUsage",
                type: {
                    name: "Number"
                }
            },
            onlineCpuCount: {
                serializedName: "onlineCpuCount",
                xmlName: "onlineCpuCount",
                type: {
                    name: "Number"
                }
            },
            throttlingData: {
                serializedName: "throttlingData",
                xmlName: "throttlingData",
                type: {
                    name: "Composite",
                    className: "ContainerThrottlingData"
                }
            }
        }
    }
};
const ContainerCpuUsage = {
    serializedName: "ContainerCpuUsage",
    type: {
        name: "Composite",
        className: "ContainerCpuUsage",
        modelProperties: {
            totalUsage: {
                serializedName: "totalUsage",
                xmlName: "totalUsage",
                type: {
                    name: "Number"
                }
            },
            perCpuUsage: {
                serializedName: "perCpuUsage",
                xmlName: "perCpuUsage",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            kernelModeUsage: {
                serializedName: "kernelModeUsage",
                xmlName: "kernelModeUsage",
                type: {
                    name: "Number"
                }
            },
            userModeUsage: {
                serializedName: "userModeUsage",
                xmlName: "userModeUsage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerThrottlingData = {
    serializedName: "ContainerThrottlingData",
    type: {
        name: "Composite",
        className: "ContainerThrottlingData",
        modelProperties: {
            periods: {
                serializedName: "periods",
                xmlName: "periods",
                type: {
                    name: "Number"
                }
            },
            throttledPeriods: {
                serializedName: "throttledPeriods",
                xmlName: "throttledPeriods",
                type: {
                    name: "Number"
                }
            },
            throttledTime: {
                serializedName: "throttledTime",
                xmlName: "throttledTime",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerMemoryStatistics = {
    serializedName: "ContainerMemoryStatistics",
    type: {
        name: "Composite",
        className: "ContainerMemoryStatistics",
        modelProperties: {
            usage: {
                serializedName: "usage",
                xmlName: "usage",
                type: {
                    name: "Number"
                }
            },
            maxUsage: {
                serializedName: "maxUsage",
                xmlName: "maxUsage",
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                xmlName: "limit",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerNetworkInterfaceStatistics = {
    serializedName: "ContainerNetworkInterfaceStatistics",
    type: {
        name: "Composite",
        className: "ContainerNetworkInterfaceStatistics",
        modelProperties: {
            rxBytes: {
                serializedName: "rxBytes",
                xmlName: "rxBytes",
                type: {
                    name: "Number"
                }
            },
            rxPackets: {
                serializedName: "rxPackets",
                xmlName: "rxPackets",
                type: {
                    name: "Number"
                }
            },
            rxErrors: {
                serializedName: "rxErrors",
                xmlName: "rxErrors",
                type: {
                    name: "Number"
                }
            },
            rxDropped: {
                serializedName: "rxDropped",
                xmlName: "rxDropped",
                type: {
                    name: "Number"
                }
            },
            txBytes: {
                serializedName: "txBytes",
                xmlName: "txBytes",
                type: {
                    name: "Number"
                }
            },
            txPackets: {
                serializedName: "txPackets",
                xmlName: "txPackets",
                type: {
                    name: "Number"
                }
            },
            txErrors: {
                serializedName: "txErrors",
                xmlName: "txErrors",
                type: {
                    name: "Number"
                }
            },
            txDropped: {
                serializedName: "txDropped",
                xmlName: "txDropped",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ProcessInfoCollection = {
    serializedName: "ProcessInfoCollection",
    type: {
        name: "Composite",
        className: "ProcessInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ProcessInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProcessModuleInfoCollection = {
    serializedName: "ProcessModuleInfoCollection",
    type: {
        name: "Composite",
        className: "ProcessModuleInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ProcessModuleInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessModuleInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProcessThreadInfoCollection = {
    serializedName: "ProcessThreadInfoCollection",
    type: {
        name: "Composite",
        className: "ProcessThreadInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ProcessThreadInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessThreadInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteCloneability = {
    serializedName: "SiteCloneability",
    type: {
        name: "Composite",
        className: "SiteCloneability",
        modelProperties: {
            result: {
                serializedName: "result",
                xmlName: "result",
                type: {
                    name: "Enum",
                    allowedValues: ["Cloneable", "PartiallyCloneable", "NotCloneable"]
                }
            },
            blockingFeatures: {
                serializedName: "blockingFeatures",
                xmlName: "blockingFeatures",
                xmlElementName: "SiteCloneabilityCriterion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteCloneabilityCriterion"
                        }
                    }
                }
            },
            unsupportedFeatures: {
                serializedName: "unsupportedFeatures",
                xmlName: "unsupportedFeatures",
                xmlElementName: "SiteCloneabilityCriterion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteCloneabilityCriterion"
                        }
                    }
                }
            },
            blockingCharacteristics: {
                serializedName: "blockingCharacteristics",
                xmlName: "blockingCharacteristics",
                xmlElementName: "SiteCloneabilityCriterion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteCloneabilityCriterion"
                        }
                    }
                }
            }
        }
    }
};
const SiteCloneabilityCriterion = {
    serializedName: "SiteCloneabilityCriterion",
    type: {
        name: "Composite",
        className: "SiteCloneabilityCriterion",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkTrace = {
    serializedName: "NetworkTrace",
    type: {
        name: "Composite",
        className: "NetworkTrace",
        modelProperties: {
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PerfMonCounterCollection = {
    serializedName: "PerfMonCounterCollection",
    type: {
        name: "Composite",
        className: "PerfMonCounterCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PerfMonResponse",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PerfMonResponse"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PerfMonResponse = {
    serializedName: "PerfMonResponse",
    type: {
        name: "Composite",
        className: "PerfMonResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                type: {
                    name: "Composite",
                    className: "PerfMonSet"
                }
            }
        }
    }
};
const PerfMonSet = {
    serializedName: "PerfMonSet",
    type: {
        name: "Composite",
        className: "PerfMonSet",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                xmlName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                xmlName: "values",
                xmlElementName: "PerfMonSample",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PerfMonSample"
                        }
                    }
                }
            }
        }
    }
};
const PerfMonSample = {
    serializedName: "PerfMonSample",
    type: {
        name: "Composite",
        className: "PerfMonSample",
        modelProperties: {
            time: {
                serializedName: "time",
                xmlName: "time",
                type: {
                    name: "DateTime"
                }
            },
            instanceName: {
                serializedName: "instanceName",
                xmlName: "instanceName",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PrivateAccessVirtualNetwork = {
    serializedName: "PrivateAccessVirtualNetwork",
    type: {
        name: "Composite",
        className: "PrivateAccessVirtualNetwork",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                xmlName: "key",
                type: {
                    name: "Number"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                xmlName: "resourceId",
                type: {
                    name: "String"
                }
            },
            subnets: {
                serializedName: "subnets",
                xmlName: "subnets",
                xmlElementName: "PrivateAccessSubnet",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateAccessSubnet"
                        }
                    }
                }
            }
        }
    }
};
const PrivateAccessSubnet = {
    serializedName: "PrivateAccessSubnet",
    type: {
        name: "Composite",
        className: "PrivateAccessSubnet",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                xmlName: "key",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PublicCertificateCollection = {
    serializedName: "PublicCertificateCollection",
    type: {
        name: "Composite",
        className: "PublicCertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PublicCertificate",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicCertificate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsmPublishingProfileOptions = {
    serializedName: "CsmPublishingProfileOptions",
    type: {
        name: "Composite",
        className: "CsmPublishingProfileOptions",
        modelProperties: {
            format: {
                serializedName: "format",
                xmlName: "format",
                type: {
                    name: "String"
                }
            },
            includeDisasterRecoveryEndpoints: {
                serializedName: "includeDisasterRecoveryEndpoints",
                xmlName: "includeDisasterRecoveryEndpoints",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SnapshotRecoverySource = {
    serializedName: "SnapshotRecoverySource",
    type: {
        name: "Composite",
        className: "SnapshotRecoverySource",
        modelProperties: {
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteExtensionInfoCollection = {
    serializedName: "SiteExtensionInfoCollection",
    type: {
        name: "Composite",
        className: "SiteExtensionInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteExtensionInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteExtensionInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SlotDifferenceCollection = {
    serializedName: "SlotDifferenceCollection",
    type: {
        name: "Composite",
        className: "SlotDifferenceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SlotDifference",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SlotDifference"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotCollection = {
    serializedName: "SnapshotCollection",
    type: {
        name: "Composite",
        className: "SnapshotCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Snapshot",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Snapshot"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GitHubActionConfiguration = {
    serializedName: "GitHubActionConfiguration",
    type: {
        name: "Composite",
        className: "GitHubActionConfiguration",
        modelProperties: {
            codeConfiguration: {
                serializedName: "codeConfiguration",
                xmlName: "codeConfiguration",
                type: {
                    name: "Composite",
                    className: "GitHubActionCodeConfiguration"
                }
            },
            containerConfiguration: {
                serializedName: "containerConfiguration",
                xmlName: "containerConfiguration",
                type: {
                    name: "Composite",
                    className: "GitHubActionContainerConfiguration"
                }
            },
            isLinux: {
                serializedName: "isLinux",
                xmlName: "isLinux",
                type: {
                    name: "Boolean"
                }
            },
            generateWorkflowFile: {
                serializedName: "generateWorkflowFile",
                xmlName: "generateWorkflowFile",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const GitHubActionCodeConfiguration = {
    serializedName: "GitHubActionCodeConfiguration",
    type: {
        name: "Composite",
        className: "GitHubActionCodeConfiguration",
        modelProperties: {
            runtimeStack: {
                serializedName: "runtimeStack",
                xmlName: "runtimeStack",
                type: {
                    name: "String"
                }
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GitHubActionContainerConfiguration = {
    serializedName: "GitHubActionContainerConfiguration",
    type: {
        name: "Composite",
        className: "GitHubActionContainerConfiguration",
        modelProperties: {
            serverUrl: {
                serializedName: "serverUrl",
                xmlName: "serverUrl",
                type: {
                    name: "String"
                }
            },
            imageName: {
                serializedName: "imageName",
                xmlName: "imageName",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                xmlName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                xmlName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggeredWebJobCollection = {
    serializedName: "TriggeredWebJobCollection",
    type: {
        name: "Composite",
        className: "TriggeredWebJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TriggeredWebJob",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TriggeredWebJob"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggeredJobRun = {
    serializedName: "TriggeredJobRun",
    type: {
        name: "Composite",
        className: "TriggeredJobRun",
        modelProperties: {
            webJobId: {
                serializedName: "web_job_id",
                xmlName: "web_job_id",
                type: {
                    name: "String"
                }
            },
            webJobName: {
                serializedName: "web_job_name",
                xmlName: "web_job_name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "Enum",
                    allowedValues: ["Success", "Failed", "Error"]
                }
            },
            startTime: {
                serializedName: "start_time",
                xmlName: "start_time",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "end_time",
                xmlName: "end_time",
                type: {
                    name: "DateTime"
                }
            },
            duration: {
                serializedName: "duration",
                xmlName: "duration",
                type: {
                    name: "String"
                }
            },
            outputUrl: {
                serializedName: "output_url",
                xmlName: "output_url",
                type: {
                    name: "String"
                }
            },
            errorUrl: {
                serializedName: "error_url",
                xmlName: "error_url",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            },
            jobName: {
                serializedName: "job_name",
                xmlName: "job_name",
                type: {
                    name: "String"
                }
            },
            trigger: {
                serializedName: "trigger",
                xmlName: "trigger",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggeredJobHistoryCollection = {
    serializedName: "TriggeredJobHistoryCollection",
    type: {
        name: "Composite",
        className: "TriggeredJobHistoryCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TriggeredJobHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TriggeredJobHistory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebJobCollection = {
    serializedName: "WebJobCollection",
    type: {
        name: "Composite",
        className: "WebJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WebJob",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebJob"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegenerateActionParameter = {
    serializedName: "RegenerateActionParameter",
    type: {
        name: "Composite",
        className: "RegenerateActionParameter",
        modelProperties: {
            keyType: {
                serializedName: "keyType",
                xmlName: "keyType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    serializedName: "ErrorResponse",
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorProperties"
                }
            }
        }
    }
};
const ErrorProperties = {
    serializedName: "ErrorProperties",
    type: {
        name: "Composite",
        className: "ErrorProperties",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunListResult = {
    serializedName: "WorkflowRunListResult",
    type: {
        name: "Composite",
        className: "WorkflowRunListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowRun",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRun"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Correlation = {
    serializedName: "Correlation",
    type: {
        name: "Composite",
        className: "Correlation",
        modelProperties: {
            clientTrackingId: {
                serializedName: "clientTrackingId",
                xmlName: "clientTrackingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceReference = {
    serializedName: "ResourceReference",
    type: {
        name: "Composite",
        className: "ResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunTrigger = {
    serializedName: "WorkflowRunTrigger",
    type: {
        name: "Composite",
        className: "WorkflowRunTrigger",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                readOnly: true,
                xmlName: "inputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            inputsLink: {
                serializedName: "inputsLink",
                xmlName: "inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            },
            outputs: {
                serializedName: "outputs",
                readOnly: true,
                xmlName: "outputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            outputsLink: {
                serializedName: "outputsLink",
                xmlName: "outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            },
            scheduledTime: {
                serializedName: "scheduledTime",
                readOnly: true,
                xmlName: "scheduledTime",
                type: {
                    name: "DateTime"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            trackingId: {
                serializedName: "trackingId",
                readOnly: true,
                xmlName: "trackingId",
                type: {
                    name: "String"
                }
            },
            correlation: {
                serializedName: "correlation",
                xmlName: "correlation",
                type: {
                    name: "Composite",
                    className: "Correlation"
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                readOnly: true,
                xmlName: "error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            trackedProperties: {
                serializedName: "trackedProperties",
                readOnly: true,
                xmlName: "trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ContentLink = {
    serializedName: "ContentLink",
    type: {
        name: "Composite",
        className: "ContentLink",
        modelProperties: {
            uri: {
                serializedName: "uri",
                xmlName: "uri",
                type: {
                    name: "String"
                }
            },
            contentVersion: {
                serializedName: "contentVersion",
                readOnly: true,
                xmlName: "contentVersion",
                type: {
                    name: "String"
                }
            },
            contentSize: {
                serializedName: "contentSize",
                readOnly: true,
                xmlName: "contentSize",
                type: {
                    name: "Number"
                }
            },
            contentHash: {
                serializedName: "contentHash",
                xmlName: "contentHash",
                type: {
                    name: "Composite",
                    className: "ContentHash"
                }
            },
            metadata: {
                serializedName: "metadata",
                readOnly: true,
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ContentHash = {
    serializedName: "ContentHash",
    type: {
        name: "Composite",
        className: "ContentHash",
        modelProperties: {
            algorithm: {
                serializedName: "algorithm",
                xmlName: "algorithm",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowParameter = {
    serializedName: "WorkflowParameter",
    type: {
        name: "Composite",
        className: "WorkflowParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    serializedName: "SubResource",
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunActionListResult = {
    serializedName: "WorkflowRunActionListResult",
    type: {
        name: "Composite",
        className: "WorkflowRunActionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowRunAction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRunAction"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunCorrelation = {
    serializedName: "RunCorrelation",
    type: {
        name: "Composite",
        className: "RunCorrelation",
        modelProperties: {
            clientTrackingId: {
                serializedName: "clientTrackingId",
                xmlName: "clientTrackingId",
                type: {
                    name: "String"
                }
            },
            clientKeywords: {
                serializedName: "clientKeywords",
                xmlName: "clientKeywords",
                xmlElementName: "RunCorrelationClientKeywordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RetryHistory = {
    serializedName: "RetryHistory",
    type: {
        name: "Composite",
        className: "RetryHistory",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "clientRequestId",
                xmlName: "clientRequestId",
                type: {
                    name: "String"
                }
            },
            serviceRequestId: {
                serializedName: "serviceRequestId",
                xmlName: "serviceRequestId",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const ExpressionTraces = {
    serializedName: "ExpressionTraces",
    type: {
        name: "Composite",
        className: "ExpressionTraces",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "any"
                }
            },
            inputs: {
                serializedName: "inputs",
                xmlName: "inputs",
                xmlElementName: "ExpressionRoot",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressionRoot"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Expression = {
    serializedName: "Expression",
    type: {
        name: "Composite",
        className: "Expression",
        modelProperties: {
            text: {
                serializedName: "text",
                xmlName: "text",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "any"
                }
            },
            subexpressions: {
                serializedName: "subexpressions",
                xmlName: "subexpressions",
                xmlElementName: "Expression",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Expression"
                        }
                    }
                }
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "AzureResourceErrorInfo"
                }
            }
        }
    }
};
const ErrorInfo = {
    serializedName: "ErrorInfo",
    type: {
        name: "Composite",
        className: "ErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                xmlName: "code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunActionRepetitionDefinitionCollection = {
    serializedName: "WorkflowRunActionRepetitionDefinitionCollection",
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionDefinitionCollection",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowRunActionRepetitionDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRunActionRepetitionDefinition"
                        }
                    }
                }
            }
        }
    }
};
const RepetitionIndex = {
    serializedName: "RepetitionIndex",
    type: {
        name: "Composite",
        className: "RepetitionIndex",
        modelProperties: {
            scopeName: {
                serializedName: "scopeName",
                xmlName: "scopeName",
                type: {
                    name: "String"
                }
            },
            itemIndex: {
                serializedName: "itemIndex",
                required: true,
                xmlName: "itemIndex",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OperationResultProperties = {
    serializedName: "OperationResultProperties",
    type: {
        name: "Composite",
        className: "OperationResultProperties",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            correlation: {
                serializedName: "correlation",
                xmlName: "correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation"
                }
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const WorkflowResource = {
    serializedName: "WorkflowResource",
    type: {
        name: "Composite",
        className: "WorkflowResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const RequestHistoryListResult = {
    serializedName: "RequestHistoryListResult",
    type: {
        name: "Composite",
        className: "RequestHistoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "RequestHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RequestHistory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RequestHistoryProperties = {
    serializedName: "RequestHistoryProperties",
    type: {
        name: "Composite",
        className: "RequestHistoryProperties",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            request: {
                serializedName: "request",
                xmlName: "request",
                type: {
                    name: "Composite",
                    className: "Request"
                }
            },
            response: {
                serializedName: "response",
                xmlName: "response",
                type: {
                    name: "Composite",
                    className: "Response"
                }
            }
        }
    }
};
const Request = {
    serializedName: "Request",
    type: {
        name: "Composite",
        className: "Request",
        modelProperties: {
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            uri: {
                serializedName: "uri",
                xmlName: "uri",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                xmlName: "method",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Response = {
    serializedName: "Response",
    type: {
        name: "Composite",
        className: "Response",
        modelProperties: {
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            statusCode: {
                serializedName: "statusCode",
                xmlName: "statusCode",
                type: {
                    name: "Number"
                }
            },
            bodyLink: {
                serializedName: "bodyLink",
                xmlName: "bodyLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }
        }
    }
};
const WorkflowTriggerListResult = {
    serializedName: "WorkflowTriggerListResult",
    type: {
        name: "Composite",
        className: "WorkflowTriggerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowTrigger"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerRecurrence = {
    serializedName: "WorkflowTriggerRecurrence",
    type: {
        name: "Composite",
        className: "WorkflowTriggerRecurrence",
        modelProperties: {
            frequency: {
                serializedName: "frequency",
                xmlName: "frequency",
                type: {
                    name: "String"
                }
            },
            interval: {
                serializedName: "interval",
                xmlName: "interval",
                type: {
                    name: "Number"
                }
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "String"
                }
            },
            timeZone: {
                serializedName: "timeZone",
                xmlName: "timeZone",
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                xmlName: "schedule",
                type: {
                    name: "Composite",
                    className: "RecurrenceSchedule"
                }
            }
        }
    }
};
const RecurrenceSchedule = {
    serializedName: "RecurrenceSchedule",
    type: {
        name: "Composite",
        className: "RecurrenceSchedule",
        modelProperties: {
            minutes: {
                serializedName: "minutes",
                xmlName: "minutes",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            hours: {
                serializedName: "hours",
                xmlName: "hours",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            weekDays: {
                serializedName: "weekDays",
                xmlName: "weekDays",
                xmlElementName: "DaysOfWeek",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Sunday",
                                "Monday",
                                "Tuesday",
                                "Wednesday",
                                "Thursday",
                                "Friday",
                                "Saturday"
                            ]
                        }
                    }
                }
            },
            monthDays: {
                serializedName: "monthDays",
                xmlName: "monthDays",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            monthlyOccurrences: {
                serializedName: "monthlyOccurrences",
                xmlName: "monthlyOccurrences",
                xmlElementName: "RecurrenceScheduleOccurrence",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecurrenceScheduleOccurrence"
                        }
                    }
                }
            }
        }
    }
};
const RecurrenceScheduleOccurrence = {
    serializedName: "RecurrenceScheduleOccurrence",
    type: {
        name: "Composite",
        className: "RecurrenceScheduleOccurrence",
        modelProperties: {
            day: {
                serializedName: "day",
                xmlName: "day",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Sunday",
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday"
                    ]
                }
            },
            occurrence: {
                serializedName: "occurrence",
                xmlName: "occurrence",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WorkflowTriggerHistoryListResult = {
    serializedName: "WorkflowTriggerHistoryListResult",
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowTriggerHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowTriggerHistory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerCallbackUrl = {
    serializedName: "WorkflowTriggerCallbackUrl",
    type: {
        name: "Composite",
        className: "WorkflowTriggerCallbackUrl",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                readOnly: true,
                xmlName: "method",
                type: {
                    name: "String"
                }
            },
            basePath: {
                serializedName: "basePath",
                readOnly: true,
                xmlName: "basePath",
                type: {
                    name: "String"
                }
            },
            relativePath: {
                serializedName: "relativePath",
                readOnly: true,
                xmlName: "relativePath",
                type: {
                    name: "String"
                }
            },
            relativePathParameters: {
                serializedName: "relativePathParameters",
                xmlName: "relativePathParameters",
                xmlElementName: "WorkflowTriggerCallbackUrlRelativePathParametersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            queries: {
                serializedName: "queries",
                xmlName: "queries",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerListCallbackUrlQueries"
                }
            }
        }
    }
};
const WorkflowTriggerListCallbackUrlQueries = {
    serializedName: "WorkflowTriggerListCallbackUrlQueries",
    type: {
        name: "Composite",
        className: "WorkflowTriggerListCallbackUrlQueries",
        modelProperties: {
            apiVersion: {
                serializedName: "api-version",
                xmlName: "api-version",
                type: {
                    name: "String"
                }
            },
            sp: {
                serializedName: "sp",
                xmlName: "sp",
                type: {
                    name: "String"
                }
            },
            sv: {
                serializedName: "sv",
                xmlName: "sv",
                type: {
                    name: "String"
                }
            },
            sig: {
                serializedName: "sig",
                xmlName: "sig",
                type: {
                    name: "String"
                }
            },
            se: {
                serializedName: "se",
                xmlName: "se",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JsonSchema = {
    serializedName: "JsonSchema",
    type: {
        name: "Composite",
        className: "JsonSchema",
        modelProperties: {
            title: {
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                xmlName: "content",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FlowEndpointsConfiguration = {
    serializedName: "FlowEndpointsConfiguration",
    type: {
        name: "Composite",
        className: "FlowEndpointsConfiguration",
        modelProperties: {
            workflow: {
                serializedName: "workflow",
                xmlName: "workflow",
                type: {
                    name: "Composite",
                    className: "FlowEndpoints"
                }
            },
            connector: {
                serializedName: "connector",
                xmlName: "connector",
                type: {
                    name: "Composite",
                    className: "FlowEndpoints"
                }
            }
        }
    }
};
const FlowEndpoints = {
    serializedName: "FlowEndpoints",
    type: {
        name: "Composite",
        className: "FlowEndpoints",
        modelProperties: {
            outgoingIpAddresses: {
                serializedName: "outgoingIpAddresses",
                xmlName: "outgoingIpAddresses",
                xmlElementName: "IpAddress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddress"
                        }
                    }
                }
            },
            accessEndpointIpAddresses: {
                serializedName: "accessEndpointIpAddresses",
                xmlName: "accessEndpointIpAddresses",
                xmlElementName: "IpAddress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddress"
                        }
                    }
                }
            }
        }
    }
};
const IpAddress = {
    serializedName: "IpAddress",
    type: {
        name: "Composite",
        className: "IpAddress",
        modelProperties: {
            address: {
                serializedName: "address",
                xmlName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FlowAccessControlConfiguration = {
    serializedName: "FlowAccessControlConfiguration",
    type: {
        name: "Composite",
        className: "FlowAccessControlConfiguration",
        modelProperties: {
            triggers: {
                serializedName: "triggers",
                xmlName: "triggers",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            },
            contents: {
                serializedName: "contents",
                xmlName: "contents",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            },
            actions: {
                serializedName: "actions",
                xmlName: "actions",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            },
            workflowManagement: {
                serializedName: "workflowManagement",
                xmlName: "workflowManagement",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            }
        }
    }
};
const FlowAccessControlConfigurationPolicy = {
    serializedName: "FlowAccessControlConfigurationPolicy",
    type: {
        name: "Composite",
        className: "FlowAccessControlConfigurationPolicy",
        modelProperties: {
            allowedCallerIpAddresses: {
                serializedName: "allowedCallerIpAddresses",
                xmlName: "allowedCallerIpAddresses",
                xmlElementName: "IpAddressRange",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressRange"
                        }
                    }
                }
            },
            openAuthenticationPolicies: {
                serializedName: "openAuthenticationPolicies",
                xmlName: "openAuthenticationPolicies",
                type: {
                    name: "Composite",
                    className: "OpenAuthenticationAccessPolicies"
                }
            }
        }
    }
};
const IpAddressRange = {
    serializedName: "IpAddressRange",
    type: {
        name: "Composite",
        className: "IpAddressRange",
        modelProperties: {
            addressRange: {
                serializedName: "addressRange",
                xmlName: "addressRange",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenAuthenticationAccessPolicies = {
    serializedName: "OpenAuthenticationAccessPolicies",
    type: {
        name: "Composite",
        className: "OpenAuthenticationAccessPolicies",
        modelProperties: {
            policies: {
                serializedName: "policies",
                xmlName: "policies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "OpenAuthenticationAccessPolicy"
                        }
                    }
                }
            }
        }
    }
};
const OpenAuthenticationAccessPolicy = {
    serializedName: "OpenAuthenticationAccessPolicy",
    type: {
        name: "Composite",
        className: "OpenAuthenticationAccessPolicy",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            claims: {
                serializedName: "claims",
                xmlName: "claims",
                xmlElementName: "OpenAuthenticationPolicyClaim",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OpenAuthenticationPolicyClaim"
                        }
                    }
                }
            }
        }
    }
};
const OpenAuthenticationPolicyClaim = {
    serializedName: "OpenAuthenticationPolicyClaim",
    type: {
        name: "Composite",
        className: "OpenAuthenticationPolicyClaim",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowSku = {
    serializedName: "WorkflowSku",
    type: {
        name: "Composite",
        className: "WorkflowSku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            plan: {
                serializedName: "plan",
                xmlName: "plan",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }
        }
    }
};
const WorkflowVersionListResult = {
    serializedName: "WorkflowVersionListResult",
    type: {
        name: "Composite",
        className: "WorkflowVersionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppserviceGithubToken = {
    serializedName: "AppserviceGithubToken",
    type: {
        name: "Composite",
        className: "AppserviceGithubToken",
        modelProperties: {
            accessToken: {
                serializedName: "accessToken",
                xmlName: "accessToken",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                xmlName: "scope",
                type: {
                    name: "String"
                }
            },
            tokenType: {
                serializedName: "tokenType",
                xmlName: "tokenType",
                type: {
                    name: "String"
                }
            },
            gotToken: {
                serializedName: "gotToken",
                xmlName: "gotToken",
                type: {
                    name: "Boolean"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                xmlName: "errorMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppserviceGithubTokenRequest = {
    serializedName: "AppserviceGithubTokenRequest",
    type: {
        name: "Composite",
        className: "AppserviceGithubTokenRequest",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                required: true,
                xmlName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowFilter = {
    serializedName: "WorkflowFilter",
    type: {
        name: "Composite",
        className: "WorkflowFilter",
        modelProperties: {
            state: {
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowListResult = {
    serializedName: "WorkflowListResult",
    type: {
        name: "Composite",
        className: "WorkflowListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "Workflow",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workflow"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunActionFilter = {
    serializedName: "WorkflowRunActionFilter",
    type: {
        name: "Composite",
        className: "WorkflowRunActionFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunFilter = {
    serializedName: "WorkflowRunFilter",
    type: {
        name: "Composite",
        className: "WorkflowRunFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerFilter = {
    serializedName: "WorkflowTriggerFilter",
    type: {
        name: "Composite",
        className: "WorkflowTriggerFilter",
        modelProperties: {
            state: {
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerHistoryFilter = {
    serializedName: "WorkflowTriggerHistoryFilter",
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistoryFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppServiceCertificateOrder = {
    serializedName: "AppServiceCertificateOrder",
    type: {
        name: "Composite",
        className: "AppServiceCertificateOrder",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { certificates: {
                serializedName: "properties.certificates",
                xmlName: "properties.certificates",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AppServiceCertificate" }
                    }
                }
            }, distinguishedName: {
                serializedName: "properties.distinguishedName",
                xmlName: "properties.distinguishedName",
                type: {
                    name: "String"
                }
            }, domainVerificationToken: {
                serializedName: "properties.domainVerificationToken",
                readOnly: true,
                xmlName: "properties.domainVerificationToken",
                type: {
                    name: "String"
                }
            }, validityInYears: {
                defaultValue: 1,
                serializedName: "properties.validityInYears",
                xmlName: "properties.validityInYears",
                type: {
                    name: "Number"
                }
            }, keySize: {
                defaultValue: 2048,
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, productType: {
                serializedName: "properties.productType",
                xmlName: "properties.productType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "StandardDomainValidatedSsl",
                        "StandardDomainValidatedWildCardSsl"
                    ]
                }
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Pendingissuance",
                        "Issued",
                        "Revoked",
                        "Canceled",
                        "Denied",
                        "Pendingrevocation",
                        "PendingRekey",
                        "Unused",
                        "Expired",
                        "NotSubmitted"
                    ]
                }
            }, signedCertificate: {
                serializedName: "properties.signedCertificate",
                xmlName: "properties.signedCertificate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails"
                }
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String"
                }
            }, intermediate: {
                serializedName: "properties.intermediate",
                xmlName: "properties.intermediate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails"
                }
            }, root: {
                serializedName: "properties.root",
                xmlName: "properties.root",
                type: {
                    name: "Composite",
                    className: "CertificateDetails"
                }
            }, serialNumber: {
                serializedName: "properties.serialNumber",
                readOnly: true,
                xmlName: "properties.serialNumber",
                type: {
                    name: "String"
                }
            }, lastCertificateIssuanceTime: {
                serializedName: "properties.lastCertificateIssuanceTime",
                readOnly: true,
                xmlName: "properties.lastCertificateIssuanceTime",
                type: {
                    name: "DateTime"
                }
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime"
                }
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                readOnly: true,
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean"
                }
            }, appServiceCertificateNotRenewableReasons: {
                serializedName: "properties.appServiceCertificateNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.appServiceCertificateNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, nextAutoRenewalTimeStamp: {
                serializedName: "properties.nextAutoRenewalTimeStamp",
                readOnly: true,
                xmlName: "properties.nextAutoRenewalTimeStamp",
                type: {
                    name: "DateTime"
                }
            }, contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "CertificateOrderContact"
                }
            } })
    }
};
const AppServiceCertificateResource = {
    serializedName: "AppServiceCertificateResource",
    type: {
        name: "Composite",
        className: "AppServiceCertificateResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String"
                }
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown"
                    ]
                }
            } })
    }
};
const Domain = {
    serializedName: "Domain",
    type: {
        name: "Composite",
        className: "Domain",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { contactAdmin: {
                serializedName: "properties.contactAdmin",
                xmlName: "properties.contactAdmin",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, contactBilling: {
                serializedName: "properties.contactBilling",
                xmlName: "properties.contactBilling",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, contactRegistrant: {
                serializedName: "properties.contactRegistrant",
                xmlName: "properties.contactRegistrant",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, contactTech: {
                serializedName: "properties.contactTech",
                xmlName: "properties.contactTech",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, registrationStatus: {
                serializedName: "properties.registrationStatus",
                readOnly: true,
                xmlName: "properties.registrationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Active",
                        "Awaiting",
                        "Cancelled",
                        "Confiscated",
                        "Disabled",
                        "Excluded",
                        "Expired",
                        "Failed",
                        "Held",
                        "Locked",
                        "Parked",
                        "Pending",
                        "Reserved",
                        "Reverted",
                        "Suspended",
                        "Transferred",
                        "Unknown",
                        "Unlocked",
                        "Unparked",
                        "Updated",
                        "JsonConverterFailed"
                    ]
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, nameServers: {
                serializedName: "properties.nameServers",
                readOnly: true,
                xmlName: "properties.nameServers",
                xmlElementName: "DomainPropertiesNameServersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privacy: {
                serializedName: "properties.privacy",
                xmlName: "properties.privacy",
                type: {
                    name: "Boolean"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime"
                }
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime"
                }
            }, lastRenewedTime: {
                serializedName: "properties.lastRenewedTime",
                readOnly: true,
                xmlName: "properties.lastRenewedTime",
                type: {
                    name: "DateTime"
                }
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean"
                }
            }, readyForDnsRecordManagement: {
                serializedName: "properties.readyForDnsRecordManagement",
                readOnly: true,
                xmlName: "properties.readyForDnsRecordManagement",
                type: {
                    name: "Boolean"
                }
            }, managedHostNames: {
                serializedName: "properties.managedHostNames",
                readOnly: true,
                xmlName: "properties.managedHostNames",
                xmlElementName: "HostName",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostName"
                        }
                    }
                }
            }, consent: {
                serializedName: "properties.consent",
                xmlName: "properties.consent",
                type: {
                    name: "Composite",
                    className: "DomainPurchaseConsent"
                }
            }, domainNotRenewableReasons: {
                serializedName: "properties.domainNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.domainNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, dnsType: {
                serializedName: "properties.dnsType",
                xmlName: "properties.dnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"]
                }
            }, dnsZoneId: {
                serializedName: "properties.dnsZoneId",
                xmlName: "properties.dnsZoneId",
                type: {
                    name: "String"
                }
            }, targetDnsType: {
                serializedName: "properties.targetDnsType",
                xmlName: "properties.targetDnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"]
                }
            }, authCode: {
                serializedName: "properties.authCode",
                xmlName: "properties.authCode",
                type: {
                    name: "String"
                }
            } })
    }
};
const AppServiceEnvironmentResource = {
    serializedName: "AppServiceEnvironmentResource",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Preparing", "Ready", "Scaling", "Deleting"]
                }
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                xmlName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile"
                }
            }, internalLoadBalancingMode: {
                serializedName: "properties.internalLoadBalancingMode",
                xmlName: "properties.internalLoadBalancingMode",
                type: {
                    name: "String"
                }
            }, multiSize: {
                serializedName: "properties.multiSize",
                xmlName: "properties.multiSize",
                type: {
                    name: "String"
                }
            }, multiRoleCount: {
                serializedName: "properties.multiRoleCount",
                readOnly: true,
                xmlName: "properties.multiRoleCount",
                type: {
                    name: "Number"
                }
            }, ipsslAddressCount: {
                serializedName: "properties.ipsslAddressCount",
                xmlName: "properties.ipsslAddressCount",
                type: {
                    name: "Number"
                }
            }, dnsSuffix: {
                serializedName: "properties.dnsSuffix",
                xmlName: "properties.dnsSuffix",
                type: {
                    name: "String"
                }
            }, maximumNumberOfMachines: {
                serializedName: "properties.maximumNumberOfMachines",
                readOnly: true,
                xmlName: "properties.maximumNumberOfMachines",
                type: {
                    name: "Number"
                }
            }, frontEndScaleFactor: {
                serializedName: "properties.frontEndScaleFactor",
                xmlName: "properties.frontEndScaleFactor",
                type: {
                    name: "Number"
                }
            }, suspended: {
                serializedName: "properties.suspended",
                readOnly: true,
                xmlName: "properties.suspended",
                type: {
                    name: "Boolean"
                }
            }, clusterSettings: {
                serializedName: "properties.clusterSettings",
                xmlName: "properties.clusterSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }, userWhitelistedIpRanges: {
                serializedName: "properties.userWhitelistedIpRanges",
                xmlName: "properties.userWhitelistedIpRanges",
                xmlElementName: "AppServiceEnvironmentUserWhitelistedIpRangesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, hasLinuxWorkers: {
                serializedName: "properties.hasLinuxWorkers",
                readOnly: true,
                xmlName: "properties.hasLinuxWorkers",
                type: {
                    name: "Boolean"
                }
            }, upgradePreference: {
                defaultValue: "None",
                serializedName: "properties.upgradePreference",
                xmlName: "properties.upgradePreference",
                type: {
                    name: "String"
                }
            }, dedicatedHostCount: {
                serializedName: "properties.dedicatedHostCount",
                xmlName: "properties.dedicatedHostCount",
                type: {
                    name: "Number"
                }
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            }, customDnsSuffixConfiguration: {
                serializedName: "properties.customDnsSuffixConfiguration",
                xmlName: "properties.customDnsSuffixConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDnsSuffixConfiguration"
                }
            }, networkingConfiguration: {
                serializedName: "properties.networkingConfiguration",
                xmlName: "properties.networkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AseV3NetworkingConfiguration"
                }
            }, upgradeAvailability: {
                serializedName: "properties.upgradeAvailability",
                readOnly: true,
                xmlName: "properties.upgradeAvailability",
                type: {
                    name: "String"
                }
            } })
    }
};
const Site = {
    serializedName: "Site",
    type: {
        name: "Composite",
        className: "Site",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                xmlName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, hostNames: {
                serializedName: "properties.hostNames",
                readOnly: true,
                xmlName: "properties.hostNames",
                xmlElementName: "SitePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, repositorySiteName: {
                serializedName: "properties.repositorySiteName",
                readOnly: true,
                xmlName: "properties.repositorySiteName",
                type: {
                    name: "String"
                }
            }, usageState: {
                serializedName: "properties.usageState",
                readOnly: true,
                xmlName: "properties.usageState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Exceeded"]
                }
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, enabledHostNames: {
                serializedName: "properties.enabledHostNames",
                readOnly: true,
                xmlName: "properties.enabledHostNames",
                xmlElementName: "SitePropertiesEnabledHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availabilityState: {
                serializedName: "properties.availabilityState",
                readOnly: true,
                xmlName: "properties.availabilityState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Limited", "DisasterRecoveryMode"]
                }
            }, hostNameSslStates: {
                serializedName: "properties.hostNameSslStates",
                xmlName: "properties.hostNameSslStates",
                xmlElementName: "HostNameSslState",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostNameSslState"
                        }
                    }
                }
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String"
                }
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean"
                }
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean"
                }
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean"
                }
            }, lastModifiedTimeUtc: {
                serializedName: "properties.lastModifiedTimeUtc",
                readOnly: true,
                xmlName: "properties.lastModifiedTimeUtc",
                type: {
                    name: "DateTime"
                }
            }, vnetRouteAllEnabled: {
                serializedName: "properties.vnetRouteAllEnabled",
                xmlName: "properties.vnetRouteAllEnabled",
                type: {
                    name: "Boolean"
                }
            }, vnetImagePullEnabled: {
                serializedName: "properties.vnetImagePullEnabled",
                xmlName: "properties.vnetImagePullEnabled",
                type: {
                    name: "Boolean"
                }
            }, vnetContentShareEnabled: {
                serializedName: "properties.vnetContentShareEnabled",
                xmlName: "properties.vnetContentShareEnabled",
                type: {
                    name: "Boolean"
                }
            }, siteConfig: {
                serializedName: "properties.siteConfig",
                xmlName: "properties.siteConfig",
                type: {
                    name: "Composite",
                    className: "SiteConfig"
                }
            }, trafficManagerHostNames: {
                serializedName: "properties.trafficManagerHostNames",
                readOnly: true,
                xmlName: "properties.trafficManagerHostNames",
                xmlElementName: "SitePropertiesTrafficManagerHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, scmSiteAlsoStopped: {
                defaultValue: false,
                serializedName: "properties.scmSiteAlsoStopped",
                xmlName: "properties.scmSiteAlsoStopped",
                type: {
                    name: "Boolean"
                }
            }, targetSwapSlot: {
                serializedName: "properties.targetSwapSlot",
                readOnly: true,
                xmlName: "properties.targetSwapSlot",
                type: {
                    name: "String"
                }
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile"
                }
            }, clientAffinityEnabled: {
                serializedName: "properties.clientAffinityEnabled",
                xmlName: "properties.clientAffinityEnabled",
                type: {
                    name: "Boolean"
                }
            }, clientCertEnabled: {
                serializedName: "properties.clientCertEnabled",
                xmlName: "properties.clientCertEnabled",
                type: {
                    name: "Boolean"
                }
            }, clientCertMode: {
                serializedName: "properties.clientCertMode",
                xmlName: "properties.clientCertMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Required", "Optional", "OptionalInteractiveUser"]
                }
            }, clientCertExclusionPaths: {
                serializedName: "properties.clientCertExclusionPaths",
                xmlName: "properties.clientCertExclusionPaths",
                type: {
                    name: "String"
                }
            }, hostNamesDisabled: {
                serializedName: "properties.hostNamesDisabled",
                xmlName: "properties.hostNamesDisabled",
                type: {
                    name: "Boolean"
                }
            }, customDomainVerificationId: {
                serializedName: "properties.customDomainVerificationId",
                xmlName: "properties.customDomainVerificationId",
                type: {
                    name: "String"
                }
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                readOnly: true,
                xmlName: "properties.outboundIpAddresses",
                type: {
                    name: "String"
                }
            }, possibleOutboundIpAddresses: {
                serializedName: "properties.possibleOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.possibleOutboundIpAddresses",
                type: {
                    name: "String"
                }
            }, containerSize: {
                serializedName: "properties.containerSize",
                xmlName: "properties.containerSize",
                type: {
                    name: "Number"
                }
            }, dailyMemoryTimeQuota: {
                serializedName: "properties.dailyMemoryTimeQuota",
                xmlName: "properties.dailyMemoryTimeQuota",
                type: {
                    name: "Number"
                }
            }, suspendedTill: {
                serializedName: "properties.suspendedTill",
                readOnly: true,
                xmlName: "properties.suspendedTill",
                type: {
                    name: "DateTime"
                }
            }, maxNumberOfWorkers: {
                serializedName: "properties.maxNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maxNumberOfWorkers",
                type: {
                    name: "Number"
                }
            }, cloningInfo: {
                serializedName: "properties.cloningInfo",
                xmlName: "properties.cloningInfo",
                type: {
                    name: "Composite",
                    className: "CloningInfo"
                }
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String"
                }
            }, isDefaultContainer: {
                serializedName: "properties.isDefaultContainer",
                readOnly: true,
                xmlName: "properties.isDefaultContainer",
                type: {
                    name: "Boolean"
                }
            }, defaultHostName: {
                serializedName: "properties.defaultHostName",
                readOnly: true,
                xmlName: "properties.defaultHostName",
                type: {
                    name: "String"
                }
            }, slotSwapStatus: {
                serializedName: "properties.slotSwapStatus",
                xmlName: "properties.slotSwapStatus",
                type: {
                    name: "Composite",
                    className: "SlotSwapStatus"
                }
            }, httpsOnly: {
                serializedName: "properties.httpsOnly",
                xmlName: "properties.httpsOnly",
                type: {
                    name: "Boolean"
                }
            }, redundancyMode: {
                serializedName: "properties.redundancyMode",
                xmlName: "properties.redundancyMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Manual",
                        "Failover",
                        "ActiveActive",
                        "GeoRedundant"
                    ]
                }
            }, inProgressOperationId: {
                serializedName: "properties.inProgressOperationId",
                readOnly: true,
                xmlName: "properties.inProgressOperationId",
                type: {
                    name: "Uuid"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, storageAccountRequired: {
                serializedName: "properties.storageAccountRequired",
                xmlName: "properties.storageAccountRequired",
                type: {
                    name: "Boolean"
                }
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            }, virtualNetworkSubnetId: {
                serializedName: "properties.virtualNetworkSubnetId",
                xmlName: "properties.virtualNetworkSubnetId",
                type: {
                    name: "String"
                }
            } })
    }
};
const AppServicePlan = {
    serializedName: "AppServicePlan",
    type: {
        name: "Composite",
        className: "AppServicePlan",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription"
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                xmlName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, workerTierName: {
                serializedName: "properties.workerTierName",
                xmlName: "properties.workerTierName",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Ready", "Pending", "Creating"]
                }
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                xmlName: "properties.subscription",
                type: {
                    name: "String"
                }
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile"
                }
            }, maximumNumberOfWorkers: {
                serializedName: "properties.maximumNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maximumNumberOfWorkers",
                type: {
                    name: "Number"
                }
            }, numberOfWorkers: {
                serializedName: "properties.numberOfWorkers",
                readOnly: true,
                xmlName: "properties.numberOfWorkers",
                type: {
                    name: "Number"
                }
            }, geoRegion: {
                serializedName: "properties.geoRegion",
                readOnly: true,
                xmlName: "properties.geoRegion",
                type: {
                    name: "String"
                }
            }, perSiteScaling: {
                defaultValue: false,
                serializedName: "properties.perSiteScaling",
                xmlName: "properties.perSiteScaling",
                type: {
                    name: "Boolean"
                }
            }, elasticScaleEnabled: {
                serializedName: "properties.elasticScaleEnabled",
                xmlName: "properties.elasticScaleEnabled",
                type: {
                    name: "Boolean"
                }
            }, maximumElasticWorkerCount: {
                serializedName: "properties.maximumElasticWorkerCount",
                xmlName: "properties.maximumElasticWorkerCount",
                type: {
                    name: "Number"
                }
            }, numberOfSites: {
                serializedName: "properties.numberOfSites",
                readOnly: true,
                xmlName: "properties.numberOfSites",
                type: {
                    name: "Number"
                }
            }, isSpot: {
                serializedName: "properties.isSpot",
                xmlName: "properties.isSpot",
                type: {
                    name: "Boolean"
                }
            }, spotExpirationTime: {
                serializedName: "properties.spotExpirationTime",
                xmlName: "properties.spotExpirationTime",
                type: {
                    name: "DateTime"
                }
            }, freeOfferExpirationTime: {
                serializedName: "properties.freeOfferExpirationTime",
                xmlName: "properties.freeOfferExpirationTime",
                type: {
                    name: "DateTime"
                }
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String"
                }
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean"
                }
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean"
                }
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean"
                }
            }, targetWorkerCount: {
                serializedName: "properties.targetWorkerCount",
                xmlName: "properties.targetWorkerCount",
                type: {
                    name: "Number"
                }
            }, targetWorkerSizeId: {
                serializedName: "properties.targetWorkerSizeId",
                xmlName: "properties.targetWorkerSizeId",
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, kubeEnvironmentProfile: {
                serializedName: "properties.kubeEnvironmentProfile",
                xmlName: "properties.kubeEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "KubeEnvironmentProfile"
                }
            }, zoneRedundant: {
                defaultValue: false,
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const Certificate = {
    serializedName: "Certificate",
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String"
                }
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                readOnly: true,
                xmlName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            }, subjectName: {
                serializedName: "properties.subjectName",
                readOnly: true,
                xmlName: "properties.subjectName",
                type: {
                    name: "String"
                }
            }, hostNames: {
                serializedName: "properties.hostNames",
                xmlName: "properties.hostNames",
                xmlElementName: "CertificatePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, pfxBlob: {
                serializedName: "properties.pfxBlob",
                xmlName: "properties.pfxBlob",
                type: {
                    name: "ByteArray"
                }
            }, siteName: {
                serializedName: "properties.siteName",
                readOnly: true,
                xmlName: "properties.siteName",
                type: {
                    name: "String"
                }
            }, selfLink: {
                serializedName: "properties.selfLink",
                readOnly: true,
                xmlName: "properties.selfLink",
                type: {
                    name: "String"
                }
            }, issuer: {
                serializedName: "properties.issuer",
                readOnly: true,
                xmlName: "properties.issuer",
                type: {
                    name: "String"
                }
            }, issueDate: {
                serializedName: "properties.issueDate",
                readOnly: true,
                xmlName: "properties.issueDate",
                type: {
                    name: "DateTime"
                }
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                readOnly: true,
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                xmlName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, valid: {
                serializedName: "properties.valid",
                readOnly: true,
                xmlName: "properties.valid",
                type: {
                    name: "Boolean"
                }
            }, cerBlob: {
                serializedName: "properties.cerBlob",
                readOnly: true,
                xmlName: "properties.cerBlob",
                type: {
                    name: "ByteArray"
                }
            }, publicKeyHash: {
                serializedName: "properties.publicKeyHash",
                readOnly: true,
                xmlName: "properties.publicKeyHash",
                type: {
                    name: "String"
                }
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile"
                }
            }, keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String"
                }
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String"
                }
            }, keyVaultSecretStatus: {
                serializedName: "properties.keyVaultSecretStatus",
                readOnly: true,
                xmlName: "properties.keyVaultSecretStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown"
                    ]
                }
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String"
                }
            }, canonicalName: {
                serializedName: "properties.canonicalName",
                xmlName: "properties.canonicalName",
                type: {
                    name: "String"
                }
            }, domainValidationMethod: {
                serializedName: "properties.domainValidationMethod",
                xmlName: "properties.domainValidationMethod",
                type: {
                    name: "String"
                }
            } })
    }
};
const ContainerApp = {
    serializedName: "ContainerApp",
    type: {
        name: "Composite",
        className: "ContainerApp",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, kubeEnvironmentId: {
                serializedName: "properties.kubeEnvironmentId",
                xmlName: "properties.kubeEnvironmentId",
                type: {
                    name: "String"
                }
            }, latestRevisionName: {
                serializedName: "properties.latestRevisionName",
                readOnly: true,
                xmlName: "properties.latestRevisionName",
                type: {
                    name: "String"
                }
            }, latestRevisionFqdn: {
                serializedName: "properties.latestRevisionFqdn",
                readOnly: true,
                xmlName: "properties.latestRevisionFqdn",
                type: {
                    name: "String"
                }
            }, configuration: {
                serializedName: "properties.configuration",
                xmlName: "properties.configuration",
                type: {
                    name: "Composite",
                    className: "Configuration"
                }
            }, template: {
                serializedName: "properties.template",
                xmlName: "properties.template",
                type: {
                    name: "Composite",
                    className: "Template"
                }
            } })
    }
};
const Revision = {
    serializedName: "Revision",
    type: {
        name: "Composite",
        className: "Revision",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                readOnly: true,
                xmlName: "properties.fqdn",
                type: {
                    name: "String"
                }
            }, template: {
                serializedName: "properties.template",
                xmlName: "properties.template",
                type: {
                    name: "Composite",
                    className: "Template"
                }
            }, active: {
                serializedName: "properties.active",
                readOnly: true,
                xmlName: "properties.active",
                type: {
                    name: "Boolean"
                }
            }, replicas: {
                serializedName: "properties.replicas",
                readOnly: true,
                xmlName: "properties.replicas",
                type: {
                    name: "Number"
                }
            }, trafficWeight: {
                serializedName: "properties.trafficWeight",
                readOnly: true,
                xmlName: "properties.trafficWeight",
                type: {
                    name: "Number"
                }
            }, provisioningError: {
                serializedName: "properties.provisioningError",
                readOnly: true,
                xmlName: "properties.provisioningError",
                type: {
                    name: "String"
                }
            }, healthState: {
                serializedName: "properties.healthState",
                readOnly: true,
                xmlName: "properties.healthState",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubeEnvironment = {
    serializedName: "KubeEnvironment",
    type: {
        name: "Composite",
        className: "KubeEnvironment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                xmlName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "Waiting",
                        "InitializationInProgress",
                        "InfrastructureSetupInProgress",
                        "InfrastructureSetupComplete",
                        "ScheduledForDelete",
                        "UpgradeRequested",
                        "UpgradeFailed"
                    ]
                }
            }, deploymentErrors: {
                serializedName: "properties.deploymentErrors",
                readOnly: true,
                xmlName: "properties.deploymentErrors",
                type: {
                    name: "String"
                }
            }, internalLoadBalancerEnabled: {
                serializedName: "properties.internalLoadBalancerEnabled",
                xmlName: "properties.internalLoadBalancerEnabled",
                type: {
                    name: "Boolean"
                }
            }, defaultDomain: {
                serializedName: "properties.defaultDomain",
                readOnly: true,
                xmlName: "properties.defaultDomain",
                type: {
                    name: "String"
                }
            }, staticIp: {
                serializedName: "properties.staticIp",
                xmlName: "properties.staticIp",
                type: {
                    name: "String"
                }
            }, environmentType: {
                serializedName: "properties.environmentType",
                xmlName: "properties.environmentType",
                type: {
                    name: "String"
                }
            }, arcConfiguration: {
                serializedName: "properties.arcConfiguration",
                xmlName: "properties.arcConfiguration",
                type: {
                    name: "Composite",
                    className: "ArcConfiguration"
                }
            }, appLogsConfiguration: {
                serializedName: "properties.appLogsConfiguration",
                xmlName: "properties.appLogsConfiguration",
                type: {
                    name: "Composite",
                    className: "AppLogsConfiguration"
                }
            }, containerAppsConfiguration: {
                serializedName: "properties.containerAppsConfiguration",
                xmlName: "properties.containerAppsConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerAppsConfiguration"
                }
            }, aksResourceID: {
                serializedName: "properties.aksResourceID",
                xmlName: "properties.aksResourceID",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteARMResource = {
    serializedName: "StaticSiteARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteARMResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription"
                }
            }, identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, defaultHostname: {
                serializedName: "properties.defaultHostname",
                readOnly: true,
                xmlName: "properties.defaultHostname",
                type: {
                    name: "String"
                }
            }, repositoryUrl: {
                serializedName: "properties.repositoryUrl",
                xmlName: "properties.repositoryUrl",
                type: {
                    name: "String"
                }
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            }, customDomains: {
                serializedName: "properties.customDomains",
                readOnly: true,
                xmlName: "properties.customDomains",
                xmlElementName: "StaticSiteCustomDomainsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, repositoryToken: {
                serializedName: "properties.repositoryToken",
                xmlName: "properties.repositoryToken",
                type: {
                    name: "String"
                }
            }, buildProperties: {
                serializedName: "properties.buildProperties",
                xmlName: "properties.buildProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteBuildProperties"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                xmlName: "properties.privateEndpointConnections",
                xmlElementName: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseMessageEnvelopeRemotePrivateEndpointConnection"
                        }
                    }
                }
            }, stagingEnvironmentPolicy: {
                serializedName: "properties.stagingEnvironmentPolicy",
                xmlName: "properties.stagingEnvironmentPolicy",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, allowConfigFileUpdates: {
                serializedName: "properties.allowConfigFileUpdates",
                xmlName: "properties.allowConfigFileUpdates",
                type: {
                    name: "Boolean"
                }
            }, templateProperties: {
                serializedName: "properties.templateProperties",
                xmlName: "properties.templateProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteTemplateOptions"
                }
            }, contentDistributionEndpoint: {
                serializedName: "properties.contentDistributionEndpoint",
                readOnly: true,
                xmlName: "properties.contentDistributionEndpoint",
                type: {
                    name: "String"
                }
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                readOnly: true,
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            }, userProvidedFunctionApps: {
                serializedName: "properties.userProvidedFunctionApps",
                readOnly: true,
                xmlName: "properties.userProvidedFunctionApps",
                xmlElementName: "StaticSiteUserProvidedFunctionApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionApp"
                        }
                    }
                }
            }, linkedBackends: {
                serializedName: "properties.linkedBackends",
                readOnly: true,
                xmlName: "properties.linkedBackends",
                xmlElementName: "StaticSiteLinkedBackend",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackend"
                        }
                    }
                }
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String"
                }
            }, enterpriseGradeCdnStatus: {
                serializedName: "properties.enterpriseGradeCdnStatus",
                xmlName: "properties.enterpriseGradeCdnStatus",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            } })
    }
};
const PremierAddOn = {
    serializedName: "PremierAddOn",
    type: {
        name: "Composite",
        className: "PremierAddOn",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "String"
                }
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String"
                }
            }, vendor: {
                serializedName: "properties.vendor",
                xmlName: "properties.vendor",
                type: {
                    name: "String"
                }
            }, marketplacePublisher: {
                serializedName: "properties.marketplacePublisher",
                xmlName: "properties.marketplacePublisher",
                type: {
                    name: "String"
                }
            }, marketplaceOffer: {
                serializedName: "properties.marketplaceOffer",
                xmlName: "properties.marketplaceOffer",
                type: {
                    name: "String"
                }
            } })
    }
};
const AppServiceCertificateOrderPatchResource = {
    serializedName: "AppServiceCertificateOrderPatchResource",
    type: {
        name: "Composite",
        className: "AppServiceCertificateOrderPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { certificates: {
                serializedName: "properties.certificates",
                xmlName: "properties.certificates",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AppServiceCertificate" }
                    }
                }
            }, distinguishedName: {
                serializedName: "properties.distinguishedName",
                xmlName: "properties.distinguishedName",
                type: {
                    name: "String"
                }
            }, domainVerificationToken: {
                serializedName: "properties.domainVerificationToken",
                readOnly: true,
                xmlName: "properties.domainVerificationToken",
                type: {
                    name: "String"
                }
            }, validityInYears: {
                defaultValue: 1,
                serializedName: "properties.validityInYears",
                xmlName: "properties.validityInYears",
                type: {
                    name: "Number"
                }
            }, keySize: {
                defaultValue: 2048,
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, productType: {
                serializedName: "properties.productType",
                xmlName: "properties.productType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "StandardDomainValidatedSsl",
                        "StandardDomainValidatedWildCardSsl"
                    ]
                }
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Pendingissuance",
                        "Issued",
                        "Revoked",
                        "Canceled",
                        "Denied",
                        "Pendingrevocation",
                        "PendingRekey",
                        "Unused",
                        "Expired",
                        "NotSubmitted"
                    ]
                }
            }, signedCertificate: {
                serializedName: "properties.signedCertificate",
                xmlName: "properties.signedCertificate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails"
                }
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String"
                }
            }, intermediate: {
                serializedName: "properties.intermediate",
                xmlName: "properties.intermediate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails"
                }
            }, root: {
                serializedName: "properties.root",
                xmlName: "properties.root",
                type: {
                    name: "Composite",
                    className: "CertificateDetails"
                }
            }, serialNumber: {
                serializedName: "properties.serialNumber",
                readOnly: true,
                xmlName: "properties.serialNumber",
                type: {
                    name: "String"
                }
            }, lastCertificateIssuanceTime: {
                serializedName: "properties.lastCertificateIssuanceTime",
                readOnly: true,
                xmlName: "properties.lastCertificateIssuanceTime",
                type: {
                    name: "DateTime"
                }
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime"
                }
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                readOnly: true,
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean"
                }
            }, appServiceCertificateNotRenewableReasons: {
                serializedName: "properties.appServiceCertificateNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.appServiceCertificateNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, nextAutoRenewalTimeStamp: {
                serializedName: "properties.nextAutoRenewalTimeStamp",
                readOnly: true,
                xmlName: "properties.nextAutoRenewalTimeStamp",
                type: {
                    name: "DateTime"
                }
            }, contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "CertificateOrderContact"
                }
            } })
    }
};
const AppServiceCertificatePatchResource = {
    serializedName: "AppServiceCertificatePatchResource",
    type: {
        name: "Composite",
        className: "AppServiceCertificatePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String"
                }
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown"
                    ]
                }
            } })
    }
};
const ReissueCertificateOrderRequest = {
    serializedName: "ReissueCertificateOrderRequest",
    type: {
        name: "Composite",
        className: "ReissueCertificateOrderRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { keySize: {
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, delayExistingRevokeInHours: {
                serializedName: "properties.delayExistingRevokeInHours",
                xmlName: "properties.delayExistingRevokeInHours",
                type: {
                    name: "Number"
                }
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String"
                }
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const RenewCertificateOrderRequest = {
    serializedName: "RenewCertificateOrderRequest",
    type: {
        name: "Composite",
        className: "RenewCertificateOrderRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { keySize: {
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String"
                }
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DetectorResponse = {
    serializedName: "DetectorResponse",
    type: {
        name: "Composite",
        className: "DetectorResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { metadata: {
                serializedName: "properties.metadata",
                xmlName: "properties.metadata",
                type: {
                    name: "Composite",
                    className: "DetectorInfo"
                }
            }, dataset: {
                serializedName: "properties.dataset",
                xmlName: "properties.dataset",
                xmlElementName: "DiagnosticData",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticData"
                        }
                    }
                }
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Composite",
                    className: "Status"
                }
            }, dataProvidersMetadata: {
                serializedName: "properties.dataProvidersMetadata",
                xmlName: "properties.dataProvidersMetadata",
                xmlElementName: "DataProviderMetadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataProviderMetadata"
                        }
                    }
                }
            }, suggestedUtterances: {
                serializedName: "properties.suggestedUtterances",
                xmlName: "properties.suggestedUtterances",
                type: {
                    name: "Composite",
                    className: "QueryUtterancesResults"
                }
            } })
    }
};
const DomainPatchResource = {
    serializedName: "DomainPatchResource",
    type: {
        name: "Composite",
        className: "DomainPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { contactAdmin: {
                serializedName: "properties.contactAdmin",
                xmlName: "properties.contactAdmin",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, contactBilling: {
                serializedName: "properties.contactBilling",
                xmlName: "properties.contactBilling",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, contactRegistrant: {
                serializedName: "properties.contactRegistrant",
                xmlName: "properties.contactRegistrant",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, contactTech: {
                serializedName: "properties.contactTech",
                xmlName: "properties.contactTech",
                type: {
                    name: "Composite",
                    className: "Contact"
                }
            }, registrationStatus: {
                serializedName: "properties.registrationStatus",
                readOnly: true,
                xmlName: "properties.registrationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Active",
                        "Awaiting",
                        "Cancelled",
                        "Confiscated",
                        "Disabled",
                        "Excluded",
                        "Expired",
                        "Failed",
                        "Held",
                        "Locked",
                        "Parked",
                        "Pending",
                        "Reserved",
                        "Reverted",
                        "Suspended",
                        "Transferred",
                        "Unknown",
                        "Unlocked",
                        "Unparked",
                        "Updated",
                        "JsonConverterFailed"
                    ]
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, nameServers: {
                serializedName: "properties.nameServers",
                readOnly: true,
                xmlName: "properties.nameServers",
                xmlElementName: "DomainPatchResourcePropertiesNameServersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privacy: {
                serializedName: "properties.privacy",
                xmlName: "properties.privacy",
                type: {
                    name: "Boolean"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime"
                }
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime"
                }
            }, lastRenewedTime: {
                serializedName: "properties.lastRenewedTime",
                readOnly: true,
                xmlName: "properties.lastRenewedTime",
                type: {
                    name: "DateTime"
                }
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean"
                }
            }, readyForDnsRecordManagement: {
                serializedName: "properties.readyForDnsRecordManagement",
                readOnly: true,
                xmlName: "properties.readyForDnsRecordManagement",
                type: {
                    name: "Boolean"
                }
            }, managedHostNames: {
                serializedName: "properties.managedHostNames",
                readOnly: true,
                xmlName: "properties.managedHostNames",
                xmlElementName: "HostName",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostName"
                        }
                    }
                }
            }, consent: {
                serializedName: "properties.consent",
                xmlName: "properties.consent",
                type: {
                    name: "Composite",
                    className: "DomainPurchaseConsent"
                }
            }, domainNotRenewableReasons: {
                serializedName: "properties.domainNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.domainNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, dnsType: {
                serializedName: "properties.dnsType",
                xmlName: "properties.dnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"]
                }
            }, dnsZoneId: {
                serializedName: "properties.dnsZoneId",
                xmlName: "properties.dnsZoneId",
                type: {
                    name: "String"
                }
            }, targetDnsType: {
                serializedName: "properties.targetDnsType",
                xmlName: "properties.targetDnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"]
                }
            }, authCode: {
                serializedName: "properties.authCode",
                xmlName: "properties.authCode",
                type: {
                    name: "String"
                }
            } })
    }
};
const DomainOwnershipIdentifier = {
    serializedName: "DomainOwnershipIdentifier",
    type: {
        name: "Composite",
        className: "DomainOwnershipIdentifier",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { ownershipId: {
                serializedName: "properties.ownershipId",
                xmlName: "properties.ownershipId",
                type: {
                    name: "String"
                }
            } })
    }
};
const TopLevelDomain = {
    serializedName: "TopLevelDomain",
    type: {
        name: "Composite",
        className: "TopLevelDomain",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { privacy: {
                serializedName: "properties.privacy",
                xmlName: "properties.privacy",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CustomDnsSuffixConfiguration = {
    serializedName: "CustomDnsSuffixConfiguration",
    type: {
        name: "Composite",
        className: "CustomDnsSuffixConfiguration",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Failed", "Degraded", "InProgress"]
                }
            }, provisioningDetails: {
                serializedName: "properties.provisioningDetails",
                readOnly: true,
                xmlName: "properties.provisioningDetails",
                type: {
                    name: "String"
                }
            }, dnsSuffix: {
                serializedName: "properties.dnsSuffix",
                xmlName: "properties.dnsSuffix",
                type: {
                    name: "String"
                }
            }, certificateUrl: {
                serializedName: "properties.certificateUrl",
                xmlName: "properties.certificateUrl",
                type: {
                    name: "String"
                }
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            } })
    }
};
const AseV3NetworkingConfiguration = {
    serializedName: "AseV3NetworkingConfiguration",
    type: {
        name: "Composite",
        className: "AseV3NetworkingConfiguration",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { windowsOutboundIpAddresses: {
                serializedName: "properties.windowsOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.windowsOutboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesWindowsOutboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, linuxOutboundIpAddresses: {
                serializedName: "properties.linuxOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.linuxOutboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesLinuxOutboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, externalInboundIpAddresses: {
                serializedName: "properties.externalInboundIpAddresses",
                readOnly: true,
                xmlName: "properties.externalInboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesExternalInboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, internalInboundIpAddresses: {
                serializedName: "properties.internalInboundIpAddresses",
                readOnly: true,
                xmlName: "properties.internalInboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesInternalInboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, allowNewPrivateEndpointConnections: {
                serializedName: "properties.allowNewPrivateEndpointConnections",
                xmlName: "properties.allowNewPrivateEndpointConnections",
                type: {
                    name: "Boolean"
                }
            }, ftpEnabled: {
                serializedName: "properties.ftpEnabled",
                xmlName: "properties.ftpEnabled",
                type: {
                    name: "Boolean"
                }
            }, remoteDebugEnabled: {
                serializedName: "properties.remoteDebugEnabled",
                xmlName: "properties.remoteDebugEnabled",
                type: {
                    name: "Boolean"
                }
            }, inboundIpAddressOverride: {
                serializedName: "properties.inboundIpAddressOverride",
                xmlName: "properties.inboundIpAddressOverride",
                type: {
                    name: "String"
                }
            } })
    }
};
const AppServiceEnvironmentPatchResource = {
    serializedName: "AppServiceEnvironmentPatchResource",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Preparing", "Ready", "Scaling", "Deleting"]
                }
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                xmlName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile"
                }
            }, internalLoadBalancingMode: {
                serializedName: "properties.internalLoadBalancingMode",
                xmlName: "properties.internalLoadBalancingMode",
                type: {
                    name: "String"
                }
            }, multiSize: {
                serializedName: "properties.multiSize",
                xmlName: "properties.multiSize",
                type: {
                    name: "String"
                }
            }, multiRoleCount: {
                serializedName: "properties.multiRoleCount",
                readOnly: true,
                xmlName: "properties.multiRoleCount",
                type: {
                    name: "Number"
                }
            }, ipsslAddressCount: {
                serializedName: "properties.ipsslAddressCount",
                xmlName: "properties.ipsslAddressCount",
                type: {
                    name: "Number"
                }
            }, dnsSuffix: {
                serializedName: "properties.dnsSuffix",
                xmlName: "properties.dnsSuffix",
                type: {
                    name: "String"
                }
            }, maximumNumberOfMachines: {
                serializedName: "properties.maximumNumberOfMachines",
                readOnly: true,
                xmlName: "properties.maximumNumberOfMachines",
                type: {
                    name: "Number"
                }
            }, frontEndScaleFactor: {
                serializedName: "properties.frontEndScaleFactor",
                xmlName: "properties.frontEndScaleFactor",
                type: {
                    name: "Number"
                }
            }, suspended: {
                serializedName: "properties.suspended",
                readOnly: true,
                xmlName: "properties.suspended",
                type: {
                    name: "Boolean"
                }
            }, clusterSettings: {
                serializedName: "properties.clusterSettings",
                xmlName: "properties.clusterSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }, userWhitelistedIpRanges: {
                serializedName: "properties.userWhitelistedIpRanges",
                xmlName: "properties.userWhitelistedIpRanges",
                xmlElementName: "AppServiceEnvironmentUserWhitelistedIpRangesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, hasLinuxWorkers: {
                serializedName: "properties.hasLinuxWorkers",
                readOnly: true,
                xmlName: "properties.hasLinuxWorkers",
                type: {
                    name: "Boolean"
                }
            }, upgradePreference: {
                defaultValue: "None",
                serializedName: "properties.upgradePreference",
                xmlName: "properties.upgradePreference",
                type: {
                    name: "String"
                }
            }, dedicatedHostCount: {
                serializedName: "properties.dedicatedHostCount",
                xmlName: "properties.dedicatedHostCount",
                type: {
                    name: "Number"
                }
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            }, customDnsSuffixConfiguration: {
                serializedName: "properties.customDnsSuffixConfiguration",
                xmlName: "properties.customDnsSuffixConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDnsSuffixConfiguration"
                }
            }, networkingConfiguration: {
                serializedName: "properties.networkingConfiguration",
                xmlName: "properties.networkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AseV3NetworkingConfiguration"
                }
            }, upgradeAvailability: {
                serializedName: "properties.upgradeAvailability",
                readOnly: true,
                xmlName: "properties.upgradeAvailability",
                type: {
                    name: "String"
                }
            } })
    }
};
const AddressResponse = {
    serializedName: "AddressResponse",
    type: {
        name: "Composite",
        className: "AddressResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { serviceIpAddress: {
                serializedName: "properties.serviceIpAddress",
                xmlName: "properties.serviceIpAddress",
                type: {
                    name: "String"
                }
            }, internalIpAddress: {
                serializedName: "properties.internalIpAddress",
                xmlName: "properties.internalIpAddress",
                type: {
                    name: "String"
                }
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                xmlName: "properties.outboundIpAddresses",
                xmlElementName: "AddressResponsePropertiesOutboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, vipMappings: {
                serializedName: "properties.vipMappings",
                xmlName: "properties.vipMappings",
                xmlElementName: "VirtualIPMapping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualIPMapping"
                        }
                    }
                }
            } })
    }
};
const PushSettings = {
    serializedName: "PushSettings",
    type: {
        name: "Composite",
        className: "PushSettings",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { isPushEnabled: {
                serializedName: "properties.isPushEnabled",
                xmlName: "properties.isPushEnabled",
                type: {
                    name: "Boolean"
                }
            }, tagWhitelistJson: {
                serializedName: "properties.tagWhitelistJson",
                xmlName: "properties.tagWhitelistJson",
                type: {
                    name: "String"
                }
            }, tagsRequiringAuth: {
                serializedName: "properties.tagsRequiringAuth",
                xmlName: "properties.tagsRequiringAuth",
                type: {
                    name: "String"
                }
            }, dynamicTagsJson: {
                serializedName: "properties.dynamicTagsJson",
                xmlName: "properties.dynamicTagsJson",
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkerPoolResource = {
    serializedName: "WorkerPoolResource",
    type: {
        name: "Composite",
        className: "WorkerPoolResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription"
                }
            }, workerSizeId: {
                serializedName: "properties.workerSizeId",
                xmlName: "properties.workerSizeId",
                type: {
                    name: "Number"
                }
            }, computeMode: {
                serializedName: "properties.computeMode",
                xmlName: "properties.computeMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Shared", "Dedicated", "Dynamic"]
                }
            }, workerSize: {
                serializedName: "properties.workerSize",
                xmlName: "properties.workerSize",
                type: {
                    name: "String"
                }
            }, workerCount: {
                serializedName: "properties.workerCount",
                xmlName: "properties.workerCount",
                type: {
                    name: "Number"
                }
            }, instanceNames: {
                serializedName: "properties.instanceNames",
                readOnly: true,
                xmlName: "properties.instanceNames",
                xmlElementName: "WorkerPoolInstanceNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ResourceMetricDefinition = {
    serializedName: "ResourceMetricDefinition",
    type: {
        name: "Composite",
        className: "ResourceMetricDefinition",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { unit: {
                serializedName: "properties.unit",
                readOnly: true,
                xmlName: "properties.unit",
                type: {
                    name: "String"
                }
            }, primaryAggregationType: {
                serializedName: "properties.primaryAggregationType",
                readOnly: true,
                xmlName: "properties.primaryAggregationType",
                type: {
                    name: "String"
                }
            }, metricAvailabilities: {
                serializedName: "properties.metricAvailabilities",
                readOnly: true,
                xmlName: "properties.metricAvailabilities",
                xmlElementName: "ResourceMetricAvailability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceMetricAvailability"
                        }
                    }
                }
            }, resourceUri: {
                serializedName: "properties.resourceUri",
                readOnly: true,
                xmlName: "properties.resourceUri",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties.properties",
                readOnly: true,
                xmlName: "properties.properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const Usage = {
    serializedName: "Usage",
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, resourceName: {
                serializedName: "properties.resourceName",
                readOnly: true,
                xmlName: "properties.resourceName",
                type: {
                    name: "String"
                }
            }, unit: {
                serializedName: "properties.unit",
                readOnly: true,
                xmlName: "properties.unit",
                type: {
                    name: "String"
                }
            }, currentValue: {
                serializedName: "properties.currentValue",
                readOnly: true,
                xmlName: "properties.currentValue",
                type: {
                    name: "Number"
                }
            }, limit: {
                serializedName: "properties.limit",
                readOnly: true,
                xmlName: "properties.limit",
                type: {
                    name: "Number"
                }
            }, nextResetTime: {
                serializedName: "properties.nextResetTime",
                readOnly: true,
                xmlName: "properties.nextResetTime",
                type: {
                    name: "DateTime"
                }
            }, computeMode: {
                serializedName: "properties.computeMode",
                readOnly: true,
                xmlName: "properties.computeMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Shared", "Dedicated", "Dynamic"]
                }
            }, siteMode: {
                serializedName: "properties.siteMode",
                readOnly: true,
                xmlName: "properties.siteMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const RemotePrivateEndpointConnectionARMResource = {
    serializedName: "RemotePrivateEndpointConnectionARMResource",
    type: {
        name: "Composite",
        className: "RemotePrivateEndpointConnectionARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                xmlName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ArmIdWrapper"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState"
                }
            }, ipAddresses: {
                serializedName: "properties.ipAddresses",
                xmlName: "properties.ipAddresses",
                xmlElementName: "RemotePrivateEndpointConnectionARMResourcePropertiesIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PrivateLinkConnectionApprovalRequestResource = {
    serializedName: "PrivateLinkConnectionApprovalRequestResource",
    type: {
        name: "Composite",
        className: "PrivateLinkConnectionApprovalRequestResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState"
                }
            } })
    }
};
const AppServicePlanPatchResource = {
    serializedName: "AppServicePlanPatchResource",
    type: {
        name: "Composite",
        className: "AppServicePlanPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { workerTierName: {
                serializedName: "properties.workerTierName",
                xmlName: "properties.workerTierName",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Ready", "Pending", "Creating"]
                }
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                xmlName: "properties.subscription",
                type: {
                    name: "String"
                }
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile"
                }
            }, maximumNumberOfWorkers: {
                serializedName: "properties.maximumNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maximumNumberOfWorkers",
                type: {
                    name: "Number"
                }
            }, numberOfWorkers: {
                serializedName: "properties.numberOfWorkers",
                readOnly: true,
                xmlName: "properties.numberOfWorkers",
                type: {
                    name: "Number"
                }
            }, geoRegion: {
                serializedName: "properties.geoRegion",
                readOnly: true,
                xmlName: "properties.geoRegion",
                type: {
                    name: "String"
                }
            }, perSiteScaling: {
                defaultValue: false,
                serializedName: "properties.perSiteScaling",
                xmlName: "properties.perSiteScaling",
                type: {
                    name: "Boolean"
                }
            }, elasticScaleEnabled: {
                serializedName: "properties.elasticScaleEnabled",
                xmlName: "properties.elasticScaleEnabled",
                type: {
                    name: "Boolean"
                }
            }, maximumElasticWorkerCount: {
                serializedName: "properties.maximumElasticWorkerCount",
                xmlName: "properties.maximumElasticWorkerCount",
                type: {
                    name: "Number"
                }
            }, numberOfSites: {
                serializedName: "properties.numberOfSites",
                readOnly: true,
                xmlName: "properties.numberOfSites",
                type: {
                    name: "Number"
                }
            }, isSpot: {
                serializedName: "properties.isSpot",
                xmlName: "properties.isSpot",
                type: {
                    name: "Boolean"
                }
            }, spotExpirationTime: {
                serializedName: "properties.spotExpirationTime",
                xmlName: "properties.spotExpirationTime",
                type: {
                    name: "DateTime"
                }
            }, freeOfferExpirationTime: {
                serializedName: "properties.freeOfferExpirationTime",
                xmlName: "properties.freeOfferExpirationTime",
                type: {
                    name: "DateTime"
                }
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String"
                }
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean"
                }
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean"
                }
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean"
                }
            }, targetWorkerCount: {
                serializedName: "properties.targetWorkerCount",
                xmlName: "properties.targetWorkerCount",
                type: {
                    name: "Number"
                }
            }, targetWorkerSizeId: {
                serializedName: "properties.targetWorkerSizeId",
                xmlName: "properties.targetWorkerSizeId",
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting"
                    ]
                }
            }, kubeEnvironmentProfile: {
                serializedName: "properties.kubeEnvironmentProfile",
                xmlName: "properties.kubeEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "KubeEnvironmentProfile"
                }
            }, zoneRedundant: {
                defaultValue: false,
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const HybridConnection = {
    serializedName: "HybridConnection",
    type: {
        name: "Composite",
        className: "HybridConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                xmlName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, relayName: {
                serializedName: "properties.relayName",
                xmlName: "properties.relayName",
                type: {
                    name: "String"
                }
            }, relayArmUri: {
                serializedName: "properties.relayArmUri",
                xmlName: "properties.relayArmUri",
                type: {
                    name: "String"
                }
            }, hostname: {
                serializedName: "properties.hostname",
                xmlName: "properties.hostname",
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                xmlName: "properties.port",
                type: {
                    name: "Number"
                }
            }, sendKeyName: {
                serializedName: "properties.sendKeyName",
                xmlName: "properties.sendKeyName",
                type: {
                    name: "String"
                }
            }, sendKeyValue: {
                serializedName: "properties.sendKeyValue",
                xmlName: "properties.sendKeyValue",
                type: {
                    name: "String"
                }
            }, serviceBusSuffix: {
                serializedName: "properties.serviceBusSuffix",
                xmlName: "properties.serviceBusSuffix",
                type: {
                    name: "String"
                }
            } })
    }
};
const HybridConnectionKey = {
    serializedName: "HybridConnectionKey",
    type: {
        name: "Composite",
        className: "HybridConnectionKey",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sendKeyName: {
                serializedName: "properties.sendKeyName",
                readOnly: true,
                xmlName: "properties.sendKeyName",
                type: {
                    name: "String"
                }
            }, sendKeyValue: {
                serializedName: "properties.sendKeyValue",
                readOnly: true,
                xmlName: "properties.sendKeyValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const HybridConnectionLimits = {
    serializedName: "HybridConnectionLimits",
    type: {
        name: "Composite",
        className: "HybridConnectionLimits",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { current: {
                serializedName: "properties.current",
                readOnly: true,
                xmlName: "properties.current",
                type: {
                    name: "Number"
                }
            }, maximum: {
                serializedName: "properties.maximum",
                readOnly: true,
                xmlName: "properties.maximum",
                type: {
                    name: "Number"
                }
            } })
    }
};
const VnetRoute = {
    serializedName: "VnetRoute",
    type: {
        name: "Composite",
        className: "VnetRoute",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { startAddress: {
                serializedName: "properties.startAddress",
                xmlName: "properties.startAddress",
                type: {
                    name: "String"
                }
            }, endAddress: {
                serializedName: "properties.endAddress",
                xmlName: "properties.endAddress",
                type: {
                    name: "String"
                }
            }, routeType: {
                serializedName: "properties.routeType",
                xmlName: "properties.routeType",
                type: {
                    name: "String"
                }
            } })
    }
};
const VnetInfoResource = {
    serializedName: "VnetInfoResource",
    type: {
        name: "Composite",
        className: "VnetInfoResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { vnetResourceId: {
                serializedName: "properties.vnetResourceId",
                xmlName: "properties.vnetResourceId",
                type: {
                    name: "String"
                }
            }, certThumbprint: {
                serializedName: "properties.certThumbprint",
                readOnly: true,
                xmlName: "properties.certThumbprint",
                type: {
                    name: "String"
                }
            }, certBlob: {
                serializedName: "properties.certBlob",
                xmlName: "properties.certBlob",
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                readOnly: true,
                xmlName: "properties.routes",
                xmlElementName: "VnetRoute",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetRoute"
                        }
                    }
                }
            }, resyncRequired: {
                serializedName: "properties.resyncRequired",
                readOnly: true,
                xmlName: "properties.resyncRequired",
                type: {
                    name: "Boolean"
                }
            }, dnsServers: {
                serializedName: "properties.dnsServers",
                xmlName: "properties.dnsServers",
                type: {
                    name: "String"
                }
            }, isSwift: {
                serializedName: "properties.isSwift",
                xmlName: "properties.isSwift",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VnetGateway = {
    serializedName: "VnetGateway",
    type: {
        name: "Composite",
        className: "VnetGateway",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { vnetName: {
                serializedName: "properties.vnetName",
                xmlName: "properties.vnetName",
                type: {
                    name: "String"
                }
            }, vpnPackageUri: {
                serializedName: "properties.vpnPackageUri",
                xmlName: "properties.vpnPackageUri",
                type: {
                    name: "String"
                }
            } })
    }
};
const CertificatePatchResource = {
    serializedName: "CertificatePatchResource",
    type: {
        name: "Composite",
        className: "CertificatePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String"
                }
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                readOnly: true,
                xmlName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            }, subjectName: {
                serializedName: "properties.subjectName",
                readOnly: true,
                xmlName: "properties.subjectName",
                type: {
                    name: "String"
                }
            }, hostNames: {
                serializedName: "properties.hostNames",
                xmlName: "properties.hostNames",
                xmlElementName: "CertificatePatchResourcePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, pfxBlob: {
                serializedName: "properties.pfxBlob",
                xmlName: "properties.pfxBlob",
                type: {
                    name: "ByteArray"
                }
            }, siteName: {
                serializedName: "properties.siteName",
                readOnly: true,
                xmlName: "properties.siteName",
                type: {
                    name: "String"
                }
            }, selfLink: {
                serializedName: "properties.selfLink",
                readOnly: true,
                xmlName: "properties.selfLink",
                type: {
                    name: "String"
                }
            }, issuer: {
                serializedName: "properties.issuer",
                readOnly: true,
                xmlName: "properties.issuer",
                type: {
                    name: "String"
                }
            }, issueDate: {
                serializedName: "properties.issueDate",
                readOnly: true,
                xmlName: "properties.issueDate",
                type: {
                    name: "DateTime"
                }
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                readOnly: true,
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                xmlName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, valid: {
                serializedName: "properties.valid",
                readOnly: true,
                xmlName: "properties.valid",
                type: {
                    name: "Boolean"
                }
            }, cerBlob: {
                serializedName: "properties.cerBlob",
                readOnly: true,
                xmlName: "properties.cerBlob",
                type: {
                    name: "ByteArray"
                }
            }, publicKeyHash: {
                serializedName: "properties.publicKeyHash",
                readOnly: true,
                xmlName: "properties.publicKeyHash",
                type: {
                    name: "String"
                }
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile"
                }
            }, keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String"
                }
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String"
                }
            }, keyVaultSecretStatus: {
                serializedName: "properties.keyVaultSecretStatus",
                readOnly: true,
                xmlName: "properties.keyVaultSecretStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown"
                    ]
                }
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String"
                }
            }, canonicalName: {
                serializedName: "properties.canonicalName",
                xmlName: "properties.canonicalName",
                type: {
                    name: "String"
                }
            }, domainValidationMethod: {
                serializedName: "properties.domainValidationMethod",
                xmlName: "properties.domainValidationMethod",
                type: {
                    name: "String"
                }
            } })
    }
};
const DeletedSite = {
    serializedName: "DeletedSite",
    type: {
        name: "Composite",
        className: "DeletedSite",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deletedSiteId: {
                serializedName: "properties.deletedSiteId",
                readOnly: true,
                xmlName: "properties.deletedSiteId",
                type: {
                    name: "Number"
                }
            }, deletedTimestamp: {
                serializedName: "properties.deletedTimestamp",
                readOnly: true,
                xmlName: "properties.deletedTimestamp",
                type: {
                    name: "String"
                }
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                xmlName: "properties.subscription",
                type: {
                    name: "String"
                }
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String"
                }
            }, deletedSiteName: {
                serializedName: "properties.deletedSiteName",
                readOnly: true,
                xmlName: "properties.deletedSiteName",
                type: {
                    name: "String"
                }
            }, slot: {
                serializedName: "properties.slot",
                readOnly: true,
                xmlName: "properties.slot",
                type: {
                    name: "String"
                }
            }, kindPropertiesKind: {
                serializedName: "properties.kind",
                readOnly: true,
                xmlName: "properties.kind",
                type: {
                    name: "String"
                }
            }, geoRegionName: {
                serializedName: "properties.geoRegionName",
                readOnly: true,
                xmlName: "properties.geoRegionName",
                type: {
                    name: "String"
                }
            } })
    }
};
const DiagnosticCategory = {
    serializedName: "DiagnosticCategory",
    type: {
        name: "Composite",
        className: "DiagnosticCategory",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const AnalysisDefinition = {
    serializedName: "AnalysisDefinition",
    type: {
        name: "Composite",
        className: "AnalysisDefinition",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const DiagnosticAnalysis = {
    serializedName: "DiagnosticAnalysis",
    type: {
        name: "Composite",
        className: "DiagnosticAnalysis",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, abnormalTimePeriods: {
                serializedName: "properties.abnormalTimePeriods",
                xmlName: "properties.abnormalTimePeriods",
                xmlElementName: "AbnormalTimePeriod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AbnormalTimePeriod"
                        }
                    }
                }
            }, payload: {
                serializedName: "properties.payload",
                xmlName: "properties.payload",
                xmlElementName: "AnalysisData",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalysisData"
                        }
                    }
                }
            }, nonCorrelatedDetectors: {
                serializedName: "properties.nonCorrelatedDetectors",
                xmlName: "properties.nonCorrelatedDetectors",
                xmlElementName: "DetectorDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorDefinition"
                        }
                    }
                }
            } })
    }
};
const DetectorDefinitionResource = {
    serializedName: "DetectorDefinitionResource",
    type: {
        name: "Composite",
        className: "DetectorDefinitionResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, rank: {
                serializedName: "properties.rank",
                readOnly: true,
                xmlName: "properties.rank",
                type: {
                    name: "Number"
                }
            }, isEnabled: {
                serializedName: "properties.isEnabled",
                readOnly: true,
                xmlName: "properties.isEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DiagnosticDetectorResponse = {
    serializedName: "DiagnosticDetectorResponse",
    type: {
        name: "Composite",
        className: "DiagnosticDetectorResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, issueDetected: {
                serializedName: "properties.issueDetected",
                xmlName: "properties.issueDetected",
                type: {
                    name: "Boolean"
                }
            }, detectorDefinition: {
                serializedName: "properties.detectorDefinition",
                xmlName: "properties.detectorDefinition",
                type: {
                    name: "Composite",
                    className: "DetectorDefinition"
                }
            }, metrics: {
                serializedName: "properties.metrics",
                xmlName: "properties.metrics",
                xmlElementName: "DiagnosticMetricSet",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticMetricSet"
                        }
                    }
                }
            }, abnormalTimePeriods: {
                serializedName: "properties.abnormalTimePeriods",
                xmlName: "properties.abnormalTimePeriods",
                xmlElementName: "DetectorAbnormalTimePeriod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorAbnormalTimePeriod"
                        }
                    }
                }
            }, data: {
                serializedName: "properties.data",
                xmlName: "properties.data",
                xmlElementName: "DiagnosticDetectorResponsePropertiesDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair"
                                }
                            }
                        }
                    }
                }
            }, responseMetaData: {
                serializedName: "properties.responseMetaData",
                xmlName: "properties.responseMetaData",
                type: {
                    name: "Composite",
                    className: "ResponseMetaData"
                }
            } })
    }
};
const Snapshot = {
    serializedName: "Snapshot",
    type: {
        name: "Composite",
        className: "Snapshot",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { time: {
                serializedName: "properties.time",
                readOnly: true,
                xmlName: "properties.time",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubeEnvironmentPatchResource = {
    serializedName: "KubeEnvironmentPatchResource",
    type: {
        name: "Composite",
        className: "KubeEnvironmentPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "Waiting",
                        "InitializationInProgress",
                        "InfrastructureSetupInProgress",
                        "InfrastructureSetupComplete",
                        "ScheduledForDelete",
                        "UpgradeRequested",
                        "UpgradeFailed"
                    ]
                }
            }, deploymentErrors: {
                serializedName: "properties.deploymentErrors",
                readOnly: true,
                xmlName: "properties.deploymentErrors",
                type: {
                    name: "String"
                }
            }, internalLoadBalancerEnabled: {
                serializedName: "properties.internalLoadBalancerEnabled",
                xmlName: "properties.internalLoadBalancerEnabled",
                type: {
                    name: "Boolean"
                }
            }, defaultDomain: {
                serializedName: "properties.defaultDomain",
                readOnly: true,
                xmlName: "properties.defaultDomain",
                type: {
                    name: "String"
                }
            }, staticIp: {
                serializedName: "properties.staticIp",
                xmlName: "properties.staticIp",
                type: {
                    name: "String"
                }
            }, arcConfiguration: {
                serializedName: "properties.arcConfiguration",
                xmlName: "properties.arcConfiguration",
                type: {
                    name: "Composite",
                    className: "ArcConfiguration"
                }
            }, appLogsConfiguration: {
                serializedName: "properties.appLogsConfiguration",
                xmlName: "properties.appLogsConfiguration",
                type: {
                    name: "Composite",
                    className: "AppLogsConfiguration"
                }
            }, containerAppsConfiguration: {
                serializedName: "properties.containerAppsConfiguration",
                xmlName: "properties.containerAppsConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerAppsConfiguration"
                }
            }, aksResourceID: {
                serializedName: "properties.aksResourceID",
                xmlName: "properties.aksResourceID",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationStackResource = {
    serializedName: "ApplicationStackResource",
    type: {
        name: "Composite",
        className: "ApplicationStackResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { namePropertiesName: {
                serializedName: "properties.name",
                xmlName: "properties.name",
                type: {
                    name: "String"
                }
            }, display: {
                serializedName: "properties.display",
                xmlName: "properties.display",
                type: {
                    name: "String"
                }
            }, dependency: {
                serializedName: "properties.dependency",
                xmlName: "properties.dependency",
                type: {
                    name: "String"
                }
            }, majorVersions: {
                serializedName: "properties.majorVersions",
                xmlName: "properties.majorVersions",
                xmlElementName: "StackMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackMajorVersion"
                        }
                    }
                }
            }, frameworks: {
                serializedName: "properties.frameworks",
                xmlName: "properties.frameworks",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack"
                        }
                    }
                }
            }, isDeprecated: {
                serializedName: "properties.isDeprecated",
                xmlName: "properties.isDeprecated",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack"
                        }
                    }
                }
            } })
    }
};
const FunctionAppStack = {
    serializedName: "FunctionAppStack",
    type: {
        name: "Composite",
        className: "FunctionAppStack",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            }, displayText: {
                serializedName: "properties.displayText",
                readOnly: true,
                xmlName: "properties.displayText",
                type: {
                    name: "String"
                }
            }, value: {
                serializedName: "properties.value",
                readOnly: true,
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            }, majorVersions: {
                serializedName: "properties.majorVersions",
                readOnly: true,
                xmlName: "properties.majorVersions",
                xmlElementName: "FunctionAppMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionAppMajorVersion"
                        }
                    }
                }
            }, preferredOs: {
                serializedName: "properties.preferredOs",
                readOnly: true,
                xmlName: "properties.preferredOs",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            } })
    }
};
const WebAppStack = {
    serializedName: "WebAppStack",
    type: {
        name: "Composite",
        className: "WebAppStack",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            }, displayText: {
                serializedName: "properties.displayText",
                readOnly: true,
                xmlName: "properties.displayText",
                type: {
                    name: "String"
                }
            }, value: {
                serializedName: "properties.value",
                readOnly: true,
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            }, majorVersions: {
                serializedName: "properties.majorVersions",
                readOnly: true,
                xmlName: "properties.majorVersions",
                xmlElementName: "WebAppMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebAppMajorVersion"
                        }
                    }
                }
            }, preferredOs: {
                serializedName: "properties.preferredOs",
                readOnly: true,
                xmlName: "properties.preferredOs",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            } })
    }
};
const Recommendation = {
    serializedName: "Recommendation",
    type: {
        name: "Composite",
        className: "Recommendation",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { creationTime: {
                serializedName: "properties.creationTime",
                xmlName: "properties.creationTime",
                type: {
                    name: "DateTime"
                }
            }, recommendationId: {
                serializedName: "properties.recommendationId",
                xmlName: "properties.recommendationId",
                type: {
                    name: "Uuid"
                }
            }, resourceId: {
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, resourceScope: {
                serializedName: "properties.resourceScope",
                xmlName: "properties.resourceScope",
                type: {
                    name: "String"
                }
            }, ruleName: {
                serializedName: "properties.ruleName",
                xmlName: "properties.ruleName",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String"
                }
            }, level: {
                serializedName: "properties.level",
                xmlName: "properties.level",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Critical",
                        "Warning",
                        "Information",
                        "NonUrgentSuggestion"
                    ]
                }
            }, channels: {
                serializedName: "properties.channels",
                xmlName: "properties.channels",
                type: {
                    name: "Enum",
                    allowedValues: ["Notification", "Api", "Email", "Webhook", "All"]
                }
            }, categoryTags: {
                serializedName: "properties.categoryTags",
                readOnly: true,
                xmlName: "properties.categoryTags",
                xmlElementName: "RecommendationPropertiesCategoryTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, actionName: {
                serializedName: "properties.actionName",
                xmlName: "properties.actionName",
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Number"
                }
            }, states: {
                serializedName: "properties.states",
                xmlName: "properties.states",
                xmlElementName: "RecommendationPropertiesStatesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, nextNotificationTime: {
                serializedName: "properties.nextNotificationTime",
                xmlName: "properties.nextNotificationTime",
                type: {
                    name: "DateTime"
                }
            }, notificationExpirationTime: {
                serializedName: "properties.notificationExpirationTime",
                xmlName: "properties.notificationExpirationTime",
                type: {
                    name: "DateTime"
                }
            }, notifiedTime: {
                serializedName: "properties.notifiedTime",
                xmlName: "properties.notifiedTime",
                type: {
                    name: "DateTime"
                }
            }, score: {
                serializedName: "properties.score",
                xmlName: "properties.score",
                type: {
                    name: "Number"
                }
            }, isDynamic: {
                serializedName: "properties.isDynamic",
                xmlName: "properties.isDynamic",
                type: {
                    name: "Boolean"
                }
            }, extensionName: {
                serializedName: "properties.extensionName",
                xmlName: "properties.extensionName",
                type: {
                    name: "String"
                }
            }, bladeName: {
                serializedName: "properties.bladeName",
                xmlName: "properties.bladeName",
                type: {
                    name: "String"
                }
            }, forwardLink: {
                serializedName: "properties.forwardLink",
                xmlName: "properties.forwardLink",
                type: {
                    name: "String"
                }
            } })
    }
};
const RecommendationRule = {
    serializedName: "RecommendationRule",
    type: {
        name: "Composite",
        className: "RecommendationRule",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { recommendationName: {
                serializedName: "properties.recommendationName",
                xmlName: "properties.recommendationName",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String"
                }
            }, recommendationId: {
                serializedName: "properties.recommendationId",
                xmlName: "properties.recommendationId",
                type: {
                    name: "Uuid"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, actionName: {
                serializedName: "properties.actionName",
                xmlName: "properties.actionName",
                type: {
                    name: "String"
                }
            }, level: {
                serializedName: "properties.level",
                xmlName: "properties.level",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Critical",
                        "Warning",
                        "Information",
                        "NonUrgentSuggestion"
                    ]
                }
            }, channels: {
                serializedName: "properties.channels",
                xmlName: "properties.channels",
                type: {
                    name: "Enum",
                    allowedValues: ["Notification", "Api", "Email", "Webhook", "All"]
                }
            }, categoryTags: {
                serializedName: "properties.categoryTags",
                readOnly: true,
                xmlName: "properties.categoryTags",
                xmlElementName: "RecommendationRulePropertiesCategoryTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isDynamic: {
                serializedName: "properties.isDynamic",
                xmlName: "properties.isDynamic",
                type: {
                    name: "Boolean"
                }
            }, extensionName: {
                serializedName: "properties.extensionName",
                xmlName: "properties.extensionName",
                type: {
                    name: "String"
                }
            }, bladeName: {
                serializedName: "properties.bladeName",
                xmlName: "properties.bladeName",
                type: {
                    name: "String"
                }
            }, forwardLink: {
                serializedName: "properties.forwardLink",
                xmlName: "properties.forwardLink",
                type: {
                    name: "String"
                }
            } })
    }
};
const ResourceHealthMetadata = {
    serializedName: "ResourceHealthMetadata",
    type: {
        name: "Composite",
        className: "ResourceHealthMetadata",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { category: {
                serializedName: "properties.category",
                xmlName: "properties.category",
                type: {
                    name: "String"
                }
            }, signalAvailability: {
                serializedName: "properties.signalAvailability",
                xmlName: "properties.signalAvailability",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const User = {
    serializedName: "User",
    type: {
        name: "Composite",
        className: "User",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { publishingUserName: {
                serializedName: "properties.publishingUserName",
                xmlName: "properties.publishingUserName",
                type: {
                    name: "String"
                }
            }, publishingPassword: {
                serializedName: "properties.publishingPassword",
                xmlName: "properties.publishingPassword",
                type: {
                    name: "String"
                }
            }, publishingPasswordHash: {
                serializedName: "properties.publishingPasswordHash",
                xmlName: "properties.publishingPasswordHash",
                type: {
                    name: "String"
                }
            }, publishingPasswordHashSalt: {
                serializedName: "properties.publishingPasswordHashSalt",
                xmlName: "properties.publishingPasswordHashSalt",
                type: {
                    name: "String"
                }
            }, scmUri: {
                serializedName: "properties.scmUri",
                xmlName: "properties.scmUri",
                type: {
                    name: "String"
                }
            } })
    }
};
const SourceControl = {
    serializedName: "SourceControl",
    type: {
        name: "Composite",
        className: "SourceControl",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { token: {
                serializedName: "properties.token",
                xmlName: "properties.token",
                type: {
                    name: "String"
                }
            }, tokenSecret: {
                serializedName: "properties.tokenSecret",
                xmlName: "properties.tokenSecret",
                type: {
                    name: "String"
                }
            }, refreshToken: {
                serializedName: "properties.refreshToken",
                xmlName: "properties.refreshToken",
                type: {
                    name: "String"
                }
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const BillingMeter = {
    serializedName: "BillingMeter",
    type: {
        name: "Composite",
        className: "BillingMeter",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { meterId: {
                serializedName: "properties.meterId",
                xmlName: "properties.meterId",
                type: {
                    name: "String"
                }
            }, billingLocation: {
                serializedName: "properties.billingLocation",
                xmlName: "properties.billingLocation",
                type: {
                    name: "String"
                }
            }, shortName: {
                serializedName: "properties.shortName",
                xmlName: "properties.shortName",
                type: {
                    name: "String"
                }
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                xmlName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            }, resourceType: {
                serializedName: "properties.resourceType",
                xmlName: "properties.resourceType",
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                xmlName: "properties.osType",
                type: {
                    name: "String"
                }
            }, multiplier: {
                serializedName: "properties.multiplier",
                xmlName: "properties.multiplier",
                type: {
                    name: "Number"
                }
            } })
    }
};
const Identifier = {
    serializedName: "Identifier",
    type: {
        name: "Composite",
        className: "Identifier",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { value: {
                serializedName: "properties.id",
                xmlName: "properties.id",
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomHostnameSites = {
    serializedName: "CustomHostnameSites",
    type: {
        name: "Composite",
        className: "CustomHostnameSites",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { customHostname: {
                serializedName: "properties.customHostname",
                xmlName: "properties.customHostname",
                type: {
                    name: "String"
                }
            }, region: {
                serializedName: "properties.region",
                xmlName: "properties.region",
                type: {
                    name: "String"
                }
            }, siteResourceIds: {
                serializedName: "properties.siteResourceIds",
                xmlName: "properties.siteResourceIds",
                xmlElementName: "Identifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Identifier"
                        }
                    }
                }
            } })
    }
};
const GeoRegion = {
    serializedName: "GeoRegion",
    type: {
        name: "Composite",
        className: "GeoRegion",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, orgDomain: {
                serializedName: "properties.orgDomain",
                readOnly: true,
                xmlName: "properties.orgDomain",
                type: {
                    name: "String"
                }
            } })
    }
};
const PremierAddOnOffer = {
    serializedName: "PremierAddOnOffer",
    type: {
        name: "Composite",
        className: "PremierAddOnOffer",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "String"
                }
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String"
                }
            }, vendor: {
                serializedName: "properties.vendor",
                xmlName: "properties.vendor",
                type: {
                    name: "String"
                }
            }, promoCodeRequired: {
                serializedName: "properties.promoCodeRequired",
                xmlName: "properties.promoCodeRequired",
                type: {
                    name: "Boolean"
                }
            }, quota: {
                serializedName: "properties.quota",
                xmlName: "properties.quota",
                type: {
                    name: "Number"
                }
            }, webHostingPlanRestrictions: {
                serializedName: "properties.webHostingPlanRestrictions",
                xmlName: "properties.webHostingPlanRestrictions",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Free",
                        "Shared",
                        "Basic",
                        "Standard",
                        "Premium"
                    ]
                }
            }, privacyPolicyUrl: {
                serializedName: "properties.privacyPolicyUrl",
                xmlName: "properties.privacyPolicyUrl",
                type: {
                    name: "String"
                }
            }, legalTermsUrl: {
                serializedName: "properties.legalTermsUrl",
                xmlName: "properties.legalTermsUrl",
                type: {
                    name: "String"
                }
            }, marketplacePublisher: {
                serializedName: "properties.marketplacePublisher",
                xmlName: "properties.marketplacePublisher",
                type: {
                    name: "String"
                }
            }, marketplaceOffer: {
                serializedName: "properties.marketplaceOffer",
                xmlName: "properties.marketplaceOffer",
                type: {
                    name: "String"
                }
            } })
    }
};
const VnetParameters = {
    serializedName: "VnetParameters",
    type: {
        name: "Composite",
        className: "VnetParameters",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { vnetResourceGroup: {
                serializedName: "properties.vnetResourceGroup",
                xmlName: "properties.vnetResourceGroup",
                type: {
                    name: "String"
                }
            }, vnetName: {
                serializedName: "properties.vnetName",
                xmlName: "properties.vnetName",
                type: {
                    name: "String"
                }
            }, vnetSubnetName: {
                serializedName: "properties.vnetSubnetName",
                xmlName: "properties.vnetSubnetName",
                type: {
                    name: "String"
                }
            }, subnetResourceId: {
                serializedName: "properties.subnetResourceId",
                xmlName: "properties.subnetResourceId",
                type: {
                    name: "String"
                }
            } })
    }
};
const VnetValidationTestFailure = {
    serializedName: "VnetValidationTestFailure",
    type: {
        name: "Composite",
        className: "VnetValidationTestFailure",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { testName: {
                serializedName: "properties.testName",
                xmlName: "properties.testName",
                type: {
                    name: "String"
                }
            }, details: {
                serializedName: "properties.details",
                xmlName: "properties.details",
                type: {
                    name: "String"
                }
            } })
    }
};
const VnetValidationFailureDetails = {
    serializedName: "VnetValidationFailureDetails",
    type: {
        name: "Composite",
        className: "VnetValidationFailureDetails",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String"
                }
            }, failed: {
                serializedName: "properties.failed",
                xmlName: "properties.failed",
                type: {
                    name: "Boolean"
                }
            }, failedTests: {
                serializedName: "properties.failedTests",
                xmlName: "properties.failedTests",
                xmlElementName: "VnetValidationTestFailure",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetValidationTestFailure"
                        }
                    }
                }
            }, warnings: {
                serializedName: "properties.warnings",
                xmlName: "properties.warnings",
                xmlElementName: "VnetValidationTestFailure",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetValidationTestFailure"
                        }
                    }
                }
            } })
    }
};
const StaticSitesWorkflowPreviewRequest = {
    serializedName: "StaticSitesWorkflowPreviewRequest",
    type: {
        name: "Composite",
        className: "StaticSitesWorkflowPreviewRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { repositoryUrl: {
                serializedName: "properties.repositoryUrl",
                xmlName: "properties.repositoryUrl",
                type: {
                    name: "String"
                }
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            }, buildProperties: {
                serializedName: "properties.buildProperties",
                xmlName: "properties.buildProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteBuildProperties"
                }
            } })
    }
};
const StaticSitesWorkflowPreview = {
    serializedName: "StaticSitesWorkflowPreview",
    type: {
        name: "Composite",
        className: "StaticSitesWorkflowPreview",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { path: {
                serializedName: "properties.path",
                readOnly: true,
                xmlName: "properties.path",
                type: {
                    name: "String"
                }
            }, contents: {
                serializedName: "properties.contents",
                readOnly: true,
                xmlName: "properties.contents",
                type: {
                    name: "String"
                }
            } })
    }
};
const RemotePrivateEndpointConnection = {
    serializedName: "RemotePrivateEndpointConnection",
    type: {
        name: "Composite",
        className: "RemotePrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                xmlName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ArmIdWrapper"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState"
                }
            }, ipAddresses: {
                serializedName: "properties.ipAddresses",
                xmlName: "properties.ipAddresses",
                xmlElementName: "RemotePrivateEndpointConnectionPropertiesIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StaticSiteUserProvidedFunctionApp = {
    serializedName: "StaticSiteUserProvidedFunctionApp",
    type: {
        name: "Composite",
        className: "StaticSiteUserProvidedFunctionApp",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionAppResourceId: {
                serializedName: "properties.functionAppResourceId",
                xmlName: "properties.functionAppResourceId",
                type: {
                    name: "String"
                }
            }, functionAppRegion: {
                serializedName: "properties.functionAppRegion",
                xmlName: "properties.functionAppRegion",
                type: {
                    name: "String"
                }
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const StaticSitePatchResource = {
    serializedName: "StaticSitePatchResource",
    type: {
        name: "Composite",
        className: "StaticSitePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { defaultHostname: {
                serializedName: "properties.defaultHostname",
                readOnly: true,
                xmlName: "properties.defaultHostname",
                type: {
                    name: "String"
                }
            }, repositoryUrl: {
                serializedName: "properties.repositoryUrl",
                xmlName: "properties.repositoryUrl",
                type: {
                    name: "String"
                }
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            }, customDomains: {
                serializedName: "properties.customDomains",
                readOnly: true,
                xmlName: "properties.customDomains",
                xmlElementName: "StaticSiteCustomDomainsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, repositoryToken: {
                serializedName: "properties.repositoryToken",
                xmlName: "properties.repositoryToken",
                type: {
                    name: "String"
                }
            }, buildProperties: {
                serializedName: "properties.buildProperties",
                xmlName: "properties.buildProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteBuildProperties"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                xmlName: "properties.privateEndpointConnections",
                xmlElementName: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseMessageEnvelopeRemotePrivateEndpointConnection"
                        }
                    }
                }
            }, stagingEnvironmentPolicy: {
                serializedName: "properties.stagingEnvironmentPolicy",
                xmlName: "properties.stagingEnvironmentPolicy",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, allowConfigFileUpdates: {
                serializedName: "properties.allowConfigFileUpdates",
                xmlName: "properties.allowConfigFileUpdates",
                type: {
                    name: "Boolean"
                }
            }, templateProperties: {
                serializedName: "properties.templateProperties",
                xmlName: "properties.templateProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteTemplateOptions"
                }
            }, contentDistributionEndpoint: {
                serializedName: "properties.contentDistributionEndpoint",
                readOnly: true,
                xmlName: "properties.contentDistributionEndpoint",
                type: {
                    name: "String"
                }
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                readOnly: true,
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            }, userProvidedFunctionApps: {
                serializedName: "properties.userProvidedFunctionApps",
                readOnly: true,
                xmlName: "properties.userProvidedFunctionApps",
                xmlElementName: "StaticSiteUserProvidedFunctionApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionApp"
                        }
                    }
                }
            }, linkedBackends: {
                serializedName: "properties.linkedBackends",
                readOnly: true,
                xmlName: "properties.linkedBackends",
                xmlElementName: "StaticSiteLinkedBackend",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackend"
                        }
                    }
                }
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String"
                }
            }, enterpriseGradeCdnStatus: {
                serializedName: "properties.enterpriseGradeCdnStatus",
                xmlName: "properties.enterpriseGradeCdnStatus",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteUserARMResource = {
    serializedName: "StaticSiteUserARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provider: {
                serializedName: "properties.provider",
                readOnly: true,
                xmlName: "properties.provider",
                type: {
                    name: "String"
                }
            }, userId: {
                serializedName: "properties.userId",
                readOnly: true,
                xmlName: "properties.userId",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, roles: {
                serializedName: "properties.roles",
                xmlName: "properties.roles",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteBuildARMResource = {
    serializedName: "StaticSiteBuildARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteBuildARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { buildId: {
                serializedName: "properties.buildId",
                readOnly: true,
                xmlName: "properties.buildId",
                type: {
                    name: "String"
                }
            }, sourceBranch: {
                serializedName: "properties.sourceBranch",
                readOnly: true,
                xmlName: "properties.sourceBranch",
                type: {
                    name: "String"
                }
            }, pullRequestTitle: {
                serializedName: "properties.pullRequestTitle",
                readOnly: true,
                xmlName: "properties.pullRequestTitle",
                type: {
                    name: "String"
                }
            }, hostname: {
                serializedName: "properties.hostname",
                readOnly: true,
                xmlName: "properties.hostname",
                type: {
                    name: "String"
                }
            }, createdTimeUtc: {
                serializedName: "properties.createdTimeUtc",
                readOnly: true,
                xmlName: "properties.createdTimeUtc",
                type: {
                    name: "DateTime"
                }
            }, lastUpdatedOn: {
                serializedName: "properties.lastUpdatedOn",
                readOnly: true,
                xmlName: "properties.lastUpdatedOn",
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, userProvidedFunctionApps: {
                serializedName: "properties.userProvidedFunctionApps",
                readOnly: true,
                xmlName: "properties.userProvidedFunctionApps",
                xmlElementName: "StaticSiteUserProvidedFunctionApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionApp"
                        }
                    }
                }
            }, linkedBackends: {
                serializedName: "properties.linkedBackends",
                readOnly: true,
                xmlName: "properties.linkedBackends",
                xmlElementName: "StaticSiteLinkedBackend",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackend"
                        }
                    }
                }
            } })
    }
};
const StringDictionary = {
    serializedName: "StringDictionary",
    type: {
        name: "Composite",
        className: "StringDictionary",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const StaticSiteFunctionOverviewARMResource = {
    serializedName: "StaticSiteFunctionOverviewARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteFunctionOverviewARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionName: {
                serializedName: "properties.functionName",
                readOnly: true,
                xmlName: "properties.functionName",
                type: {
                    name: "String"
                }
            }, triggerType: {
                serializedName: "properties.triggerType",
                readOnly: true,
                xmlName: "properties.triggerType",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteUserProvidedFunctionAppARMResource = {
    serializedName: "StaticSiteUserProvidedFunctionAppARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserProvidedFunctionAppARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionAppResourceId: {
                serializedName: "properties.functionAppResourceId",
                xmlName: "properties.functionAppResourceId",
                type: {
                    name: "String"
                }
            }, functionAppRegion: {
                serializedName: "properties.functionAppRegion",
                xmlName: "properties.functionAppRegion",
                type: {
                    name: "String"
                }
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const StaticSiteZipDeploymentARMResource = {
    serializedName: "StaticSiteZipDeploymentARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteZipDeploymentARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { appZipUrl: {
                serializedName: "properties.appZipUrl",
                xmlName: "properties.appZipUrl",
                type: {
                    name: "String"
                }
            }, apiZipUrl: {
                serializedName: "properties.apiZipUrl",
                xmlName: "properties.apiZipUrl",
                type: {
                    name: "String"
                }
            }, deploymentTitle: {
                serializedName: "properties.deploymentTitle",
                xmlName: "properties.deploymentTitle",
                type: {
                    name: "String"
                }
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String"
                }
            }, functionLanguage: {
                serializedName: "properties.functionLanguage",
                xmlName: "properties.functionLanguage",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteUserInvitationRequestResource = {
    serializedName: "StaticSiteUserInvitationRequestResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserInvitationRequestResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { domain: {
                serializedName: "properties.domain",
                xmlName: "properties.domain",
                type: {
                    name: "String"
                }
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String"
                }
            }, userDetails: {
                serializedName: "properties.userDetails",
                xmlName: "properties.userDetails",
                type: {
                    name: "String"
                }
            }, roles: {
                serializedName: "properties.roles",
                xmlName: "properties.roles",
                type: {
                    name: "String"
                }
            }, numHoursToExpiration: {
                serializedName: "properties.numHoursToExpiration",
                xmlName: "properties.numHoursToExpiration",
                type: {
                    name: "Number"
                }
            } })
    }
};
const StaticSiteUserInvitationResponseResource = {
    serializedName: "StaticSiteUserInvitationResponseResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserInvitationResponseResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { expiresOn: {
                serializedName: "properties.expiresOn",
                readOnly: true,
                xmlName: "properties.expiresOn",
                type: {
                    name: "DateTime"
                }
            }, invitationUrl: {
                serializedName: "properties.invitationUrl",
                readOnly: true,
                xmlName: "properties.invitationUrl",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteCustomDomainOverviewARMResource = {
    serializedName: "StaticSiteCustomDomainOverviewARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteCustomDomainOverviewARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { domainName: {
                serializedName: "properties.domainName",
                readOnly: true,
                xmlName: "properties.domainName",
                type: {
                    name: "String"
                }
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, validationToken: {
                serializedName: "properties.validationToken",
                readOnly: true,
                xmlName: "properties.validationToken",
                type: {
                    name: "String"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                xmlName: "properties.errorMessage",
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticSiteCustomDomainRequestPropertiesARMResource = {
    serializedName: "StaticSiteCustomDomainRequestPropertiesARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteCustomDomainRequestPropertiesARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { validationMethod: {
                defaultValue: "cname-delegation",
                serializedName: "properties.validationMethod",
                xmlName: "properties.validationMethod",
                type: {
                    name: "String"
                }
            } })
    }
};
const StringList = {
    serializedName: "StringList",
    type: {
        name: "Composite",
        className: "StringList",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                xmlElementName: "StringListPropertiesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StaticSiteResetPropertiesARMResource = {
    serializedName: "StaticSiteResetPropertiesARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteResetPropertiesARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { repositoryToken: {
                serializedName: "properties.repositoryToken",
                xmlName: "properties.repositoryToken",
                type: {
                    name: "String"
                }
            }, shouldUpdateRepository: {
                serializedName: "properties.shouldUpdateRepository",
                xmlName: "properties.shouldUpdateRepository",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const StaticSiteLinkedBackendARMResource = {
    serializedName: "StaticSiteLinkedBackendARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteLinkedBackendARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { backendResourceId: {
                serializedName: "properties.backendResourceId",
                xmlName: "properties.backendResourceId",
                type: {
                    name: "String"
                }
            }, region: {
                serializedName: "properties.region",
                xmlName: "properties.region",
                type: {
                    name: "String"
                }
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const SitePatchResource = {
    serializedName: "SitePatchResource",
    type: {
        name: "Composite",
        className: "SitePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, hostNames: {
                serializedName: "properties.hostNames",
                readOnly: true,
                xmlName: "properties.hostNames",
                xmlElementName: "SitePatchResourcePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, repositorySiteName: {
                serializedName: "properties.repositorySiteName",
                readOnly: true,
                xmlName: "properties.repositorySiteName",
                type: {
                    name: "String"
                }
            }, usageState: {
                serializedName: "properties.usageState",
                readOnly: true,
                xmlName: "properties.usageState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Exceeded"]
                }
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, enabledHostNames: {
                serializedName: "properties.enabledHostNames",
                readOnly: true,
                xmlName: "properties.enabledHostNames",
                xmlElementName: "SitePatchResourcePropertiesEnabledHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availabilityState: {
                serializedName: "properties.availabilityState",
                readOnly: true,
                xmlName: "properties.availabilityState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Limited", "DisasterRecoveryMode"]
                }
            }, hostNameSslStates: {
                serializedName: "properties.hostNameSslStates",
                xmlName: "properties.hostNameSslStates",
                xmlElementName: "HostNameSslState",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostNameSslState"
                        }
                    }
                }
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String"
                }
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean"
                }
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean"
                }
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean"
                }
            }, lastModifiedTimeUtc: {
                serializedName: "properties.lastModifiedTimeUtc",
                readOnly: true,
                xmlName: "properties.lastModifiedTimeUtc",
                type: {
                    name: "DateTime"
                }
            }, siteConfig: {
                serializedName: "properties.siteConfig",
                xmlName: "properties.siteConfig",
                type: {
                    name: "Composite",
                    className: "SiteConfig"
                }
            }, trafficManagerHostNames: {
                serializedName: "properties.trafficManagerHostNames",
                readOnly: true,
                xmlName: "properties.trafficManagerHostNames",
                xmlElementName: "SitePatchResourcePropertiesTrafficManagerHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, scmSiteAlsoStopped: {
                defaultValue: false,
                serializedName: "properties.scmSiteAlsoStopped",
                xmlName: "properties.scmSiteAlsoStopped",
                type: {
                    name: "Boolean"
                }
            }, targetSwapSlot: {
                serializedName: "properties.targetSwapSlot",
                readOnly: true,
                xmlName: "properties.targetSwapSlot",
                type: {
                    name: "String"
                }
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile"
                }
            }, clientAffinityEnabled: {
                serializedName: "properties.clientAffinityEnabled",
                xmlName: "properties.clientAffinityEnabled",
                type: {
                    name: "Boolean"
                }
            }, clientCertEnabled: {
                serializedName: "properties.clientCertEnabled",
                xmlName: "properties.clientCertEnabled",
                type: {
                    name: "Boolean"
                }
            }, clientCertMode: {
                serializedName: "properties.clientCertMode",
                xmlName: "properties.clientCertMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Required", "Optional", "OptionalInteractiveUser"]
                }
            }, clientCertExclusionPaths: {
                serializedName: "properties.clientCertExclusionPaths",
                xmlName: "properties.clientCertExclusionPaths",
                type: {
                    name: "String"
                }
            }, hostNamesDisabled: {
                serializedName: "properties.hostNamesDisabled",
                xmlName: "properties.hostNamesDisabled",
                type: {
                    name: "Boolean"
                }
            }, customDomainVerificationId: {
                serializedName: "properties.customDomainVerificationId",
                xmlName: "properties.customDomainVerificationId",
                type: {
                    name: "String"
                }
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                readOnly: true,
                xmlName: "properties.outboundIpAddresses",
                type: {
                    name: "String"
                }
            }, possibleOutboundIpAddresses: {
                serializedName: "properties.possibleOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.possibleOutboundIpAddresses",
                type: {
                    name: "String"
                }
            }, containerSize: {
                serializedName: "properties.containerSize",
                xmlName: "properties.containerSize",
                type: {
                    name: "Number"
                }
            }, dailyMemoryTimeQuota: {
                serializedName: "properties.dailyMemoryTimeQuota",
                xmlName: "properties.dailyMemoryTimeQuota",
                type: {
                    name: "Number"
                }
            }, suspendedTill: {
                serializedName: "properties.suspendedTill",
                readOnly: true,
                xmlName: "properties.suspendedTill",
                type: {
                    name: "DateTime"
                }
            }, maxNumberOfWorkers: {
                serializedName: "properties.maxNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maxNumberOfWorkers",
                type: {
                    name: "Number"
                }
            }, cloningInfo: {
                serializedName: "properties.cloningInfo",
                xmlName: "properties.cloningInfo",
                type: {
                    name: "Composite",
                    className: "CloningInfo"
                }
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String"
                }
            }, isDefaultContainer: {
                serializedName: "properties.isDefaultContainer",
                readOnly: true,
                xmlName: "properties.isDefaultContainer",
                type: {
                    name: "Boolean"
                }
            }, defaultHostName: {
                serializedName: "properties.defaultHostName",
                readOnly: true,
                xmlName: "properties.defaultHostName",
                type: {
                    name: "String"
                }
            }, slotSwapStatus: {
                serializedName: "properties.slotSwapStatus",
                xmlName: "properties.slotSwapStatus",
                type: {
                    name: "Composite",
                    className: "SlotSwapStatus"
                }
            }, httpsOnly: {
                serializedName: "properties.httpsOnly",
                xmlName: "properties.httpsOnly",
                type: {
                    name: "Boolean"
                }
            }, redundancyMode: {
                serializedName: "properties.redundancyMode",
                xmlName: "properties.redundancyMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Manual",
                        "Failover",
                        "ActiveActive",
                        "GeoRedundant"
                    ]
                }
            }, inProgressOperationId: {
                serializedName: "properties.inProgressOperationId",
                readOnly: true,
                xmlName: "properties.inProgressOperationId",
                type: {
                    name: "Uuid"
                }
            }, storageAccountRequired: {
                serializedName: "properties.storageAccountRequired",
                xmlName: "properties.storageAccountRequired",
                type: {
                    name: "Boolean"
                }
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            }, virtualNetworkSubnetId: {
                serializedName: "properties.virtualNetworkSubnetId",
                xmlName: "properties.virtualNetworkSubnetId",
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomHostnameAnalysisResult = {
    serializedName: "CustomHostnameAnalysisResult",
    type: {
        name: "Composite",
        className: "CustomHostnameAnalysisResult",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { isHostnameAlreadyVerified: {
                serializedName: "properties.isHostnameAlreadyVerified",
                readOnly: true,
                xmlName: "properties.isHostnameAlreadyVerified",
                type: {
                    name: "Boolean"
                }
            }, customDomainVerificationTest: {
                serializedName: "properties.customDomainVerificationTest",
                readOnly: true,
                xmlName: "properties.customDomainVerificationTest",
                type: {
                    name: "Enum",
                    allowedValues: ["Passed", "Failed", "Skipped"]
                }
            }, customDomainVerificationFailureInfo: {
                serializedName: "properties.customDomainVerificationFailureInfo",
                xmlName: "properties.customDomainVerificationFailureInfo",
                type: {
                    name: "Composite",
                    className: "ErrorEntity"
                }
            }, hasConflictOnScaleUnit: {
                serializedName: "properties.hasConflictOnScaleUnit",
                readOnly: true,
                xmlName: "properties.hasConflictOnScaleUnit",
                type: {
                    name: "Boolean"
                }
            }, hasConflictAcrossSubscription: {
                serializedName: "properties.hasConflictAcrossSubscription",
                readOnly: true,
                xmlName: "properties.hasConflictAcrossSubscription",
                type: {
                    name: "Boolean"
                }
            }, conflictingAppResourceId: {
                serializedName: "properties.conflictingAppResourceId",
                readOnly: true,
                xmlName: "properties.conflictingAppResourceId",
                type: {
                    name: "String"
                }
            }, cNameRecords: {
                serializedName: "properties.cNameRecords",
                xmlName: "properties.cNameRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesCNameRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, txtRecords: {
                serializedName: "properties.txtRecords",
                xmlName: "properties.txtRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesTxtRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, aRecords: {
                serializedName: "properties.aRecords",
                xmlName: "properties.aRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesARecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, alternateCNameRecords: {
                serializedName: "properties.alternateCNameRecords",
                xmlName: "properties.alternateCNameRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesAlternateCNameRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, alternateTxtRecords: {
                serializedName: "properties.alternateTxtRecords",
                xmlName: "properties.alternateTxtRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesAlternateTxtRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const BackupRequest = {
    serializedName: "BackupRequest",
    type: {
        name: "Composite",
        className: "BackupRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { backupName: {
                serializedName: "properties.backupName",
                xmlName: "properties.backupName",
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, storageAccountUrl: {
                serializedName: "properties.storageAccountUrl",
                xmlName: "properties.storageAccountUrl",
                type: {
                    name: "String"
                }
            }, backupSchedule: {
                serializedName: "properties.backupSchedule",
                xmlName: "properties.backupSchedule",
                type: {
                    name: "Composite",
                    className: "BackupSchedule"
                }
            }, databases: {
                serializedName: "properties.databases",
                xmlName: "properties.databases",
                xmlElementName: "DatabaseBackupSetting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBackupSetting"
                        }
                    }
                }
            } })
    }
};
const BackupItem = {
    serializedName: "BackupItem",
    type: {
        name: "Composite",
        className: "BackupItem",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { backupId: {
                serializedName: "properties.id",
                readOnly: true,
                xmlName: "properties.id",
                type: {
                    name: "Number"
                }
            }, storageAccountUrl: {
                serializedName: "properties.storageAccountUrl",
                readOnly: true,
                xmlName: "properties.storageAccountUrl",
                type: {
                    name: "String"
                }
            }, blobName: {
                serializedName: "properties.blobName",
                readOnly: true,
                xmlName: "properties.blobName",
                type: {
                    name: "String"
                }
            }, namePropertiesName: {
                serializedName: "properties.name",
                readOnly: true,
                xmlName: "properties.name",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InProgress",
                        "Failed",
                        "Succeeded",
                        "TimedOut",
                        "Created",
                        "Skipped",
                        "PartiallySucceeded",
                        "DeleteInProgress",
                        "DeleteFailed",
                        "Deleted"
                    ]
                }
            }, sizeInBytes: {
                serializedName: "properties.sizeInBytes",
                readOnly: true,
                xmlName: "properties.sizeInBytes",
                type: {
                    name: "Number"
                }
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                xmlName: "properties.created",
                type: {
                    name: "DateTime"
                }
            }, log: {
                serializedName: "properties.log",
                readOnly: true,
                xmlName: "properties.log",
                type: {
                    name: "String"
                }
            }, databases: {
                serializedName: "properties.databases",
                readOnly: true,
                xmlName: "properties.databases",
                xmlElementName: "DatabaseBackupSetting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBackupSetting"
                        }
                    }
                }
            }, scheduled: {
                serializedName: "properties.scheduled",
                readOnly: true,
                xmlName: "properties.scheduled",
                type: {
                    name: "Boolean"
                }
            }, lastRestoreTimeStamp: {
                serializedName: "properties.lastRestoreTimeStamp",
                readOnly: true,
                xmlName: "properties.lastRestoreTimeStamp",
                type: {
                    name: "DateTime"
                }
            }, finishedTimeStamp: {
                serializedName: "properties.finishedTimeStamp",
                readOnly: true,
                xmlName: "properties.finishedTimeStamp",
                type: {
                    name: "DateTime"
                }
            }, correlationId: {
                serializedName: "properties.correlationId",
                readOnly: true,
                xmlName: "properties.correlationId",
                type: {
                    name: "String"
                }
            }, websiteSizeInBytes: {
                serializedName: "properties.websiteSizeInBytes",
                readOnly: true,
                xmlName: "properties.websiteSizeInBytes",
                type: {
                    name: "Number"
                }
            } })
    }
};
const RestoreRequest = {
    serializedName: "RestoreRequest",
    type: {
        name: "Composite",
        className: "RestoreRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { storageAccountUrl: {
                serializedName: "properties.storageAccountUrl",
                xmlName: "properties.storageAccountUrl",
                type: {
                    name: "String"
                }
            }, blobName: {
                serializedName: "properties.blobName",
                xmlName: "properties.blobName",
                type: {
                    name: "String"
                }
            }, overwrite: {
                serializedName: "properties.overwrite",
                xmlName: "properties.overwrite",
                type: {
                    name: "Boolean"
                }
            }, siteName: {
                serializedName: "properties.siteName",
                xmlName: "properties.siteName",
                type: {
                    name: "String"
                }
            }, databases: {
                serializedName: "properties.databases",
                xmlName: "properties.databases",
                xmlElementName: "DatabaseBackupSetting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBackupSetting"
                        }
                    }
                }
            }, ignoreConflictingHostNames: {
                defaultValue: false,
                serializedName: "properties.ignoreConflictingHostNames",
                xmlName: "properties.ignoreConflictingHostNames",
                type: {
                    name: "Boolean"
                }
            }, ignoreDatabases: {
                defaultValue: false,
                serializedName: "properties.ignoreDatabases",
                xmlName: "properties.ignoreDatabases",
                type: {
                    name: "Boolean"
                }
            }, appServicePlan: {
                serializedName: "properties.appServicePlan",
                xmlName: "properties.appServicePlan",
                type: {
                    name: "String"
                }
            }, operationType: {
                defaultValue: "Default",
                serializedName: "properties.operationType",
                xmlName: "properties.operationType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Default",
                        "Clone",
                        "Relocation",
                        "Snapshot",
                        "CloudFS"
                    ]
                }
            }, adjustConnectionStrings: {
                serializedName: "properties.adjustConnectionStrings",
                xmlName: "properties.adjustConnectionStrings",
                type: {
                    name: "Boolean"
                }
            }, hostingEnvironment: {
                serializedName: "properties.hostingEnvironment",
                xmlName: "properties.hostingEnvironment",
                type: {
                    name: "String"
                }
            } })
    }
};
const CsmPublishingCredentialsPoliciesEntity = {
    serializedName: "CsmPublishingCredentialsPoliciesEntity",
    type: {
        name: "Composite",
        className: "CsmPublishingCredentialsPoliciesEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { allow: {
                serializedName: "properties.allow",
                xmlName: "properties.allow",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SiteConfigResource = {
    serializedName: "SiteConfigResource",
    type: {
        name: "Composite",
        className: "SiteConfigResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { numberOfWorkers: {
                serializedName: "properties.numberOfWorkers",
                xmlName: "properties.numberOfWorkers",
                type: {
                    name: "Number"
                }
            }, defaultDocuments: {
                serializedName: "properties.defaultDocuments",
                xmlName: "properties.defaultDocuments",
                xmlElementName: "SiteConfigDefaultDocumentsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, netFrameworkVersion: {
                defaultValue: "v4.6",
                serializedName: "properties.netFrameworkVersion",
                xmlName: "properties.netFrameworkVersion",
                type: {
                    name: "String"
                }
            }, phpVersion: {
                serializedName: "properties.phpVersion",
                xmlName: "properties.phpVersion",
                type: {
                    name: "String"
                }
            }, pythonVersion: {
                serializedName: "properties.pythonVersion",
                xmlName: "properties.pythonVersion",
                type: {
                    name: "String"
                }
            }, nodeVersion: {
                serializedName: "properties.nodeVersion",
                xmlName: "properties.nodeVersion",
                type: {
                    name: "String"
                }
            }, powerShellVersion: {
                serializedName: "properties.powerShellVersion",
                xmlName: "properties.powerShellVersion",
                type: {
                    name: "String"
                }
            }, linuxFxVersion: {
                serializedName: "properties.linuxFxVersion",
                xmlName: "properties.linuxFxVersion",
                type: {
                    name: "String"
                }
            }, windowsFxVersion: {
                serializedName: "properties.windowsFxVersion",
                xmlName: "properties.windowsFxVersion",
                type: {
                    name: "String"
                }
            }, requestTracingEnabled: {
                serializedName: "properties.requestTracingEnabled",
                xmlName: "properties.requestTracingEnabled",
                type: {
                    name: "Boolean"
                }
            }, requestTracingExpirationTime: {
                serializedName: "properties.requestTracingExpirationTime",
                xmlName: "properties.requestTracingExpirationTime",
                type: {
                    name: "DateTime"
                }
            }, remoteDebuggingEnabled: {
                serializedName: "properties.remoteDebuggingEnabled",
                xmlName: "properties.remoteDebuggingEnabled",
                type: {
                    name: "Boolean"
                }
            }, remoteDebuggingVersion: {
                serializedName: "properties.remoteDebuggingVersion",
                xmlName: "properties.remoteDebuggingVersion",
                type: {
                    name: "String"
                }
            }, httpLoggingEnabled: {
                serializedName: "properties.httpLoggingEnabled",
                xmlName: "properties.httpLoggingEnabled",
                type: {
                    name: "Boolean"
                }
            }, acrUseManagedIdentityCreds: {
                serializedName: "properties.acrUseManagedIdentityCreds",
                xmlName: "properties.acrUseManagedIdentityCreds",
                type: {
                    name: "Boolean"
                }
            }, acrUserManagedIdentityID: {
                serializedName: "properties.acrUserManagedIdentityID",
                xmlName: "properties.acrUserManagedIdentityID",
                type: {
                    name: "String"
                }
            }, logsDirectorySizeLimit: {
                serializedName: "properties.logsDirectorySizeLimit",
                xmlName: "properties.logsDirectorySizeLimit",
                type: {
                    name: "Number"
                }
            }, detailedErrorLoggingEnabled: {
                serializedName: "properties.detailedErrorLoggingEnabled",
                xmlName: "properties.detailedErrorLoggingEnabled",
                type: {
                    name: "Boolean"
                }
            }, publishingUsername: {
                serializedName: "properties.publishingUsername",
                xmlName: "properties.publishingUsername",
                type: {
                    name: "String"
                }
            }, appSettings: {
                serializedName: "properties.appSettings",
                xmlName: "properties.appSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair"
                        }
                    }
                }
            }, connectionStrings: {
                serializedName: "properties.connectionStrings",
                xmlName: "properties.connectionStrings",
                xmlElementName: "ConnStringInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnStringInfo"
                        }
                    }
                }
            }, machineKey: {
                serializedName: "properties.machineKey",
                xmlName: "properties.machineKey",
                type: {
                    name: "Composite",
                    className: "SiteMachineKey"
                }
            }, handlerMappings: {
                serializedName: "properties.handlerMappings",
                xmlName: "properties.handlerMappings",
                xmlElementName: "HandlerMapping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandlerMapping"
                        }
                    }
                }
            }, documentRoot: {
                serializedName: "properties.documentRoot",
                xmlName: "properties.documentRoot",
                type: {
                    name: "String"
                }
            }, scmType: {
                serializedName: "properties.scmType",
                xmlName: "properties.scmType",
                type: {
                    name: "String"
                }
            }, use32BitWorkerProcess: {
                serializedName: "properties.use32BitWorkerProcess",
                xmlName: "properties.use32BitWorkerProcess",
                type: {
                    name: "Boolean"
                }
            }, webSocketsEnabled: {
                serializedName: "properties.webSocketsEnabled",
                xmlName: "properties.webSocketsEnabled",
                type: {
                    name: "Boolean"
                }
            }, alwaysOn: {
                serializedName: "properties.alwaysOn",
                xmlName: "properties.alwaysOn",
                type: {
                    name: "Boolean"
                }
            }, javaVersion: {
                serializedName: "properties.javaVersion",
                xmlName: "properties.javaVersion",
                type: {
                    name: "String"
                }
            }, javaContainer: {
                serializedName: "properties.javaContainer",
                xmlName: "properties.javaContainer",
                type: {
                    name: "String"
                }
            }, javaContainerVersion: {
                serializedName: "properties.javaContainerVersion",
                xmlName: "properties.javaContainerVersion",
                type: {
                    name: "String"
                }
            }, appCommandLine: {
                serializedName: "properties.appCommandLine",
                xmlName: "properties.appCommandLine",
                type: {
                    name: "String"
                }
            }, managedPipelineMode: {
                serializedName: "properties.managedPipelineMode",
                xmlName: "properties.managedPipelineMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Integrated", "Classic"]
                }
            }, virtualApplications: {
                serializedName: "properties.virtualApplications",
                xmlName: "properties.virtualApplications",
                xmlElementName: "VirtualApplication",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplication"
                        }
                    }
                }
            }, loadBalancing: {
                serializedName: "properties.loadBalancing",
                xmlName: "properties.loadBalancing",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "WeightedRoundRobin",
                        "LeastRequests",
                        "LeastResponseTime",
                        "WeightedTotalTraffic",
                        "RequestHash",
                        "PerSiteRoundRobin"
                    ]
                }
            }, experiments: {
                serializedName: "properties.experiments",
                xmlName: "properties.experiments",
                type: {
                    name: "Composite",
                    className: "Experiments"
                }
            }, limits: {
                serializedName: "properties.limits",
                xmlName: "properties.limits",
                type: {
                    name: "Composite",
                    className: "SiteLimits"
                }
            }, autoHealEnabled: {
                serializedName: "properties.autoHealEnabled",
                xmlName: "properties.autoHealEnabled",
                type: {
                    name: "Boolean"
                }
            }, autoHealRules: {
                serializedName: "properties.autoHealRules",
                xmlName: "properties.autoHealRules",
                type: {
                    name: "Composite",
                    className: "AutoHealRules"
                }
            }, tracingOptions: {
                serializedName: "properties.tracingOptions",
                xmlName: "properties.tracingOptions",
                type: {
                    name: "String"
                }
            }, vnetName: {
                serializedName: "properties.vnetName",
                xmlName: "properties.vnetName",
                type: {
                    name: "String"
                }
            }, vnetRouteAllEnabled: {
                serializedName: "properties.vnetRouteAllEnabled",
                xmlName: "properties.vnetRouteAllEnabled",
                type: {
                    name: "Boolean"
                }
            }, vnetPrivatePortsCount: {
                serializedName: "properties.vnetPrivatePortsCount",
                xmlName: "properties.vnetPrivatePortsCount",
                type: {
                    name: "Number"
                }
            }, cors: {
                serializedName: "properties.cors",
                xmlName: "properties.cors",
                type: {
                    name: "Composite",
                    className: "CorsSettings"
                }
            }, push: {
                serializedName: "properties.push",
                xmlName: "properties.push",
                type: {
                    name: "Composite",
                    className: "PushSettings"
                }
            }, apiDefinition: {
                serializedName: "properties.apiDefinition",
                xmlName: "properties.apiDefinition",
                type: {
                    name: "Composite",
                    className: "ApiDefinitionInfo"
                }
            }, apiManagementConfig: {
                serializedName: "properties.apiManagementConfig",
                xmlName: "properties.apiManagementConfig",
                type: {
                    name: "Composite",
                    className: "ApiManagementConfig"
                }
            }, autoSwapSlotName: {
                serializedName: "properties.autoSwapSlotName",
                xmlName: "properties.autoSwapSlotName",
                type: {
                    name: "String"
                }
            }, localMySqlEnabled: {
                defaultValue: false,
                serializedName: "properties.localMySqlEnabled",
                xmlName: "properties.localMySqlEnabled",
                type: {
                    name: "Boolean"
                }
            }, managedServiceIdentityId: {
                serializedName: "properties.managedServiceIdentityId",
                xmlName: "properties.managedServiceIdentityId",
                type: {
                    name: "Number"
                }
            }, xManagedServiceIdentityId: {
                serializedName: "properties.xManagedServiceIdentityId",
                xmlName: "properties.xManagedServiceIdentityId",
                type: {
                    name: "Number"
                }
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String"
                }
            }, ipSecurityRestrictions: {
                serializedName: "properties.ipSecurityRestrictions",
                xmlName: "properties.ipSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction"
                        }
                    }
                }
            }, scmIpSecurityRestrictions: {
                serializedName: "properties.scmIpSecurityRestrictions",
                xmlName: "properties.scmIpSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction"
                        }
                    }
                }
            }, scmIpSecurityRestrictionsUseMain: {
                serializedName: "properties.scmIpSecurityRestrictionsUseMain",
                xmlName: "properties.scmIpSecurityRestrictionsUseMain",
                type: {
                    name: "Boolean"
                }
            }, http20Enabled: {
                defaultValue: true,
                serializedName: "properties.http20Enabled",
                xmlName: "properties.http20Enabled",
                type: {
                    name: "Boolean"
                }
            }, minTlsVersion: {
                serializedName: "properties.minTlsVersion",
                xmlName: "properties.minTlsVersion",
                type: {
                    name: "String"
                }
            }, scmMinTlsVersion: {
                serializedName: "properties.scmMinTlsVersion",
                xmlName: "properties.scmMinTlsVersion",
                type: {
                    name: "String"
                }
            }, ftpsState: {
                serializedName: "properties.ftpsState",
                xmlName: "properties.ftpsState",
                type: {
                    name: "String"
                }
            }, preWarmedInstanceCount: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.preWarmedInstanceCount",
                xmlName: "properties.preWarmedInstanceCount",
                type: {
                    name: "Number"
                }
            }, functionAppScaleLimit: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.functionAppScaleLimit",
                xmlName: "properties.functionAppScaleLimit",
                type: {
                    name: "Number"
                }
            }, healthCheckPath: {
                serializedName: "properties.healthCheckPath",
                xmlName: "properties.healthCheckPath",
                type: {
                    name: "String"
                }
            }, functionsRuntimeScaleMonitoringEnabled: {
                serializedName: "properties.functionsRuntimeScaleMonitoringEnabled",
                xmlName: "properties.functionsRuntimeScaleMonitoringEnabled",
                type: {
                    name: "Boolean"
                }
            }, websiteTimeZone: {
                serializedName: "properties.websiteTimeZone",
                xmlName: "properties.websiteTimeZone",
                type: {
                    name: "String"
                }
            }, minimumElasticInstanceCount: {
                constraints: {
                    InclusiveMaximum: 20,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.minimumElasticInstanceCount",
                xmlName: "properties.minimumElasticInstanceCount",
                type: {
                    name: "Number"
                }
            }, azureStorageAccounts: {
                serializedName: "properties.azureStorageAccounts",
                xmlName: "properties.azureStorageAccounts",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AzureStorageInfoValue" }
                    }
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            } })
    }
};
const SiteAuthSettings = {
    serializedName: "SiteAuthSettings",
    type: {
        name: "Composite",
        className: "SiteAuthSettings",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, runtimeVersion: {
                serializedName: "properties.runtimeVersion",
                xmlName: "properties.runtimeVersion",
                type: {
                    name: "String"
                }
            }, unauthenticatedClientAction: {
                serializedName: "properties.unauthenticatedClientAction",
                xmlName: "properties.unauthenticatedClientAction",
                type: {
                    name: "Enum",
                    allowedValues: ["RedirectToLoginPage", "AllowAnonymous"]
                }
            }, tokenStoreEnabled: {
                serializedName: "properties.tokenStoreEnabled",
                xmlName: "properties.tokenStoreEnabled",
                type: {
                    name: "Boolean"
                }
            }, allowedExternalRedirectUrls: {
                serializedName: "properties.allowedExternalRedirectUrls",
                xmlName: "properties.allowedExternalRedirectUrls",
                xmlElementName: "SiteAuthSettingsPropertiesAllowedExternalRedirectUrlsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, defaultProvider: {
                serializedName: "properties.defaultProvider",
                xmlName: "properties.defaultProvider",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "AzureActiveDirectory",
                        "Facebook",
                        "Google",
                        "MicrosoftAccount",
                        "Twitter",
                        "Github"
                    ]
                }
            }, tokenRefreshExtensionHours: {
                serializedName: "properties.tokenRefreshExtensionHours",
                xmlName: "properties.tokenRefreshExtensionHours",
                type: {
                    name: "Number"
                }
            }, clientId: {
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            }, clientSecretSettingName: {
                serializedName: "properties.clientSecretSettingName",
                xmlName: "properties.clientSecretSettingName",
                type: {
                    name: "String"
                }
            }, clientSecretCertificateThumbprint: {
                serializedName: "properties.clientSecretCertificateThumbprint",
                xmlName: "properties.clientSecretCertificateThumbprint",
                type: {
                    name: "String"
                }
            }, issuer: {
                serializedName: "properties.issuer",
                xmlName: "properties.issuer",
                type: {
                    name: "String"
                }
            }, validateIssuer: {
                serializedName: "properties.validateIssuer",
                xmlName: "properties.validateIssuer",
                type: {
                    name: "Boolean"
                }
            }, allowedAudiences: {
                serializedName: "properties.allowedAudiences",
                xmlName: "properties.allowedAudiences",
                xmlElementName: "SiteAuthSettingsPropertiesAllowedAudiencesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, additionalLoginParams: {
                serializedName: "properties.additionalLoginParams",
                xmlName: "properties.additionalLoginParams",
                xmlElementName: "SiteAuthSettingsPropertiesAdditionalLoginParamsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, aadClaimsAuthorization: {
                serializedName: "properties.aadClaimsAuthorization",
                xmlName: "properties.aadClaimsAuthorization",
                type: {
                    name: "String"
                }
            }, googleClientId: {
                serializedName: "properties.googleClientId",
                xmlName: "properties.googleClientId",
                type: {
                    name: "String"
                }
            }, googleClientSecret: {
                serializedName: "properties.googleClientSecret",
                xmlName: "properties.googleClientSecret",
                type: {
                    name: "String"
                }
            }, googleClientSecretSettingName: {
                serializedName: "properties.googleClientSecretSettingName",
                xmlName: "properties.googleClientSecretSettingName",
                type: {
                    name: "String"
                }
            }, googleOAuthScopes: {
                serializedName: "properties.googleOAuthScopes",
                xmlName: "properties.googleOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesGoogleOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, facebookAppId: {
                serializedName: "properties.facebookAppId",
                xmlName: "properties.facebookAppId",
                type: {
                    name: "String"
                }
            }, facebookAppSecret: {
                serializedName: "properties.facebookAppSecret",
                xmlName: "properties.facebookAppSecret",
                type: {
                    name: "String"
                }
            }, facebookAppSecretSettingName: {
                serializedName: "properties.facebookAppSecretSettingName",
                xmlName: "properties.facebookAppSecretSettingName",
                type: {
                    name: "String"
                }
            }, facebookOAuthScopes: {
                serializedName: "properties.facebookOAuthScopes",
                xmlName: "properties.facebookOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesFacebookOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, gitHubClientId: {
                serializedName: "properties.gitHubClientId",
                xmlName: "properties.gitHubClientId",
                type: {
                    name: "String"
                }
            }, gitHubClientSecret: {
                serializedName: "properties.gitHubClientSecret",
                xmlName: "properties.gitHubClientSecret",
                type: {
                    name: "String"
                }
            }, gitHubClientSecretSettingName: {
                serializedName: "properties.gitHubClientSecretSettingName",
                xmlName: "properties.gitHubClientSecretSettingName",
                type: {
                    name: "String"
                }
            }, gitHubOAuthScopes: {
                serializedName: "properties.gitHubOAuthScopes",
                xmlName: "properties.gitHubOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesGitHubOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, twitterConsumerKey: {
                serializedName: "properties.twitterConsumerKey",
                xmlName: "properties.twitterConsumerKey",
                type: {
                    name: "String"
                }
            }, twitterConsumerSecret: {
                serializedName: "properties.twitterConsumerSecret",
                xmlName: "properties.twitterConsumerSecret",
                type: {
                    name: "String"
                }
            }, twitterConsumerSecretSettingName: {
                serializedName: "properties.twitterConsumerSecretSettingName",
                xmlName: "properties.twitterConsumerSecretSettingName",
                type: {
                    name: "String"
                }
            }, microsoftAccountClientId: {
                serializedName: "properties.microsoftAccountClientId",
                xmlName: "properties.microsoftAccountClientId",
                type: {
                    name: "String"
                }
            }, microsoftAccountClientSecret: {
                serializedName: "properties.microsoftAccountClientSecret",
                xmlName: "properties.microsoftAccountClientSecret",
                type: {
                    name: "String"
                }
            }, microsoftAccountClientSecretSettingName: {
                serializedName: "properties.microsoftAccountClientSecretSettingName",
                xmlName: "properties.microsoftAccountClientSecretSettingName",
                type: {
                    name: "String"
                }
            }, microsoftAccountOAuthScopes: {
                serializedName: "properties.microsoftAccountOAuthScopes",
                xmlName: "properties.microsoftAccountOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesMicrosoftAccountOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isAuthFromFile: {
                serializedName: "properties.isAuthFromFile",
                xmlName: "properties.isAuthFromFile",
                type: {
                    name: "String"
                }
            }, authFilePath: {
                serializedName: "properties.authFilePath",
                xmlName: "properties.authFilePath",
                type: {
                    name: "String"
                }
            }, configVersion: {
                serializedName: "properties.configVersion",
                xmlName: "properties.configVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const SiteAuthSettingsV2 = {
    serializedName: "SiteAuthSettingsV2",
    type: {
        name: "Composite",
        className: "SiteAuthSettingsV2",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { platform: {
                serializedName: "properties.platform",
                xmlName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "AuthPlatform"
                }
            }, globalValidation: {
                serializedName: "properties.globalValidation",
                xmlName: "properties.globalValidation",
                type: {
                    name: "Composite",
                    className: "GlobalValidation"
                }
            }, identityProviders: {
                serializedName: "properties.identityProviders",
                xmlName: "properties.identityProviders",
                type: {
                    name: "Composite",
                    className: "IdentityProviders"
                }
            }, login: {
                serializedName: "properties.login",
                xmlName: "properties.login",
                type: {
                    name: "Composite",
                    className: "Login"
                }
            }, httpSettings: {
                serializedName: "properties.httpSettings",
                xmlName: "properties.httpSettings",
                type: {
                    name: "Composite",
                    className: "HttpSettings"
                }
            } })
    }
};
const AzureStoragePropertyDictionaryResource = {
    serializedName: "AzureStoragePropertyDictionaryResource",
    type: {
        name: "Composite",
        className: "AzureStoragePropertyDictionaryResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AzureStorageInfoValue" }
                    }
                }
            } })
    }
};
const ApiKVReference = {
    serializedName: "ApiKVReference",
    type: {
        name: "Composite",
        className: "ApiKVReference",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { reference: {
                serializedName: "properties.reference",
                xmlName: "properties.reference",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "Resolved",
                        "InvalidSyntax",
                        "MSINotEnabled",
                        "VaultNotFound",
                        "SecretNotFound",
                        "SecretVersionNotFound",
                        "AccessToKeyVaultDenied",
                        "OtherReasons",
                        "FetchTimedOut",
                        "UnauthorizedClient"
                    ]
                }
            }, vaultName: {
                serializedName: "properties.vaultName",
                xmlName: "properties.vaultName",
                type: {
                    name: "String"
                }
            }, secretName: {
                serializedName: "properties.secretName",
                xmlName: "properties.secretName",
                type: {
                    name: "String"
                }
            }, secretVersion: {
                serializedName: "properties.secretVersion",
                xmlName: "properties.secretVersion",
                type: {
                    name: "String"
                }
            }, identityType: {
                serializedName: "properties.identityType",
                xmlName: "properties.identityType",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, details: {
                serializedName: "properties.details",
                xmlName: "properties.details",
                type: {
                    name: "String"
                }
            }, source: {
                defaultValue: "KeyVault",
                isConstant: true,
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            }, activeVersion: {
                serializedName: "properties.activeVersion",
                xmlName: "properties.activeVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectionStringDictionary = {
    serializedName: "ConnectionStringDictionary",
    type: {
        name: "Composite",
        className: "ConnectionStringDictionary",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ConnStringValueTypePair" }
                    }
                }
            } })
    }
};
const SiteLogsConfig = {
    serializedName: "SiteLogsConfig",
    type: {
        name: "Composite",
        className: "SiteLogsConfig",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { applicationLogs: {
                serializedName: "properties.applicationLogs",
                xmlName: "properties.applicationLogs",
                type: {
                    name: "Composite",
                    className: "ApplicationLogsConfig"
                }
            }, httpLogs: {
                serializedName: "properties.httpLogs",
                xmlName: "properties.httpLogs",
                type: {
                    name: "Composite",
                    className: "HttpLogsConfig"
                }
            }, failedRequestsTracing: {
                serializedName: "properties.failedRequestsTracing",
                xmlName: "properties.failedRequestsTracing",
                type: {
                    name: "Composite",
                    className: "EnabledConfig"
                }
            }, detailedErrorMessages: {
                serializedName: "properties.detailedErrorMessages",
                xmlName: "properties.detailedErrorMessages",
                type: {
                    name: "Composite",
                    className: "EnabledConfig"
                }
            } })
    }
};
const SlotConfigNamesResource = {
    serializedName: "SlotConfigNamesResource",
    type: {
        name: "Composite",
        className: "SlotConfigNamesResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { connectionStringNames: {
                serializedName: "properties.connectionStringNames",
                xmlName: "properties.connectionStringNames",
                xmlElementName: "SlotConfigNamesConnectionStringNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, appSettingNames: {
                serializedName: "properties.appSettingNames",
                xmlName: "properties.appSettingNames",
                xmlElementName: "SlotConfigNamesAppSettingNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, azureStorageConfigNames: {
                serializedName: "properties.azureStorageConfigNames",
                xmlName: "properties.azureStorageConfigNames",
                xmlElementName: "SlotConfigNamesAzureStorageConfigNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SiteConfigurationSnapshotInfo = {
    serializedName: "SiteConfigurationSnapshotInfo",
    type: {
        name: "Composite",
        className: "SiteConfigurationSnapshotInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { time: {
                serializedName: "properties.time",
                readOnly: true,
                xmlName: "properties.time",
                type: {
                    name: "DateTime"
                }
            }, snapshotId: {
                serializedName: "properties.snapshotId",
                readOnly: true,
                xmlName: "properties.snapshotId",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ContinuousWebJob = {
    serializedName: "ContinuousWebJob",
    type: {
        name: "Composite",
        className: "ContinuousWebJob",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initializing",
                        "Starting",
                        "Running",
                        "PendingRestart",
                        "Stopped"
                    ]
                }
            }, detailedStatus: {
                serializedName: "properties.detailed_status",
                xmlName: "properties.detailed_status",
                type: {
                    name: "String"
                }
            }, logUrl: {
                serializedName: "properties.log_url",
                xmlName: "properties.log_url",
                type: {
                    name: "String"
                }
            }, runCommand: {
                serializedName: "properties.run_command",
                xmlName: "properties.run_command",
                type: {
                    name: "String"
                }
            }, url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            }, extraInfoUrl: {
                serializedName: "properties.extra_info_url",
                xmlName: "properties.extra_info_url",
                type: {
                    name: "String"
                }
            }, webJobType: {
                serializedName: "properties.web_job_type",
                xmlName: "properties.web_job_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Continuous", "Triggered"]
                }
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "String"
                }
            }, usingSdk: {
                serializedName: "properties.using_sdk",
                xmlName: "properties.using_sdk",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            } })
    }
};
const CsmDeploymentStatus = {
    serializedName: "CsmDeploymentStatus",
    type: {
        name: "Composite",
        className: "CsmDeploymentStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deploymentId: {
                serializedName: "properties.deploymentId",
                xmlName: "properties.deploymentId",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, numberOfInstancesInProgress: {
                serializedName: "properties.numberOfInstancesInProgress",
                xmlName: "properties.numberOfInstancesInProgress",
                type: {
                    name: "Number"
                }
            }, numberOfInstancesSuccessful: {
                serializedName: "properties.numberOfInstancesSuccessful",
                xmlName: "properties.numberOfInstancesSuccessful",
                type: {
                    name: "Number"
                }
            }, numberOfInstancesFailed: {
                serializedName: "properties.numberOfInstancesFailed",
                xmlName: "properties.numberOfInstancesFailed",
                type: {
                    name: "Number"
                }
            }, failedInstancesLogs: {
                serializedName: "properties.failedInstancesLogs",
                xmlName: "properties.failedInstancesLogs",
                xmlElementName: "CsmDeploymentStatusPropertiesFailedInstancesLogsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, errors: {
                serializedName: "properties.errors",
                xmlName: "properties.errors",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity"
                        }
                    }
                }
            } })
    }
};
const Deployment = {
    serializedName: "Deployment",
    type: {
        name: "Composite",
        className: "Deployment",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Number"
                }
            }, message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String"
                }
            }, author: {
                serializedName: "properties.author",
                xmlName: "properties.author",
                type: {
                    name: "String"
                }
            }, deployer: {
                serializedName: "properties.deployer",
                xmlName: "properties.deployer",
                type: {
                    name: "String"
                }
            }, authorEmail: {
                serializedName: "properties.author_email",
                xmlName: "properties.author_email",
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.start_time",
                xmlName: "properties.start_time",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.end_time",
                xmlName: "properties.end_time",
                type: {
                    name: "DateTime"
                }
            }, active: {
                serializedName: "properties.active",
                xmlName: "properties.active",
                type: {
                    name: "Boolean"
                }
            }, details: {
                serializedName: "properties.details",
                xmlName: "properties.details",
                type: {
                    name: "String"
                }
            } })
    }
};
const MSDeployStatus = {
    serializedName: "MSDeployStatus",
    type: {
        name: "Composite",
        className: "MSDeployStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deployer: {
                serializedName: "properties.deployer",
                readOnly: true,
                xmlName: "properties.deployer",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "accepted",
                        "running",
                        "succeeded",
                        "failed",
                        "canceled"
                    ]
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, complete: {
                serializedName: "properties.complete",
                readOnly: true,
                xmlName: "properties.complete",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const MSDeploy = {
    serializedName: "MSDeploy",
    type: {
        name: "Composite",
        className: "MSDeploy",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { packageUri: {
                serializedName: "properties.packageUri",
                xmlName: "properties.packageUri",
                type: {
                    name: "String"
                }
            }, connectionString: {
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String"
                }
            }, dbType: {
                serializedName: "properties.dbType",
                xmlName: "properties.dbType",
                type: {
                    name: "String"
                }
            }, setParametersXmlFileUri: {
                serializedName: "properties.setParametersXmlFileUri",
                xmlName: "properties.setParametersXmlFileUri",
                type: {
                    name: "String"
                }
            }, setParameters: {
                serializedName: "properties.setParameters",
                xmlName: "properties.setParameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, skipAppData: {
                serializedName: "properties.skipAppData",
                xmlName: "properties.skipAppData",
                type: {
                    name: "Boolean"
                }
            }, appOffline: {
                serializedName: "properties.appOffline",
                xmlName: "properties.appOffline",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const MSDeployLog = {
    serializedName: "MSDeployLog",
    type: {
        name: "Composite",
        className: "MSDeployLog",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { entries: {
                serializedName: "properties.entries",
                readOnly: true,
                xmlName: "properties.entries",
                xmlElementName: "MSDeployLogEntry",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MSDeployLogEntry"
                        }
                    }
                }
            } })
    }
};
const FunctionEnvelope = {
    serializedName: "FunctionEnvelope",
    type: {
        name: "Composite",
        className: "FunctionEnvelope",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionAppId: {
                serializedName: "properties.function_app_id",
                xmlName: "properties.function_app_id",
                type: {
                    name: "String"
                }
            }, scriptRootPathHref: {
                serializedName: "properties.script_root_path_href",
                xmlName: "properties.script_root_path_href",
                type: {
                    name: "String"
                }
            }, scriptHref: {
                serializedName: "properties.script_href",
                xmlName: "properties.script_href",
                type: {
                    name: "String"
                }
            }, configHref: {
                serializedName: "properties.config_href",
                xmlName: "properties.config_href",
                type: {
                    name: "String"
                }
            }, testDataHref: {
                serializedName: "properties.test_data_href",
                xmlName: "properties.test_data_href",
                type: {
                    name: "String"
                }
            }, secretsFileHref: {
                serializedName: "properties.secrets_file_href",
                xmlName: "properties.secrets_file_href",
                type: {
                    name: "String"
                }
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String"
                }
            }, config: {
                serializedName: "properties.config",
                xmlName: "properties.config",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, files: {
                serializedName: "properties.files",
                xmlName: "properties.files",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, testData: {
                serializedName: "properties.test_data",
                xmlName: "properties.test_data",
                type: {
                    name: "String"
                }
            }, invokeUrlTemplate: {
                serializedName: "properties.invoke_url_template",
                xmlName: "properties.invoke_url_template",
                type: {
                    name: "String"
                }
            }, language: {
                serializedName: "properties.language",
                xmlName: "properties.language",
                type: {
                    name: "String"
                }
            }, isDisabled: {
                serializedName: "properties.isDisabled",
                xmlName: "properties.isDisabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const HostNameBinding = {
    serializedName: "HostNameBinding",
    type: {
        name: "Composite",
        className: "HostNameBinding",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { siteName: {
                serializedName: "properties.siteName",
                xmlName: "properties.siteName",
                type: {
                    name: "String"
                }
            }, domainId: {
                serializedName: "properties.domainId",
                xmlName: "properties.domainId",
                type: {
                    name: "String"
                }
            }, azureResourceName: {
                serializedName: "properties.azureResourceName",
                xmlName: "properties.azureResourceName",
                type: {
                    name: "String"
                }
            }, azureResourceType: {
                serializedName: "properties.azureResourceType",
                xmlName: "properties.azureResourceType",
                type: {
                    name: "Enum",
                    allowedValues: ["Website", "TrafficManager"]
                }
            }, customHostNameDnsRecordType: {
                serializedName: "properties.customHostNameDnsRecordType",
                xmlName: "properties.customHostNameDnsRecordType",
                type: {
                    name: "Enum",
                    allowedValues: ["CName", "A"]
                }
            }, hostNameType: {
                serializedName: "properties.hostNameType",
                xmlName: "properties.hostNameType",
                type: {
                    name: "Enum",
                    allowedValues: ["Verified", "Managed"]
                }
            }, sslState: {
                serializedName: "properties.sslState",
                xmlName: "properties.sslState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "SniEnabled", "IpBasedEnabled"]
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                xmlName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, virtualIP: {
                serializedName: "properties.virtualIP",
                readOnly: true,
                xmlName: "properties.virtualIP",
                type: {
                    name: "String"
                }
            } })
    }
};
const RelayServiceConnectionEntity = {
    serializedName: "RelayServiceConnectionEntity",
    type: {
        name: "Composite",
        className: "RelayServiceConnectionEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { entityName: {
                serializedName: "properties.entityName",
                xmlName: "properties.entityName",
                type: {
                    name: "String"
                }
            }, entityConnectionString: {
                serializedName: "properties.entityConnectionString",
                xmlName: "properties.entityConnectionString",
                type: {
                    name: "String"
                }
            }, resourceType: {
                serializedName: "properties.resourceType",
                xmlName: "properties.resourceType",
                type: {
                    name: "String"
                }
            }, resourceConnectionString: {
                serializedName: "properties.resourceConnectionString",
                xmlName: "properties.resourceConnectionString",
                type: {
                    name: "String"
                }
            }, hostname: {
                serializedName: "properties.hostname",
                xmlName: "properties.hostname",
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                xmlName: "properties.port",
                type: {
                    name: "Number"
                }
            }, biztalkUri: {
                serializedName: "properties.biztalkUri",
                xmlName: "properties.biztalkUri",
                type: {
                    name: "String"
                }
            } })
    }
};
const WebSiteInstanceStatus = {
    serializedName: "WebSiteInstanceStatus",
    type: {
        name: "Composite",
        className: "WebSiteInstanceStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["READY", "STOPPED", "UNKNOWN"]
                }
            }, statusUrl: {
                serializedName: "properties.statusUrl",
                xmlName: "properties.statusUrl",
                type: {
                    name: "String"
                }
            }, detectorUrl: {
                serializedName: "properties.detectorUrl",
                xmlName: "properties.detectorUrl",
                type: {
                    name: "String"
                }
            }, consoleUrl: {
                serializedName: "properties.consoleUrl",
                xmlName: "properties.consoleUrl",
                type: {
                    name: "String"
                }
            }, healthCheckUrl: {
                serializedName: "properties.healthCheckUrl",
                xmlName: "properties.healthCheckUrl",
                type: {
                    name: "String"
                }
            }, containers: {
                serializedName: "properties.containers",
                xmlName: "properties.containers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "ContainerInfo" } }
                }
            } })
    }
};
const ProcessThreadInfo = {
    serializedName: "ProcessThreadInfo",
    type: {
        name: "Composite",
        className: "ProcessThreadInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { identifier: {
                serializedName: "properties.identifier",
                readOnly: true,
                xmlName: "properties.identifier",
                type: {
                    name: "Number"
                }
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String"
                }
            }, process: {
                serializedName: "properties.process",
                xmlName: "properties.process",
                type: {
                    name: "String"
                }
            }, startAddress: {
                serializedName: "properties.start_address",
                xmlName: "properties.start_address",
                type: {
                    name: "String"
                }
            }, currentPriority: {
                serializedName: "properties.current_priority",
                xmlName: "properties.current_priority",
                type: {
                    name: "Number"
                }
            }, priorityLevel: {
                serializedName: "properties.priority_level",
                xmlName: "properties.priority_level",
                type: {
                    name: "String"
                }
            }, basePriority: {
                serializedName: "properties.base_priority",
                xmlName: "properties.base_priority",
                type: {
                    name: "Number"
                }
            }, startTime: {
                serializedName: "properties.start_time",
                xmlName: "properties.start_time",
                type: {
                    name: "DateTime"
                }
            }, totalProcessorTime: {
                serializedName: "properties.total_processor_time",
                xmlName: "properties.total_processor_time",
                type: {
                    name: "String"
                }
            }, userProcessorTime: {
                serializedName: "properties.user_processor_time",
                xmlName: "properties.user_processor_time",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, waitReason: {
                serializedName: "properties.wait_reason",
                xmlName: "properties.wait_reason",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProcessModuleInfo = {
    serializedName: "ProcessModuleInfo",
    type: {
        name: "Composite",
        className: "ProcessModuleInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { baseAddress: {
                serializedName: "properties.base_address",
                xmlName: "properties.base_address",
                type: {
                    name: "String"
                }
            }, fileName: {
                serializedName: "properties.file_name",
                xmlName: "properties.file_name",
                type: {
                    name: "String"
                }
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String"
                }
            }, filePath: {
                serializedName: "properties.file_path",
                xmlName: "properties.file_path",
                type: {
                    name: "String"
                }
            }, moduleMemorySize: {
                serializedName: "properties.module_memory_size",
                xmlName: "properties.module_memory_size",
                type: {
                    name: "Number"
                }
            }, fileVersion: {
                serializedName: "properties.file_version",
                xmlName: "properties.file_version",
                type: {
                    name: "String"
                }
            }, fileDescription: {
                serializedName: "properties.file_description",
                xmlName: "properties.file_description",
                type: {
                    name: "String"
                }
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String"
                }
            }, productVersion: {
                serializedName: "properties.product_version",
                xmlName: "properties.product_version",
                type: {
                    name: "String"
                }
            }, isDebug: {
                serializedName: "properties.is_debug",
                xmlName: "properties.is_debug",
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "properties.language",
                xmlName: "properties.language",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProcessInfo = {
    serializedName: "ProcessInfo",
    type: {
        name: "Composite",
        className: "ProcessInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { identifier: {
                serializedName: "properties.identifier",
                readOnly: true,
                xmlName: "properties.identifier",
                type: {
                    name: "Number"
                }
            }, deploymentName: {
                serializedName: "properties.deployment_name",
                xmlName: "properties.deployment_name",
                type: {
                    name: "String"
                }
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String"
                }
            }, minidump: {
                serializedName: "properties.minidump",
                xmlName: "properties.minidump",
                type: {
                    name: "String"
                }
            }, isProfileRunning: {
                serializedName: "properties.is_profile_running",
                xmlName: "properties.is_profile_running",
                type: {
                    name: "Boolean"
                }
            }, isIisProfileRunning: {
                serializedName: "properties.is_iis_profile_running",
                xmlName: "properties.is_iis_profile_running",
                type: {
                    name: "Boolean"
                }
            }, iisProfileTimeoutInSeconds: {
                serializedName: "properties.iis_profile_timeout_in_seconds",
                xmlName: "properties.iis_profile_timeout_in_seconds",
                type: {
                    name: "Number"
                }
            }, parent: {
                serializedName: "properties.parent",
                xmlName: "properties.parent",
                type: {
                    name: "String"
                }
            }, children: {
                serializedName: "properties.children",
                xmlName: "properties.children",
                xmlElementName: "ProcessInfoPropertiesChildrenItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, threads: {
                serializedName: "properties.threads",
                xmlName: "properties.threads",
                xmlElementName: "ProcessThreadInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessThreadInfo"
                        }
                    }
                }
            }, openFileHandles: {
                serializedName: "properties.open_file_handles",
                xmlName: "properties.open_file_handles",
                xmlElementName: "ProcessInfoPropertiesOpenFileHandlesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, modules: {
                serializedName: "properties.modules",
                xmlName: "properties.modules",
                xmlElementName: "ProcessModuleInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessModuleInfo"
                        }
                    }
                }
            }, fileName: {
                serializedName: "properties.file_name",
                xmlName: "properties.file_name",
                type: {
                    name: "String"
                }
            }, commandLine: {
                serializedName: "properties.command_line",
                xmlName: "properties.command_line",
                type: {
                    name: "String"
                }
            }, userName: {
                serializedName: "properties.user_name",
                xmlName: "properties.user_name",
                type: {
                    name: "String"
                }
            }, handleCount: {
                serializedName: "properties.handle_count",
                xmlName: "properties.handle_count",
                type: {
                    name: "Number"
                }
            }, moduleCount: {
                serializedName: "properties.module_count",
                xmlName: "properties.module_count",
                type: {
                    name: "Number"
                }
            }, threadCount: {
                serializedName: "properties.thread_count",
                xmlName: "properties.thread_count",
                type: {
                    name: "Number"
                }
            }, startTime: {
                serializedName: "properties.start_time",
                xmlName: "properties.start_time",
                type: {
                    name: "DateTime"
                }
            }, totalCpuTime: {
                serializedName: "properties.total_cpu_time",
                xmlName: "properties.total_cpu_time",
                type: {
                    name: "String"
                }
            }, userCpuTime: {
                serializedName: "properties.user_cpu_time",
                xmlName: "properties.user_cpu_time",
                type: {
                    name: "String"
                }
            }, privilegedCpuTime: {
                serializedName: "properties.privileged_cpu_time",
                xmlName: "properties.privileged_cpu_time",
                type: {
                    name: "String"
                }
            }, workingSet: {
                serializedName: "properties.working_set",
                xmlName: "properties.working_set",
                type: {
                    name: "Number"
                }
            }, peakWorkingSet: {
                serializedName: "properties.peak_working_set",
                xmlName: "properties.peak_working_set",
                type: {
                    name: "Number"
                }
            }, privateMemory: {
                serializedName: "properties.private_memory",
                xmlName: "properties.private_memory",
                type: {
                    name: "Number"
                }
            }, virtualMemory: {
                serializedName: "properties.virtual_memory",
                xmlName: "properties.virtual_memory",
                type: {
                    name: "Number"
                }
            }, peakVirtualMemory: {
                serializedName: "properties.peak_virtual_memory",
                xmlName: "properties.peak_virtual_memory",
                type: {
                    name: "Number"
                }
            }, pagedSystemMemory: {
                serializedName: "properties.paged_system_memory",
                xmlName: "properties.paged_system_memory",
                type: {
                    name: "Number"
                }
            }, nonPagedSystemMemory: {
                serializedName: "properties.non_paged_system_memory",
                xmlName: "properties.non_paged_system_memory",
                type: {
                    name: "Number"
                }
            }, pagedMemory: {
                serializedName: "properties.paged_memory",
                xmlName: "properties.paged_memory",
                type: {
                    name: "Number"
                }
            }, peakPagedMemory: {
                serializedName: "properties.peak_paged_memory",
                xmlName: "properties.peak_paged_memory",
                type: {
                    name: "Number"
                }
            }, timeStamp: {
                serializedName: "properties.time_stamp",
                xmlName: "properties.time_stamp",
                type: {
                    name: "DateTime"
                }
            }, environmentVariables: {
                serializedName: "properties.environment_variables",
                xmlName: "properties.environment_variables",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, isScmSite: {
                serializedName: "properties.is_scm_site",
                xmlName: "properties.is_scm_site",
                type: {
                    name: "Boolean"
                }
            }, isWebjob: {
                serializedName: "properties.is_webjob",
                xmlName: "properties.is_webjob",
                type: {
                    name: "Boolean"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const StorageMigrationOptions = {
    serializedName: "StorageMigrationOptions",
    type: {
        name: "Composite",
        className: "StorageMigrationOptions",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { azurefilesConnectionString: {
                serializedName: "properties.azurefilesConnectionString",
                xmlName: "properties.azurefilesConnectionString",
                type: {
                    name: "String"
                }
            }, azurefilesShare: {
                serializedName: "properties.azurefilesShare",
                xmlName: "properties.azurefilesShare",
                type: {
                    name: "String"
                }
            }, switchSiteAfterMigration: {
                defaultValue: false,
                serializedName: "properties.switchSiteAfterMigration",
                xmlName: "properties.switchSiteAfterMigration",
                type: {
                    name: "Boolean"
                }
            }, blockWriteAccessToSite: {
                defaultValue: false,
                serializedName: "properties.blockWriteAccessToSite",
                xmlName: "properties.blockWriteAccessToSite",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const StorageMigrationResponse = {
    serializedName: "StorageMigrationResponse",
    type: {
        name: "Composite",
        className: "StorageMigrationResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { operationId: {
                serializedName: "properties.operationId",
                readOnly: true,
                xmlName: "properties.operationId",
                type: {
                    name: "String"
                }
            } })
    }
};
const MigrateMySqlRequest = {
    serializedName: "MigrateMySqlRequest",
    type: {
        name: "Composite",
        className: "MigrateMySqlRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { connectionString: {
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String"
                }
            }, migrationType: {
                serializedName: "properties.migrationType",
                xmlName: "properties.migrationType",
                type: {
                    name: "Enum",
                    allowedValues: ["LocalToRemote", "RemoteToLocal"]
                }
            } })
    }
};
const MigrateMySqlStatus = {
    serializedName: "MigrateMySqlStatus",
    type: {
        name: "Composite",
        className: "MigrateMySqlStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { migrationOperationStatus: {
                serializedName: "properties.migrationOperationStatus",
                readOnly: true,
                xmlName: "properties.migrationOperationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InProgress",
                        "Failed",
                        "Succeeded",
                        "TimedOut",
                        "Created"
                    ]
                }
            }, operationId: {
                serializedName: "properties.operationId",
                readOnly: true,
                xmlName: "properties.operationId",
                type: {
                    name: "String"
                }
            }, localMySqlEnabled: {
                serializedName: "properties.localMySqlEnabled",
                readOnly: true,
                xmlName: "properties.localMySqlEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SwiftVirtualNetwork = {
    serializedName: "SwiftVirtualNetwork",
    type: {
        name: "Composite",
        className: "SwiftVirtualNetwork",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { subnetResourceId: {
                serializedName: "properties.subnetResourceId",
                xmlName: "properties.subnetResourceId",
                type: {
                    name: "String"
                }
            }, swiftSupported: {
                serializedName: "properties.swiftSupported",
                xmlName: "properties.swiftSupported",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NetworkFeatures = {
    serializedName: "NetworkFeatures",
    type: {
        name: "Composite",
        className: "NetworkFeatures",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { virtualNetworkName: {
                serializedName: "properties.virtualNetworkName",
                readOnly: true,
                xmlName: "properties.virtualNetworkName",
                type: {
                    name: "String"
                }
            }, virtualNetworkConnection: {
                serializedName: "properties.virtualNetworkConnection",
                xmlName: "properties.virtualNetworkConnection",
                type: {
                    name: "Composite",
                    className: "VnetInfo"
                }
            }, hybridConnections: {
                serializedName: "properties.hybridConnections",
                readOnly: true,
                xmlName: "properties.hybridConnections",
                xmlElementName: "RelayServiceConnectionEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelayServiceConnectionEntity"
                        }
                    }
                }
            }, hybridConnectionsV2: {
                serializedName: "properties.hybridConnectionsV2",
                readOnly: true,
                xmlName: "properties.hybridConnectionsV2",
                xmlElementName: "HybridConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HybridConnection"
                        }
                    }
                }
            } })
    }
};
const SitePhpErrorLogFlag = {
    serializedName: "SitePhpErrorLogFlag",
    type: {
        name: "Composite",
        className: "SitePhpErrorLogFlag",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { localLogErrors: {
                serializedName: "properties.localLogErrors",
                xmlName: "properties.localLogErrors",
                type: {
                    name: "String"
                }
            }, masterLogErrors: {
                serializedName: "properties.masterLogErrors",
                xmlName: "properties.masterLogErrors",
                type: {
                    name: "String"
                }
            }, localLogErrorsMaxLength: {
                serializedName: "properties.localLogErrorsMaxLength",
                xmlName: "properties.localLogErrorsMaxLength",
                type: {
                    name: "String"
                }
            }, masterLogErrorsMaxLength: {
                serializedName: "properties.masterLogErrorsMaxLength",
                xmlName: "properties.masterLogErrorsMaxLength",
                type: {
                    name: "String"
                }
            } })
    }
};
const PremierAddOnPatchResource = {
    serializedName: "PremierAddOnPatchResource",
    type: {
        name: "Composite",
        className: "PremierAddOnPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "String"
                }
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String"
                }
            }, vendor: {
                serializedName: "properties.vendor",
                xmlName: "properties.vendor",
                type: {
                    name: "String"
                }
            }, marketplacePublisher: {
                serializedName: "properties.marketplacePublisher",
                xmlName: "properties.marketplacePublisher",
                type: {
                    name: "String"
                }
            }, marketplaceOffer: {
                serializedName: "properties.marketplaceOffer",
                xmlName: "properties.marketplaceOffer",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateAccess = {
    serializedName: "PrivateAccess",
    type: {
        name: "Composite",
        className: "PrivateAccess",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, virtualNetworks: {
                serializedName: "properties.virtualNetworks",
                xmlName: "properties.virtualNetworks",
                xmlElementName: "PrivateAccessVirtualNetwork",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateAccessVirtualNetwork"
                        }
                    }
                }
            } })
    }
};
const PublicCertificate = {
    serializedName: "PublicCertificate",
    type: {
        name: "Composite",
        className: "PublicCertificate",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { blob: {
                serializedName: "properties.blob",
                xmlName: "properties.blob",
                type: {
                    name: "ByteArray"
                }
            }, publicCertificateLocation: {
                serializedName: "properties.publicCertificateLocation",
                xmlName: "properties.publicCertificateLocation",
                type: {
                    name: "Enum",
                    allowedValues: ["CurrentUserMy", "LocalMachineMy", "Unknown"]
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                xmlName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            } })
    }
};
const DeletedAppRestoreRequest = {
    serializedName: "DeletedAppRestoreRequest",
    type: {
        name: "Composite",
        className: "DeletedAppRestoreRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deletedSiteId: {
                serializedName: "properties.deletedSiteId",
                xmlName: "properties.deletedSiteId",
                type: {
                    name: "String"
                }
            }, recoverConfiguration: {
                serializedName: "properties.recoverConfiguration",
                xmlName: "properties.recoverConfiguration",
                type: {
                    name: "Boolean"
                }
            }, snapshotTime: {
                serializedName: "properties.snapshotTime",
                xmlName: "properties.snapshotTime",
                type: {
                    name: "String"
                }
            }, useDRSecondary: {
                serializedName: "properties.useDRSecondary",
                xmlName: "properties.useDRSecondary",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SnapshotRestoreRequest = {
    serializedName: "SnapshotRestoreRequest",
    type: {
        name: "Composite",
        className: "SnapshotRestoreRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { snapshotTime: {
                serializedName: "properties.snapshotTime",
                xmlName: "properties.snapshotTime",
                type: {
                    name: "String"
                }
            }, recoverySource: {
                serializedName: "properties.recoverySource",
                xmlName: "properties.recoverySource",
                type: {
                    name: "Composite",
                    className: "SnapshotRecoverySource"
                }
            }, overwrite: {
                serializedName: "properties.overwrite",
                xmlName: "properties.overwrite",
                type: {
                    name: "Boolean"
                }
            }, recoverConfiguration: {
                serializedName: "properties.recoverConfiguration",
                xmlName: "properties.recoverConfiguration",
                type: {
                    name: "Boolean"
                }
            }, ignoreConflictingHostNames: {
                serializedName: "properties.ignoreConflictingHostNames",
                xmlName: "properties.ignoreConflictingHostNames",
                type: {
                    name: "Boolean"
                }
            }, useDRSecondary: {
                serializedName: "properties.useDRSecondary",
                xmlName: "properties.useDRSecondary",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SiteExtensionInfo = {
    serializedName: "SiteExtensionInfo",
    type: {
        name: "Composite",
        className: "SiteExtensionInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { extensionId: {
                serializedName: "properties.extension_id",
                xmlName: "properties.extension_id",
                type: {
                    name: "String"
                }
            }, title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            }, extensionType: {
                serializedName: "properties.extension_type",
                xmlName: "properties.extension_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Gallery", "WebRoot"]
                }
            }, summary: {
                serializedName: "properties.summary",
                xmlName: "properties.summary",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                xmlName: "properties.version",
                type: {
                    name: "String"
                }
            }, extensionUrl: {
                serializedName: "properties.extension_url",
                xmlName: "properties.extension_url",
                type: {
                    name: "String"
                }
            }, projectUrl: {
                serializedName: "properties.project_url",
                xmlName: "properties.project_url",
                type: {
                    name: "String"
                }
            }, iconUrl: {
                serializedName: "properties.icon_url",
                xmlName: "properties.icon_url",
                type: {
                    name: "String"
                }
            }, licenseUrl: {
                serializedName: "properties.license_url",
                xmlName: "properties.license_url",
                type: {
                    name: "String"
                }
            }, feedUrl: {
                serializedName: "properties.feed_url",
                xmlName: "properties.feed_url",
                type: {
                    name: "String"
                }
            }, authors: {
                serializedName: "properties.authors",
                xmlName: "properties.authors",
                xmlElementName: "SiteExtensionInfoPropertiesAuthorsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, installerCommandLineParams: {
                serializedName: "properties.installer_command_line_params",
                xmlName: "properties.installer_command_line_params",
                type: {
                    name: "String"
                }
            }, publishedDateTime: {
                serializedName: "properties.published_date_time",
                xmlName: "properties.published_date_time",
                type: {
                    name: "DateTime"
                }
            }, downloadCount: {
                serializedName: "properties.download_count",
                xmlName: "properties.download_count",
                type: {
                    name: "Number"
                }
            }, localIsLatestVersion: {
                serializedName: "properties.local_is_latest_version",
                xmlName: "properties.local_is_latest_version",
                type: {
                    name: "Boolean"
                }
            }, localPath: {
                serializedName: "properties.local_path",
                xmlName: "properties.local_path",
                type: {
                    name: "String"
                }
            }, installedDateTime: {
                serializedName: "properties.installed_date_time",
                xmlName: "properties.installed_date_time",
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, comment: {
                serializedName: "properties.comment",
                xmlName: "properties.comment",
                type: {
                    name: "String"
                }
            } })
    }
};
const SlotDifference = {
    serializedName: "SlotDifference",
    type: {
        name: "Composite",
        className: "SlotDifference",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { level: {
                serializedName: "properties.level",
                readOnly: true,
                xmlName: "properties.level",
                type: {
                    name: "String"
                }
            }, settingType: {
                serializedName: "properties.settingType",
                readOnly: true,
                xmlName: "properties.settingType",
                type: {
                    name: "String"
                }
            }, diffRule: {
                serializedName: "properties.diffRule",
                readOnly: true,
                xmlName: "properties.diffRule",
                type: {
                    name: "String"
                }
            }, settingName: {
                serializedName: "properties.settingName",
                readOnly: true,
                xmlName: "properties.settingName",
                type: {
                    name: "String"
                }
            }, valueInCurrentSlot: {
                serializedName: "properties.valueInCurrentSlot",
                readOnly: true,
                xmlName: "properties.valueInCurrentSlot",
                type: {
                    name: "String"
                }
            }, valueInTargetSlot: {
                serializedName: "properties.valueInTargetSlot",
                readOnly: true,
                xmlName: "properties.valueInTargetSlot",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const SiteSourceControl = {
    serializedName: "SiteSourceControl",
    type: {
        name: "Composite",
        className: "SiteSourceControl",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { repoUrl: {
                serializedName: "properties.repoUrl",
                xmlName: "properties.repoUrl",
                type: {
                    name: "String"
                }
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            }, isManualIntegration: {
                serializedName: "properties.isManualIntegration",
                xmlName: "properties.isManualIntegration",
                type: {
                    name: "Boolean"
                }
            }, isGitHubAction: {
                serializedName: "properties.isGitHubAction",
                xmlName: "properties.isGitHubAction",
                type: {
                    name: "Boolean"
                }
            }, deploymentRollbackEnabled: {
                serializedName: "properties.deploymentRollbackEnabled",
                xmlName: "properties.deploymentRollbackEnabled",
                type: {
                    name: "Boolean"
                }
            }, isMercurial: {
                serializedName: "properties.isMercurial",
                xmlName: "properties.isMercurial",
                type: {
                    name: "Boolean"
                }
            }, gitHubActionConfiguration: {
                serializedName: "properties.gitHubActionConfiguration",
                xmlName: "properties.gitHubActionConfiguration",
                type: {
                    name: "Composite",
                    className: "GitHubActionConfiguration"
                }
            } })
    }
};
const TriggeredWebJob = {
    serializedName: "TriggeredWebJob",
    type: {
        name: "Composite",
        className: "TriggeredWebJob",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { latestRun: {
                serializedName: "properties.latest_run",
                xmlName: "properties.latest_run",
                type: {
                    name: "Composite",
                    className: "TriggeredJobRun"
                }
            }, historyUrl: {
                serializedName: "properties.history_url",
                xmlName: "properties.history_url",
                type: {
                    name: "String"
                }
            }, schedulerLogsUrl: {
                serializedName: "properties.scheduler_logs_url",
                xmlName: "properties.scheduler_logs_url",
                type: {
                    name: "String"
                }
            }, runCommand: {
                serializedName: "properties.run_command",
                xmlName: "properties.run_command",
                type: {
                    name: "String"
                }
            }, url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            }, extraInfoUrl: {
                serializedName: "properties.extra_info_url",
                xmlName: "properties.extra_info_url",
                type: {
                    name: "String"
                }
            }, webJobType: {
                serializedName: "properties.web_job_type",
                xmlName: "properties.web_job_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Continuous", "Triggered"]
                }
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "String"
                }
            }, usingSdk: {
                serializedName: "properties.using_sdk",
                xmlName: "properties.using_sdk",
                type: {
                    name: "Boolean"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, storageAccountRequired: {
                serializedName: "properties.storageAccountRequired",
                xmlName: "properties.storageAccountRequired",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            } })
    }
};
const TriggeredJobHistory = {
    serializedName: "TriggeredJobHistory",
    type: {
        name: "Composite",
        className: "TriggeredJobHistory",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { runs: {
                serializedName: "properties.runs",
                xmlName: "properties.runs",
                xmlElementName: "TriggeredJobRun",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TriggeredJobRun"
                        }
                    }
                }
            } })
    }
};
const WebJob = {
    serializedName: "WebJob",
    type: {
        name: "Composite",
        className: "WebJob",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { runCommand: {
                serializedName: "properties.run_command",
                xmlName: "properties.run_command",
                type: {
                    name: "String"
                }
            }, url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            }, extraInfoUrl: {
                serializedName: "properties.extra_info_url",
                xmlName: "properties.extra_info_url",
                type: {
                    name: "String"
                }
            }, webJobType: {
                serializedName: "properties.web_job_type",
                xmlName: "properties.web_job_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Continuous", "Triggered"]
                }
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "String"
                }
            }, usingSdk: {
                serializedName: "properties.using_sdk",
                xmlName: "properties.using_sdk",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            } })
    }
};
const WorkflowOutputParameter = {
    serializedName: "WorkflowOutputParameter",
    type: {
        name: "Composite",
        className: "WorkflowOutputParameter",
        modelProperties: Object.assign(Object.assign({}, WorkflowParameter.type.modelProperties), { error: {
                serializedName: "error",
                readOnly: true,
                xmlName: "error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const WorkflowRun = {
    serializedName: "WorkflowRun",
    type: {
        name: "Composite",
        className: "WorkflowRun",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }, waitEndTime: {
                serializedName: "properties.waitEndTime",
                readOnly: true,
                xmlName: "properties.waitEndTime",
                type: {
                    name: "DateTime"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                xmlName: "properties.code",
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                xmlName: "properties.error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, correlationId: {
                serializedName: "properties.correlationId",
                readOnly: true,
                xmlName: "properties.correlationId",
                type: {
                    name: "String"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "Correlation"
                }
            }, workflow: {
                serializedName: "properties.workflow",
                xmlName: "properties.workflow",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, trigger: {
                serializedName: "properties.trigger",
                xmlName: "properties.trigger",
                type: {
                    name: "Composite",
                    className: "WorkflowRunTrigger"
                }
            }, outputs: {
                serializedName: "properties.outputs",
                readOnly: true,
                xmlName: "properties.outputs",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "WorkflowOutputParameter" }
                    }
                }
            }, response: {
                serializedName: "properties.response",
                xmlName: "properties.response",
                type: {
                    name: "Composite",
                    className: "WorkflowRunTrigger"
                }
            } })
    }
};
const WorkflowRunAction = {
    serializedName: "WorkflowRunAction",
    type: {
        name: "Composite",
        className: "WorkflowRunAction",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                xmlName: "properties.code",
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                xmlName: "properties.error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                xmlName: "properties.trackingId",
                type: {
                    name: "String"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation"
                }
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                xmlName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                xmlName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, trackedProperties: {
                serializedName: "properties.trackedProperties",
                readOnly: true,
                xmlName: "properties.trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, retryHistory: {
                serializedName: "properties.retryHistory",
                xmlName: "properties.retryHistory",
                xmlElementName: "RetryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory"
                        }
                    }
                }
            } })
    }
};
const WorkflowTrigger = {
    serializedName: "WorkflowTrigger",
    type: {
        name: "Composite",
        className: "WorkflowTrigger",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                xmlName: "properties.changedTime",
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, lastExecutionTime: {
                serializedName: "properties.lastExecutionTime",
                readOnly: true,
                xmlName: "properties.lastExecutionTime",
                type: {
                    name: "DateTime"
                }
            }, nextExecutionTime: {
                serializedName: "properties.nextExecutionTime",
                readOnly: true,
                xmlName: "properties.nextExecutionTime",
                type: {
                    name: "DateTime"
                }
            }, recurrence: {
                serializedName: "properties.recurrence",
                xmlName: "properties.recurrence",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerRecurrence"
                }
            }, workflow: {
                serializedName: "properties.workflow",
                xmlName: "properties.workflow",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            } })
    }
};
const WorkflowTriggerHistory = {
    serializedName: "WorkflowTriggerHistory",
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistory",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, scheduledTime: {
                serializedName: "properties.scheduledTime",
                readOnly: true,
                xmlName: "properties.scheduledTime",
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                xmlName: "properties.code",
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                xmlName: "properties.error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                xmlName: "properties.trackingId",
                type: {
                    name: "String"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "Correlation"
                }
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                xmlName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                xmlName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, fired: {
                serializedName: "properties.fired",
                readOnly: true,
                xmlName: "properties.fired",
                type: {
                    name: "Boolean"
                }
            }, run: {
                serializedName: "properties.run",
                xmlName: "properties.run",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            } })
    }
};
const RunActionCorrelation = {
    serializedName: "RunActionCorrelation",
    type: {
        name: "Composite",
        className: "RunActionCorrelation",
        modelProperties: Object.assign(Object.assign({}, RunCorrelation.type.modelProperties), { actionTrackingId: {
                serializedName: "actionTrackingId",
                xmlName: "actionTrackingId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressionRoot = {
    serializedName: "ExpressionRoot",
    type: {
        name: "Composite",
        className: "ExpressionRoot",
        modelProperties: Object.assign(Object.assign({}, Expression.type.modelProperties), { path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureResourceErrorInfo = {
    serializedName: "AzureResourceErrorInfo",
    type: {
        name: "Composite",
        className: "AzureResourceErrorInfo",
        modelProperties: Object.assign(Object.assign({}, ErrorInfo.type.modelProperties), { message: {
                serializedName: "message",
                required: true,
                xmlName: "message",
                type: {
                    name: "String"
                }
            }, details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "AzureResourceErrorInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureResourceErrorInfo"
                        }
                    }
                }
            } })
    }
};
const OperationResult = {
    serializedName: "OperationResult",
    type: {
        name: "Composite",
        className: "OperationResult",
        modelProperties: Object.assign(Object.assign({}, OperationResultProperties.type.modelProperties), { trackingId: {
                serializedName: "trackingId",
                readOnly: true,
                xmlName: "trackingId",
                type: {
                    name: "String"
                }
            }, inputs: {
                serializedName: "inputs",
                readOnly: true,
                xmlName: "inputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, inputsLink: {
                serializedName: "inputsLink",
                xmlName: "inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputs: {
                serializedName: "outputs",
                readOnly: true,
                xmlName: "outputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, outputsLink: {
                serializedName: "outputsLink",
                xmlName: "outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, trackedProperties: {
                serializedName: "trackedProperties",
                readOnly: true,
                xmlName: "trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, retryHistory: {
                serializedName: "retryHistory",
                xmlName: "retryHistory",
                xmlElementName: "RetryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory"
                        }
                    }
                }
            }, iterationCount: {
                serializedName: "iterationCount",
                xmlName: "iterationCount",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkflowRunActionRepetitionDefinition = {
    serializedName: "WorkflowRunActionRepetitionDefinition",
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionDefinition",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation"
                }
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                xmlName: "properties.code",
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "any"
                }
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                xmlName: "properties.trackingId",
                type: {
                    name: "String"
                }
            }, inputs: {
                serializedName: "properties.inputs",
                readOnly: true,
                xmlName: "properties.inputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                xmlName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputs: {
                serializedName: "properties.outputs",
                readOnly: true,
                xmlName: "properties.outputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                xmlName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, trackedProperties: {
                serializedName: "properties.trackedProperties",
                readOnly: true,
                xmlName: "properties.trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, retryHistory: {
                serializedName: "properties.retryHistory",
                xmlName: "properties.retryHistory",
                xmlElementName: "RetryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory"
                        }
                    }
                }
            }, iterationCount: {
                serializedName: "properties.iterationCount",
                xmlName: "properties.iterationCount",
                type: {
                    name: "Number"
                }
            }, repetitionIndexes: {
                serializedName: "properties.repetitionIndexes",
                xmlName: "properties.repetitionIndexes",
                xmlElementName: "RepetitionIndex",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepetitionIndex"
                        }
                    }
                }
            } })
    }
};
const RequestHistory = {
    serializedName: "RequestHistory",
    type: {
        name: "Composite",
        className: "RequestHistory",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "RequestHistoryProperties"
                }
            } })
    }
};
const Workflow = {
    serializedName: "Workflow",
    type: {
        name: "Composite",
        className: "Workflow",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                xmlName: "properties.changedTime",
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                xmlName: "properties.version",
                type: {
                    name: "String"
                }
            }, accessEndpoint: {
                serializedName: "properties.accessEndpoint",
                readOnly: true,
                xmlName: "properties.accessEndpoint",
                type: {
                    name: "String"
                }
            }, endpointsConfiguration: {
                serializedName: "properties.endpointsConfiguration",
                xmlName: "properties.endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration"
                }
            }, accessControl: {
                serializedName: "properties.accessControl",
                xmlName: "properties.accessControl",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfiguration"
                }
            }, sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "WorkflowSku"
                }
            }, integrationAccount: {
                serializedName: "properties.integrationAccount",
                xmlName: "properties.integrationAccount",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, integrationServiceEnvironment: {
                serializedName: "properties.integrationServiceEnvironment",
                xmlName: "properties.integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, definition: {
                serializedName: "properties.definition",
                xmlName: "properties.definition",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, parameters: {
                serializedName: "properties.parameters",
                xmlName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "WorkflowParameter" } }
                }
            }, kind: {
                serializedName: "properties.kind",
                xmlName: "properties.kind",
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkflowVersion = {
    serializedName: "WorkflowVersion",
    type: {
        name: "Composite",
        className: "WorkflowVersion",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                xmlName: "properties.changedTime",
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                xmlName: "properties.version",
                type: {
                    name: "String"
                }
            }, accessEndpoint: {
                serializedName: "properties.accessEndpoint",
                readOnly: true,
                xmlName: "properties.accessEndpoint",
                type: {
                    name: "String"
                }
            }, endpointsConfiguration: {
                serializedName: "properties.endpointsConfiguration",
                xmlName: "properties.endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration"
                }
            }, accessControl: {
                serializedName: "properties.accessControl",
                xmlName: "properties.accessControl",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfiguration"
                }
            }, sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "WorkflowSku"
                }
            }, integrationAccount: {
                serializedName: "properties.integrationAccount",
                xmlName: "properties.integrationAccount",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, definition: {
                serializedName: "properties.definition",
                xmlName: "properties.definition",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, parameters: {
                serializedName: "properties.parameters",
                xmlName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "WorkflowParameter" } }
                }
            } })
    }
};
const WorkflowRunActionRepetitionProperties = {
    serializedName: "WorkflowRunActionRepetitionProperties",
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionProperties",
        modelProperties: Object.assign(Object.assign({}, OperationResult.type.modelProperties), { repetitionIndexes: {
                serializedName: "repetitionIndexes",
                xmlName: "repetitionIndexes",
                xmlElementName: "RepetitionIndex",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepetitionIndex"
                        }
                    }
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AppServiceCertificateOrderCollection: AppServiceCertificateOrderCollection,
    AppServiceCertificate: AppServiceCertificate,
    CertificateDetails: CertificateDetails,
    CertificateOrderContact: CertificateOrderContact,
    Resource: Resource,
    DefaultErrorResponse: DefaultErrorResponse,
    DefaultErrorResponseError: DefaultErrorResponseError,
    DefaultErrorResponseErrorDetailsItem: DefaultErrorResponseErrorDetailsItem,
    ProxyOnlyResource: ProxyOnlyResource,
    AppServiceCertificateCollection: AppServiceCertificateCollection,
    NameIdentifier: NameIdentifier,
    SiteSealRequest: SiteSealRequest,
    SiteSeal: SiteSeal,
    CertificateOrderAction: CertificateOrderAction,
    CertificateEmail: CertificateEmail,
    DetectorResponseCollection: DetectorResponseCollection,
    DetectorInfo: DetectorInfo,
    SupportTopic: SupportTopic,
    DiagnosticData: DiagnosticData,
    DataTableResponseObject: DataTableResponseObject,
    DataTableResponseColumn: DataTableResponseColumn,
    Rendering: Rendering,
    Status: Status,
    DataProviderMetadata: DataProviderMetadata,
    KeyValuePairStringObject: KeyValuePairStringObject,
    QueryUtterancesResults: QueryUtterancesResults,
    QueryUtterancesResult: QueryUtterancesResult,
    SampleUtterance: SampleUtterance,
    CsmOperationCollection: CsmOperationCollection,
    CsmOperationDescription: CsmOperationDescription,
    CsmOperationDisplay: CsmOperationDisplay,
    CsmOperationDescriptionProperties: CsmOperationDescriptionProperties,
    ServiceSpecification: ServiceSpecification,
    MetricSpecification: MetricSpecification,
    Dimension: Dimension,
    MetricAvailability: MetricAvailability,
    LogSpecification: LogSpecification,
    DomainAvailabilityCheckResult: DomainAvailabilityCheckResult,
    DomainCollection: DomainCollection,
    Contact: Contact,
    Address: Address,
    HostName: HostName,
    DomainPurchaseConsent: DomainPurchaseConsent,
    DomainControlCenterSsoRequest: DomainControlCenterSsoRequest,
    DomainRecommendationSearchParameters: DomainRecommendationSearchParameters,
    NameIdentifierCollection: NameIdentifierCollection,
    DomainOwnershipIdentifierCollection: DomainOwnershipIdentifierCollection,
    TopLevelDomainCollection: TopLevelDomainCollection,
    TopLevelDomainAgreementOption: TopLevelDomainAgreementOption,
    TldLegalAgreementCollection: TldLegalAgreementCollection,
    TldLegalAgreement: TldLegalAgreement,
    AppServiceEnvironmentCollection: AppServiceEnvironmentCollection,
    AppServiceEnvironment: AppServiceEnvironment,
    VirtualNetworkProfile: VirtualNetworkProfile,
    NameValuePair: NameValuePair,
    StampCapacityCollection: StampCapacityCollection,
    StampCapacity: StampCapacity,
    VirtualIPMapping: VirtualIPMapping,
    WebAppCollection: WebAppCollection,
    HostNameSslState: HostNameSslState,
    SiteConfig: SiteConfig,
    ConnStringInfo: ConnStringInfo,
    SiteMachineKey: SiteMachineKey,
    HandlerMapping: HandlerMapping,
    VirtualApplication: VirtualApplication,
    VirtualDirectory: VirtualDirectory,
    Experiments: Experiments,
    RampUpRule: RampUpRule,
    SiteLimits: SiteLimits,
    AutoHealRules: AutoHealRules,
    AutoHealTriggers: AutoHealTriggers,
    RequestsBasedTrigger: RequestsBasedTrigger,
    StatusCodesBasedTrigger: StatusCodesBasedTrigger,
    SlowRequestsBasedTrigger: SlowRequestsBasedTrigger,
    StatusCodesRangeBasedTrigger: StatusCodesRangeBasedTrigger,
    AutoHealActions: AutoHealActions,
    AutoHealCustomAction: AutoHealCustomAction,
    CorsSettings: CorsSettings,
    ApiDefinitionInfo: ApiDefinitionInfo,
    ApiManagementConfig: ApiManagementConfig,
    IpSecurityRestriction: IpSecurityRestriction,
    AzureStorageInfoValue: AzureStorageInfoValue,
    HostingEnvironmentProfile: HostingEnvironmentProfile,
    CloningInfo: CloningInfo,
    SlotSwapStatus: SlotSwapStatus,
    ManagedServiceIdentity: ManagedServiceIdentity,
    UserAssignedIdentity: UserAssignedIdentity,
    ExtendedLocation: ExtendedLocation,
    HostingEnvironmentDiagnostics: HostingEnvironmentDiagnostics,
    InboundEnvironmentEndpointCollection: InboundEnvironmentEndpointCollection,
    InboundEnvironmentEndpoint: InboundEnvironmentEndpoint,
    WorkerPoolCollection: WorkerPoolCollection,
    SkuDescription: SkuDescription,
    SkuCapacity: SkuCapacity,
    Capability: Capability,
    ResourceMetricDefinitionCollection: ResourceMetricDefinitionCollection,
    ResourceMetricAvailability: ResourceMetricAvailability,
    SkuInfoCollection: SkuInfoCollection,
    SkuInfo: SkuInfo,
    UsageCollection: UsageCollection,
    Operation: Operation,
    ErrorEntity: ErrorEntity,
    OutboundEnvironmentEndpointCollection: OutboundEnvironmentEndpointCollection,
    OutboundEnvironmentEndpoint: OutboundEnvironmentEndpoint,
    EndpointDependency: EndpointDependency,
    EndpointDetail: EndpointDetail,
    PrivateEndpointConnectionCollection: PrivateEndpointConnectionCollection,
    ArmIdWrapper: ArmIdWrapper,
    PrivateLinkConnectionState: PrivateLinkConnectionState,
    PrivateLinkResourcesWrapper: PrivateLinkResourcesWrapper,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkResourceProperties: PrivateLinkResourceProperties,
    AppServicePlanCollection: AppServicePlanCollection,
    KubeEnvironmentProfile: KubeEnvironmentProfile,
    CsmUsageQuotaCollection: CsmUsageQuotaCollection,
    CsmUsageQuota: CsmUsageQuota,
    LocalizableString: LocalizableString,
    ResourceCollection: ResourceCollection,
    HybridConnectionCollection: HybridConnectionCollection,
    VnetInfo: VnetInfo,
    CertificateCollection: CertificateCollection,
    ContainerAppCollection: ContainerAppCollection,
    Configuration: Configuration,
    Secret: Secret,
    Ingress: Ingress,
    TrafficWeight: TrafficWeight,
    RegistryCredentials: RegistryCredentials,
    Template: Template,
    Container: Container,
    EnvironmentVar: EnvironmentVar,
    ContainerResources: ContainerResources,
    Scale: Scale,
    ScaleRule: ScaleRule,
    QueueScaleRule: QueueScaleRule,
    ScaleRuleAuth: ScaleRuleAuth,
    CustomScaleRule: CustomScaleRule,
    HttpScaleRule: HttpScaleRule,
    Dapr: Dapr,
    DaprComponent: DaprComponent,
    DaprMetadata: DaprMetadata,
    SecretsCollection: SecretsCollection,
    ContainerAppSecret: ContainerAppSecret,
    RevisionCollection: RevisionCollection,
    DeletedWebAppCollection: DeletedWebAppCollection,
    DiagnosticCategoryCollection: DiagnosticCategoryCollection,
    DiagnosticAnalysisCollection: DiagnosticAnalysisCollection,
    AbnormalTimePeriod: AbnormalTimePeriod,
    DetectorAbnormalTimePeriod: DetectorAbnormalTimePeriod,
    Solution: Solution,
    AnalysisData: AnalysisData,
    DetectorDefinition: DetectorDefinition,
    DiagnosticMetricSet: DiagnosticMetricSet,
    DiagnosticMetricSample: DiagnosticMetricSample,
    ResponseMetaData: ResponseMetaData,
    DataSource: DataSource,
    DiagnosticDetectorCollection: DiagnosticDetectorCollection,
    KubeEnvironmentCollection: KubeEnvironmentCollection,
    ArcConfiguration: ArcConfiguration,
    FrontEndConfiguration: FrontEndConfiguration,
    AppLogsConfiguration: AppLogsConfiguration,
    LogAnalyticsConfiguration: LogAnalyticsConfiguration,
    ContainerAppsConfiguration: ContainerAppsConfiguration,
    ApplicationStackCollection: ApplicationStackCollection,
    ApplicationStack: ApplicationStack,
    StackMajorVersion: StackMajorVersion,
    StackMinorVersion: StackMinorVersion,
    FunctionAppStackCollection: FunctionAppStackCollection,
    FunctionAppMajorVersion: FunctionAppMajorVersion,
    FunctionAppMinorVersion: FunctionAppMinorVersion,
    FunctionAppRuntimes: FunctionAppRuntimes,
    FunctionAppRuntimeSettings: FunctionAppRuntimeSettings,
    AppInsightsWebAppStackSettings: AppInsightsWebAppStackSettings,
    GitHubActionWebAppStackSettings: GitHubActionWebAppStackSettings,
    SiteConfigPropertiesDictionary: SiteConfigPropertiesDictionary,
    WebAppStackCollection: WebAppStackCollection,
    WebAppMajorVersion: WebAppMajorVersion,
    WebAppMinorVersion: WebAppMinorVersion,
    WebAppRuntimes: WebAppRuntimes,
    WebAppRuntimeSettings: WebAppRuntimeSettings,
    LinuxJavaContainerSettings: LinuxJavaContainerSettings,
    WindowsJavaContainerSettings: WindowsJavaContainerSettings,
    RecommendationCollection: RecommendationCollection,
    ResourceHealthMetadataCollection: ResourceHealthMetadataCollection,
    SourceControlCollection: SourceControlCollection,
    BillingMeterCollection: BillingMeterCollection,
    ResourceNameAvailabilityRequest: ResourceNameAvailabilityRequest,
    ResourceNameAvailability: ResourceNameAvailability,
    CustomHostnameSitesCollection: CustomHostnameSitesCollection,
    DeploymentLocations: DeploymentLocations,
    HostingEnvironmentDeploymentInfo: HostingEnvironmentDeploymentInfo,
    GeoRegionCollection: GeoRegionCollection,
    IdentifierCollection: IdentifierCollection,
    PremierAddOnOfferCollection: PremierAddOnOfferCollection,
    SkuInfos: SkuInfos,
    GlobalCsmSkuDescription: GlobalCsmSkuDescription,
    CsmMoveResourceEnvelope: CsmMoveResourceEnvelope,
    ValidateRequest: ValidateRequest,
    ValidateResponse: ValidateResponse,
    ValidateResponseError: ValidateResponseError,
    StaticSiteBuildProperties: StaticSiteBuildProperties,
    StaticSiteCollection: StaticSiteCollection,
    ResponseMessageEnvelopeRemotePrivateEndpointConnection: ResponseMessageEnvelopeRemotePrivateEndpointConnection,
    ArmPlan: ArmPlan,
    StaticSiteTemplateOptions: StaticSiteTemplateOptions,
    StaticSiteLinkedBackend: StaticSiteLinkedBackend,
    StaticSiteUserCollection: StaticSiteUserCollection,
    StaticSiteBuildCollection: StaticSiteBuildCollection,
    StaticSiteFunctionOverviewCollection: StaticSiteFunctionOverviewCollection,
    StaticSiteUserProvidedFunctionAppsCollection: StaticSiteUserProvidedFunctionAppsCollection,
    StaticSiteCustomDomainOverviewCollection: StaticSiteCustomDomainOverviewCollection,
    StaticSiteLinkedBackendsCollection: StaticSiteLinkedBackendsCollection,
    CsmSlotEntity: CsmSlotEntity,
    BackupSchedule: BackupSchedule,
    DatabaseBackupSetting: DatabaseBackupSetting,
    BackupItemCollection: BackupItemCollection,
    PublishingCredentialsPoliciesCollection: PublishingCredentialsPoliciesCollection,
    SiteConfigResourceCollection: SiteConfigResourceCollection,
    AuthPlatform: AuthPlatform,
    GlobalValidation: GlobalValidation,
    IdentityProviders: IdentityProviders,
    AzureActiveDirectory: AzureActiveDirectory,
    AzureActiveDirectoryRegistration: AzureActiveDirectoryRegistration,
    AzureActiveDirectoryLogin: AzureActiveDirectoryLogin,
    AzureActiveDirectoryValidation: AzureActiveDirectoryValidation,
    JwtClaimChecks: JwtClaimChecks,
    DefaultAuthorizationPolicy: DefaultAuthorizationPolicy,
    AllowedPrincipals: AllowedPrincipals,
    Facebook: Facebook,
    AppRegistration: AppRegistration,
    LoginScopes: LoginScopes,
    GitHub: GitHub,
    ClientRegistration: ClientRegistration,
    Google: Google,
    AllowedAudiencesValidation: AllowedAudiencesValidation,
    LegacyMicrosoftAccount: LegacyMicrosoftAccount,
    Twitter: Twitter,
    TwitterRegistration: TwitterRegistration,
    Apple: Apple,
    AppleRegistration: AppleRegistration,
    AzureStaticWebApps: AzureStaticWebApps,
    AzureStaticWebAppsRegistration: AzureStaticWebAppsRegistration,
    CustomOpenIdConnectProvider: CustomOpenIdConnectProvider,
    OpenIdConnectRegistration: OpenIdConnectRegistration,
    OpenIdConnectClientCredential: OpenIdConnectClientCredential,
    OpenIdConnectConfig: OpenIdConnectConfig,
    OpenIdConnectLogin: OpenIdConnectLogin,
    Login: Login,
    LoginRoutes: LoginRoutes,
    TokenStore: TokenStore,
    FileSystemTokenStore: FileSystemTokenStore,
    BlobStorageTokenStore: BlobStorageTokenStore,
    CookieExpiration: CookieExpiration,
    Nonce: Nonce,
    HttpSettings: HttpSettings,
    HttpSettingsRoutes: HttpSettingsRoutes,
    ForwardProxy: ForwardProxy,
    ApiKVReferenceCollection: ApiKVReferenceCollection,
    ConnStringValueTypePair: ConnStringValueTypePair,
    ApplicationLogsConfig: ApplicationLogsConfig,
    FileSystemApplicationLogsConfig: FileSystemApplicationLogsConfig,
    AzureTableStorageApplicationLogsConfig: AzureTableStorageApplicationLogsConfig,
    AzureBlobStorageApplicationLogsConfig: AzureBlobStorageApplicationLogsConfig,
    HttpLogsConfig: HttpLogsConfig,
    FileSystemHttpLogsConfig: FileSystemHttpLogsConfig,
    AzureBlobStorageHttpLogsConfig: AzureBlobStorageHttpLogsConfig,
    EnabledConfig: EnabledConfig,
    SiteConfigurationSnapshotInfoCollection: SiteConfigurationSnapshotInfoCollection,
    ContinuousWebJobCollection: ContinuousWebJobCollection,
    CsmDeploymentStatusCollection: CsmDeploymentStatusCollection,
    DeploymentCollection: DeploymentCollection,
    MSDeployLogEntry: MSDeployLogEntry,
    FunctionEnvelopeCollection: FunctionEnvelopeCollection,
    KeyInfo: KeyInfo,
    FunctionSecrets: FunctionSecrets,
    HostKeys: HostKeys,
    HostNameBindingCollection: HostNameBindingCollection,
    WebAppInstanceStatusCollection: WebAppInstanceStatusCollection,
    ContainerInfo: ContainerInfo,
    ContainerCpuStatistics: ContainerCpuStatistics,
    ContainerCpuUsage: ContainerCpuUsage,
    ContainerThrottlingData: ContainerThrottlingData,
    ContainerMemoryStatistics: ContainerMemoryStatistics,
    ContainerNetworkInterfaceStatistics: ContainerNetworkInterfaceStatistics,
    ProcessInfoCollection: ProcessInfoCollection,
    ProcessModuleInfoCollection: ProcessModuleInfoCollection,
    ProcessThreadInfoCollection: ProcessThreadInfoCollection,
    SiteCloneability: SiteCloneability,
    SiteCloneabilityCriterion: SiteCloneabilityCriterion,
    NetworkTrace: NetworkTrace,
    PerfMonCounterCollection: PerfMonCounterCollection,
    PerfMonResponse: PerfMonResponse,
    PerfMonSet: PerfMonSet,
    PerfMonSample: PerfMonSample,
    PrivateAccessVirtualNetwork: PrivateAccessVirtualNetwork,
    PrivateAccessSubnet: PrivateAccessSubnet,
    PublicCertificateCollection: PublicCertificateCollection,
    CsmPublishingProfileOptions: CsmPublishingProfileOptions,
    SnapshotRecoverySource: SnapshotRecoverySource,
    SiteExtensionInfoCollection: SiteExtensionInfoCollection,
    SlotDifferenceCollection: SlotDifferenceCollection,
    SnapshotCollection: SnapshotCollection,
    GitHubActionConfiguration: GitHubActionConfiguration,
    GitHubActionCodeConfiguration: GitHubActionCodeConfiguration,
    GitHubActionContainerConfiguration: GitHubActionContainerConfiguration,
    TriggeredWebJobCollection: TriggeredWebJobCollection,
    TriggeredJobRun: TriggeredJobRun,
    TriggeredJobHistoryCollection: TriggeredJobHistoryCollection,
    WebJobCollection: WebJobCollection,
    RegenerateActionParameter: RegenerateActionParameter,
    ErrorResponse: ErrorResponse,
    ErrorProperties: ErrorProperties,
    WorkflowRunListResult: WorkflowRunListResult,
    Correlation: Correlation,
    ResourceReference: ResourceReference,
    WorkflowRunTrigger: WorkflowRunTrigger,
    ContentLink: ContentLink,
    ContentHash: ContentHash,
    WorkflowParameter: WorkflowParameter,
    SubResource: SubResource,
    WorkflowRunActionListResult: WorkflowRunActionListResult,
    RunCorrelation: RunCorrelation,
    RetryHistory: RetryHistory,
    ExpressionTraces: ExpressionTraces,
    Expression: Expression,
    ErrorInfo: ErrorInfo,
    WorkflowRunActionRepetitionDefinitionCollection: WorkflowRunActionRepetitionDefinitionCollection,
    RepetitionIndex: RepetitionIndex,
    OperationResultProperties: OperationResultProperties,
    WorkflowResource: WorkflowResource,
    RequestHistoryListResult: RequestHistoryListResult,
    RequestHistoryProperties: RequestHistoryProperties,
    Request: Request,
    Response: Response,
    WorkflowTriggerListResult: WorkflowTriggerListResult,
    WorkflowTriggerRecurrence: WorkflowTriggerRecurrence,
    RecurrenceSchedule: RecurrenceSchedule,
    RecurrenceScheduleOccurrence: RecurrenceScheduleOccurrence,
    WorkflowTriggerHistoryListResult: WorkflowTriggerHistoryListResult,
    WorkflowTriggerCallbackUrl: WorkflowTriggerCallbackUrl,
    WorkflowTriggerListCallbackUrlQueries: WorkflowTriggerListCallbackUrlQueries,
    JsonSchema: JsonSchema,
    FlowEndpointsConfiguration: FlowEndpointsConfiguration,
    FlowEndpoints: FlowEndpoints,
    IpAddress: IpAddress,
    FlowAccessControlConfiguration: FlowAccessControlConfiguration,
    FlowAccessControlConfigurationPolicy: FlowAccessControlConfigurationPolicy,
    IpAddressRange: IpAddressRange,
    OpenAuthenticationAccessPolicies: OpenAuthenticationAccessPolicies,
    OpenAuthenticationAccessPolicy: OpenAuthenticationAccessPolicy,
    OpenAuthenticationPolicyClaim: OpenAuthenticationPolicyClaim,
    WorkflowSku: WorkflowSku,
    WorkflowVersionListResult: WorkflowVersionListResult,
    AppserviceGithubToken: AppserviceGithubToken,
    AppserviceGithubTokenRequest: AppserviceGithubTokenRequest,
    WorkflowFilter: WorkflowFilter,
    WorkflowListResult: WorkflowListResult,
    WorkflowRunActionFilter: WorkflowRunActionFilter,
    WorkflowRunFilter: WorkflowRunFilter,
    WorkflowTriggerFilter: WorkflowTriggerFilter,
    WorkflowTriggerHistoryFilter: WorkflowTriggerHistoryFilter,
    AppServiceCertificateOrder: AppServiceCertificateOrder,
    AppServiceCertificateResource: AppServiceCertificateResource,
    Domain: Domain,
    AppServiceEnvironmentResource: AppServiceEnvironmentResource,
    Site: Site,
    AppServicePlan: AppServicePlan,
    Certificate: Certificate,
    ContainerApp: ContainerApp,
    Revision: Revision,
    KubeEnvironment: KubeEnvironment,
    StaticSiteARMResource: StaticSiteARMResource,
    PremierAddOn: PremierAddOn,
    AppServiceCertificateOrderPatchResource: AppServiceCertificateOrderPatchResource,
    AppServiceCertificatePatchResource: AppServiceCertificatePatchResource,
    ReissueCertificateOrderRequest: ReissueCertificateOrderRequest,
    RenewCertificateOrderRequest: RenewCertificateOrderRequest,
    DetectorResponse: DetectorResponse,
    DomainPatchResource: DomainPatchResource,
    DomainOwnershipIdentifier: DomainOwnershipIdentifier,
    TopLevelDomain: TopLevelDomain,
    CustomDnsSuffixConfiguration: CustomDnsSuffixConfiguration,
    AseV3NetworkingConfiguration: AseV3NetworkingConfiguration,
    AppServiceEnvironmentPatchResource: AppServiceEnvironmentPatchResource,
    AddressResponse: AddressResponse,
    PushSettings: PushSettings,
    WorkerPoolResource: WorkerPoolResource,
    ResourceMetricDefinition: ResourceMetricDefinition,
    Usage: Usage,
    RemotePrivateEndpointConnectionARMResource: RemotePrivateEndpointConnectionARMResource,
    PrivateLinkConnectionApprovalRequestResource: PrivateLinkConnectionApprovalRequestResource,
    AppServicePlanPatchResource: AppServicePlanPatchResource,
    HybridConnection: HybridConnection,
    HybridConnectionKey: HybridConnectionKey,
    HybridConnectionLimits: HybridConnectionLimits,
    VnetRoute: VnetRoute,
    VnetInfoResource: VnetInfoResource,
    VnetGateway: VnetGateway,
    CertificatePatchResource: CertificatePatchResource,
    DeletedSite: DeletedSite,
    DiagnosticCategory: DiagnosticCategory,
    AnalysisDefinition: AnalysisDefinition,
    DiagnosticAnalysis: DiagnosticAnalysis,
    DetectorDefinitionResource: DetectorDefinitionResource,
    DiagnosticDetectorResponse: DiagnosticDetectorResponse,
    Snapshot: Snapshot,
    KubeEnvironmentPatchResource: KubeEnvironmentPatchResource,
    ApplicationStackResource: ApplicationStackResource,
    FunctionAppStack: FunctionAppStack,
    WebAppStack: WebAppStack,
    Recommendation: Recommendation,
    RecommendationRule: RecommendationRule,
    ResourceHealthMetadata: ResourceHealthMetadata,
    User: User,
    SourceControl: SourceControl,
    BillingMeter: BillingMeter,
    Identifier: Identifier,
    CustomHostnameSites: CustomHostnameSites,
    GeoRegion: GeoRegion,
    PremierAddOnOffer: PremierAddOnOffer,
    VnetParameters: VnetParameters,
    VnetValidationTestFailure: VnetValidationTestFailure,
    VnetValidationFailureDetails: VnetValidationFailureDetails,
    StaticSitesWorkflowPreviewRequest: StaticSitesWorkflowPreviewRequest,
    StaticSitesWorkflowPreview: StaticSitesWorkflowPreview,
    RemotePrivateEndpointConnection: RemotePrivateEndpointConnection,
    StaticSiteUserProvidedFunctionApp: StaticSiteUserProvidedFunctionApp,
    StaticSitePatchResource: StaticSitePatchResource,
    StaticSiteUserARMResource: StaticSiteUserARMResource,
    StaticSiteBuildARMResource: StaticSiteBuildARMResource,
    StringDictionary: StringDictionary,
    StaticSiteFunctionOverviewARMResource: StaticSiteFunctionOverviewARMResource,
    StaticSiteUserProvidedFunctionAppARMResource: StaticSiteUserProvidedFunctionAppARMResource,
    StaticSiteZipDeploymentARMResource: StaticSiteZipDeploymentARMResource,
    StaticSiteUserInvitationRequestResource: StaticSiteUserInvitationRequestResource,
    StaticSiteUserInvitationResponseResource: StaticSiteUserInvitationResponseResource,
    StaticSiteCustomDomainOverviewARMResource: StaticSiteCustomDomainOverviewARMResource,
    StaticSiteCustomDomainRequestPropertiesARMResource: StaticSiteCustomDomainRequestPropertiesARMResource,
    StringList: StringList,
    StaticSiteResetPropertiesARMResource: StaticSiteResetPropertiesARMResource,
    StaticSiteLinkedBackendARMResource: StaticSiteLinkedBackendARMResource,
    SitePatchResource: SitePatchResource,
    CustomHostnameAnalysisResult: CustomHostnameAnalysisResult,
    BackupRequest: BackupRequest,
    BackupItem: BackupItem,
    RestoreRequest: RestoreRequest,
    CsmPublishingCredentialsPoliciesEntity: CsmPublishingCredentialsPoliciesEntity,
    SiteConfigResource: SiteConfigResource,
    SiteAuthSettings: SiteAuthSettings,
    SiteAuthSettingsV2: SiteAuthSettingsV2,
    AzureStoragePropertyDictionaryResource: AzureStoragePropertyDictionaryResource,
    ApiKVReference: ApiKVReference,
    ConnectionStringDictionary: ConnectionStringDictionary,
    SiteLogsConfig: SiteLogsConfig,
    SlotConfigNamesResource: SlotConfigNamesResource,
    SiteConfigurationSnapshotInfo: SiteConfigurationSnapshotInfo,
    ContinuousWebJob: ContinuousWebJob,
    CsmDeploymentStatus: CsmDeploymentStatus,
    Deployment: Deployment,
    MSDeployStatus: MSDeployStatus,
    MSDeploy: MSDeploy,
    MSDeployLog: MSDeployLog,
    FunctionEnvelope: FunctionEnvelope,
    HostNameBinding: HostNameBinding,
    RelayServiceConnectionEntity: RelayServiceConnectionEntity,
    WebSiteInstanceStatus: WebSiteInstanceStatus,
    ProcessThreadInfo: ProcessThreadInfo,
    ProcessModuleInfo: ProcessModuleInfo,
    ProcessInfo: ProcessInfo,
    StorageMigrationOptions: StorageMigrationOptions,
    StorageMigrationResponse: StorageMigrationResponse,
    MigrateMySqlRequest: MigrateMySqlRequest,
    MigrateMySqlStatus: MigrateMySqlStatus,
    SwiftVirtualNetwork: SwiftVirtualNetwork,
    NetworkFeatures: NetworkFeatures,
    SitePhpErrorLogFlag: SitePhpErrorLogFlag,
    PremierAddOnPatchResource: PremierAddOnPatchResource,
    PrivateAccess: PrivateAccess,
    PublicCertificate: PublicCertificate,
    DeletedAppRestoreRequest: DeletedAppRestoreRequest,
    SnapshotRestoreRequest: SnapshotRestoreRequest,
    SiteExtensionInfo: SiteExtensionInfo,
    SlotDifference: SlotDifference,
    SiteSourceControl: SiteSourceControl,
    TriggeredWebJob: TriggeredWebJob,
    TriggeredJobHistory: TriggeredJobHistory,
    WebJob: WebJob,
    WorkflowOutputParameter: WorkflowOutputParameter,
    WorkflowRun: WorkflowRun,
    WorkflowRunAction: WorkflowRunAction,
    WorkflowTrigger: WorkflowTrigger,
    WorkflowTriggerHistory: WorkflowTriggerHistory,
    RunActionCorrelation: RunActionCorrelation,
    ExpressionRoot: ExpressionRoot,
    AzureResourceErrorInfo: AzureResourceErrorInfo,
    OperationResult: OperationResult,
    WorkflowRunActionRepetitionDefinition: WorkflowRunActionRepetitionDefinition,
    RequestHistory: RequestHistory,
    Workflow: Workflow,
    WorkflowVersion: WorkflowVersion,
    WorkflowRunActionRepetitionProperties: WorkflowRunActionRepetitionProperties
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        xmlName: "$host",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        xmlName: "subscriptionId",
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-03-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const appServiceCertificateOrder = {
    parameterPath: "appServiceCertificateOrder",
    mapper: AppServiceCertificateOrder
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+[^\\.]$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        xmlName: "resourceGroupName",
        type: {
            name: "String"
        }
    }
};
const certificateOrderName = {
    parameterPath: "certificateOrderName",
    mapper: {
        serializedName: "certificateOrderName",
        required: true,
        xmlName: "certificateOrderName",
        type: {
            name: "String"
        }
    }
};
const certificateDistinguishedName = {
    parameterPath: "certificateDistinguishedName",
    mapper: AppServiceCertificateOrder
};
const certificateDistinguishedName1 = {
    parameterPath: "certificateDistinguishedName",
    mapper: AppServiceCertificateOrderPatchResource
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        xmlName: "name",
        type: {
            name: "String"
        }
    }
};
const keyVaultCertificate = {
    parameterPath: "keyVaultCertificate",
    mapper: AppServiceCertificateResource
};
const keyVaultCertificate1 = {
    parameterPath: "keyVaultCertificate",
    mapper: AppServiceCertificatePatchResource
};
const reissueCertificateOrderRequest = {
    parameterPath: "reissueCertificateOrderRequest",
    mapper: ReissueCertificateOrderRequest
};
const renewCertificateOrderRequest = {
    parameterPath: "renewCertificateOrderRequest",
    mapper: RenewCertificateOrderRequest
};
const nameIdentifier = {
    parameterPath: "nameIdentifier",
    mapper: NameIdentifier
};
const siteSealRequest = {
    parameterPath: "siteSealRequest",
    mapper: SiteSealRequest
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        xmlName: "nextLink",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const detectorName = {
    parameterPath: "detectorName",
    mapper: {
        serializedName: "detectorName",
        required: true,
        xmlName: "detectorName",
        type: {
            name: "String"
        }
    }
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        xmlName: "startTime",
        type: {
            name: "DateTime"
        }
    }
};
const endTime = {
    parameterPath: ["options", "endTime"],
    mapper: {
        serializedName: "endTime",
        xmlName: "endTime",
        type: {
            name: "DateTime"
        }
    }
};
const timeGrain = {
    parameterPath: ["options", "timeGrain"],
    mapper: {
        constraints: {
            Pattern: new RegExp("PT[1-9][0-9]+[SMH]")
        },
        serializedName: "timeGrain",
        xmlName: "timeGrain",
        type: {
            name: "String"
        }
    }
};
const identifier = {
    parameterPath: "identifier",
    mapper: NameIdentifier
};
const parameters = {
    parameterPath: "parameters",
    mapper: DomainRecommendationSearchParameters
};
const domainName = {
    parameterPath: "domainName",
    mapper: {
        serializedName: "domainName",
        required: true,
        xmlName: "domainName",
        type: {
            name: "String"
        }
    }
};
const domain = {
    parameterPath: "domain",
    mapper: Domain
};
const domainName1 = {
    parameterPath: "domainName",
    mapper: {
        constraints: {
            Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9\\.-]+")
        },
        serializedName: "domainName",
        required: true,
        xmlName: "domainName",
        type: {
            name: "String"
        }
    }
};
const forceHardDeleteDomain = {
    parameterPath: ["options", "forceHardDeleteDomain"],
    mapper: {
        serializedName: "forceHardDeleteDomain",
        xmlName: "forceHardDeleteDomain",
        type: {
            name: "Boolean"
        }
    }
};
const domain1 = {
    parameterPath: "domain",
    mapper: DomainPatchResource
};
const domainOwnershipIdentifier = {
    parameterPath: "domainOwnershipIdentifier",
    mapper: DomainOwnershipIdentifier
};
const agreementOption = {
    parameterPath: "agreementOption",
    mapper: TopLevelDomainAgreementOption
};
const hostingEnvironmentEnvelope = {
    parameterPath: "hostingEnvironmentEnvelope",
    mapper: AppServiceEnvironmentResource
};
const forceDelete = {
    parameterPath: ["options", "forceDelete"],
    mapper: {
        serializedName: "forceDelete",
        xmlName: "forceDelete",
        type: {
            name: "Boolean"
        }
    }
};
const hostingEnvironmentEnvelope1 = {
    parameterPath: "hostingEnvironmentEnvelope",
    mapper: AppServiceEnvironmentPatchResource
};
const vnetInfo = {
    parameterPath: "vnetInfo",
    mapper: VirtualNetworkProfile
};
const customDnsSuffixConfiguration = {
    parameterPath: "customDnsSuffixConfiguration",
    mapper: CustomDnsSuffixConfiguration
};
const aseNetworkingConfiguration = {
    parameterPath: "aseNetworkingConfiguration",
    mapper: AseV3NetworkingConfiguration
};
const diagnosticsName = {
    parameterPath: "diagnosticsName",
    mapper: {
        serializedName: "diagnosticsName",
        required: true,
        xmlName: "diagnosticsName",
        type: {
            name: "String"
        }
    }
};
const multiRolePoolEnvelope = {
    parameterPath: "multiRolePoolEnvelope",
    mapper: WorkerPoolResource
};
const instance = {
    parameterPath: "instance",
    mapper: {
        serializedName: "instance",
        required: true,
        xmlName: "instance",
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        xmlName: "privateEndpointConnectionName",
        type: {
            name: "String"
        }
    }
};
const privateEndpointWrapper = {
    parameterPath: "privateEndpointWrapper",
    mapper: PrivateLinkConnectionApprovalRequestResource
};
const propertiesToInclude = {
    parameterPath: ["options", "propertiesToInclude"],
    mapper: {
        serializedName: "propertiesToInclude",
        xmlName: "propertiesToInclude",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        xmlName: "$filter",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const workerPoolName = {
    parameterPath: "workerPoolName",
    mapper: {
        serializedName: "workerPoolName",
        required: true,
        xmlName: "workerPoolName",
        type: {
            name: "String"
        }
    }
};
const workerPoolEnvelope = {
    parameterPath: "workerPoolEnvelope",
    mapper: WorkerPoolResource
};
const detailed = {
    parameterPath: ["options", "detailed"],
    mapper: {
        serializedName: "detailed",
        xmlName: "detailed",
        type: {
            name: "Boolean"
        }
    }
};
const appServicePlan = {
    parameterPath: "appServicePlan",
    mapper: AppServicePlan
};
const appServicePlan1 = {
    parameterPath: "appServicePlan",
    mapper: AppServicePlanPatchResource
};
const namespaceName = {
    parameterPath: "namespaceName",
    mapper: {
        serializedName: "namespaceName",
        required: true,
        xmlName: "namespaceName",
        type: {
            name: "String"
        }
    }
};
const relayName = {
    parameterPath: "relayName",
    mapper: {
        serializedName: "relayName",
        required: true,
        xmlName: "relayName",
        type: {
            name: "String"
        }
    }
};
const softRestart = {
    parameterPath: ["options", "softRestart"],
    mapper: {
        serializedName: "softRestart",
        xmlName: "softRestart",
        type: {
            name: "Boolean"
        }
    }
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        xmlName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        xmlName: "$top",
        type: {
            name: "String"
        }
    }
};
const vnetName = {
    parameterPath: "vnetName",
    mapper: {
        serializedName: "vnetName",
        required: true,
        xmlName: "vnetName",
        type: {
            name: "String"
        }
    }
};
const gatewayName = {
    parameterPath: "gatewayName",
    mapper: {
        serializedName: "gatewayName",
        required: true,
        xmlName: "gatewayName",
        type: {
            name: "String"
        }
    }
};
const connectionEnvelope = {
    parameterPath: "connectionEnvelope",
    mapper: VnetGateway
};
const routeName = {
    parameterPath: "routeName",
    mapper: {
        serializedName: "routeName",
        required: true,
        xmlName: "routeName",
        type: {
            name: "String"
        }
    }
};
const route = {
    parameterPath: "route",
    mapper: VnetRoute
};
const workerName = {
    parameterPath: "workerName",
    mapper: {
        serializedName: "workerName",
        required: true,
        xmlName: "workerName",
        type: {
            name: "String"
        }
    }
};
const certificateEnvelope = {
    parameterPath: "certificateEnvelope",
    mapper: Certificate
};
const certificateEnvelope1 = {
    parameterPath: "certificateEnvelope",
    mapper: CertificatePatchResource
};
const containerAppEnvelope = {
    parameterPath: "containerAppEnvelope",
    mapper: ContainerApp
};
const containerAppName = {
    parameterPath: "containerAppName",
    mapper: {
        serializedName: "containerAppName",
        required: true,
        xmlName: "containerAppName",
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        xmlName: "location",
        type: {
            name: "String"
        }
    }
};
const deletedSiteId = {
    parameterPath: "deletedSiteId",
    mapper: {
        serializedName: "deletedSiteId",
        required: true,
        xmlName: "deletedSiteId",
        type: {
            name: "String"
        }
    }
};
const siteName = {
    parameterPath: "siteName",
    mapper: {
        serializedName: "siteName",
        required: true,
        xmlName: "siteName",
        type: {
            name: "String"
        }
    }
};
const diagnosticCategory = {
    parameterPath: "diagnosticCategory",
    mapper: {
        serializedName: "diagnosticCategory",
        required: true,
        xmlName: "diagnosticCategory",
        type: {
            name: "String"
        }
    }
};
const analysisName = {
    parameterPath: "analysisName",
    mapper: {
        serializedName: "analysisName",
        required: true,
        xmlName: "analysisName",
        type: {
            name: "String"
        }
    }
};
const slot = {
    parameterPath: "slot",
    mapper: {
        serializedName: "slot",
        required: true,
        xmlName: "slot",
        type: {
            name: "String"
        }
    }
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        xmlName: "operationId",
        type: {
            name: "String"
        }
    }
};
const kubeEnvironmentEnvelope = {
    parameterPath: "kubeEnvironmentEnvelope",
    mapper: KubeEnvironment
};
const kubeEnvironmentEnvelope1 = {
    parameterPath: "kubeEnvironmentEnvelope",
    mapper: KubeEnvironmentPatchResource
};
const osTypeSelected = {
    parameterPath: ["options", "osTypeSelected"],
    mapper: {
        serializedName: "osTypeSelected",
        xmlName: "osTypeSelected",
        type: {
            name: "String"
        }
    }
};
const stackOsType = {
    parameterPath: ["options", "stackOsType"],
    mapper: {
        serializedName: "stackOsType",
        xmlName: "stackOsType",
        type: {
            name: "String"
        }
    }
};
const stackOsType1 = {
    parameterPath: ["options", "stackOsType"],
    mapper: {
        serializedName: "stackOsType",
        xmlName: "stackOsType",
        type: {
            name: "String"
        }
    }
};
const stackOsType2 = {
    parameterPath: ["options", "stackOsType"],
    mapper: {
        serializedName: "stackOsType",
        xmlName: "stackOsType",
        type: {
            name: "String"
        }
    }
};
const stackOsType3 = {
    parameterPath: ["options", "stackOsType"],
    mapper: {
        serializedName: "stackOsType",
        xmlName: "stackOsType",
        type: {
            name: "String"
        }
    }
};
const osTypeSelected1 = {
    parameterPath: ["options", "osTypeSelected"],
    mapper: {
        serializedName: "osTypeSelected",
        xmlName: "osTypeSelected",
        type: {
            name: "String"
        }
    }
};
const featured = {
    parameterPath: ["options", "featured"],
    mapper: {
        serializedName: "featured",
        xmlName: "featured",
        type: {
            name: "Boolean"
        }
    }
};
const hostingEnvironmentName = {
    parameterPath: "hostingEnvironmentName",
    mapper: {
        serializedName: "hostingEnvironmentName",
        required: true,
        xmlName: "hostingEnvironmentName",
        type: {
            name: "String"
        }
    }
};
const expiredOnly = {
    parameterPath: ["options", "expiredOnly"],
    mapper: {
        serializedName: "expiredOnly",
        xmlName: "expiredOnly",
        type: {
            name: "Boolean"
        }
    }
};
const environmentName = {
    parameterPath: "environmentName",
    mapper: {
        serializedName: "environmentName",
        required: true,
        xmlName: "environmentName",
        type: {
            name: "String"
        }
    }
};
const updateSeen = {
    parameterPath: ["options", "updateSeen"],
    mapper: {
        serializedName: "updateSeen",
        xmlName: "updateSeen",
        type: {
            name: "Boolean"
        }
    }
};
const recommendationId = {
    parameterPath: ["options", "recommendationId"],
    mapper: {
        serializedName: "recommendationId",
        xmlName: "recommendationId",
        type: {
            name: "String"
        }
    }
};
const userDetails = {
    parameterPath: "userDetails",
    mapper: User
};
const sourceControlType = {
    parameterPath: "sourceControlType",
    mapper: {
        serializedName: "sourceControlType",
        required: true,
        xmlName: "sourceControlType",
        type: {
            name: "String"
        }
    }
};
const requestMessage = {
    parameterPath: "requestMessage",
    mapper: SourceControl
};
const billingLocation = {
    parameterPath: ["options", "billingLocation"],
    mapper: {
        serializedName: "billingLocation",
        xmlName: "billingLocation",
        type: {
            name: "String"
        }
    }
};
const osType = {
    parameterPath: ["options", "osType"],
    mapper: {
        serializedName: "osType",
        xmlName: "osType",
        type: {
            name: "String"
        }
    }
};
const hostname = {
    parameterPath: ["options", "hostname"],
    mapper: {
        serializedName: "hostname",
        xmlName: "hostname",
        type: {
            name: "String"
        }
    }
};
const sku = {
    parameterPath: ["options", "sku"],
    mapper: {
        serializedName: "sku",
        xmlName: "sku",
        type: {
            name: "String"
        }
    }
};
const linuxWorkersEnabled = {
    parameterPath: ["options", "linuxWorkersEnabled"],
    mapper: {
        serializedName: "linuxWorkersEnabled",
        xmlName: "linuxWorkersEnabled",
        type: {
            name: "Boolean"
        }
    }
};
const xenonWorkersEnabled = {
    parameterPath: ["options", "xenonWorkersEnabled"],
    mapper: {
        serializedName: "xenonWorkersEnabled",
        xmlName: "xenonWorkersEnabled",
        type: {
            name: "Boolean"
        }
    }
};
const linuxDynamicWorkersEnabled = {
    parameterPath: ["options", "linuxDynamicWorkersEnabled"],
    mapper: {
        serializedName: "linuxDynamicWorkersEnabled",
        xmlName: "linuxDynamicWorkersEnabled",
        type: {
            name: "Boolean"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: VnetParameters
};
const moveResourceEnvelope = {
    parameterPath: "moveResourceEnvelope",
    mapper: CsmMoveResourceEnvelope
};
const validateRequest = {
    parameterPath: "validateRequest",
    mapper: ValidateRequest
};
const staticSitesWorkflowPreviewRequest = {
    parameterPath: "staticSitesWorkflowPreviewRequest",
    mapper: StaticSitesWorkflowPreviewRequest
};
const staticSiteEnvelope = {
    parameterPath: "staticSiteEnvelope",
    mapper: StaticSiteARMResource
};
const staticSiteEnvelope1 = {
    parameterPath: "staticSiteEnvelope",
    mapper: StaticSitePatchResource
};
const authprovider = {
    parameterPath: "authprovider",
    mapper: {
        serializedName: "authprovider",
        required: true,
        xmlName: "authprovider",
        type: {
            name: "String"
        }
    }
};
const userid = {
    parameterPath: "userid",
    mapper: {
        serializedName: "userid",
        required: true,
        xmlName: "userid",
        type: {
            name: "String"
        }
    }
};
const staticSiteUserEnvelope = {
    parameterPath: "staticSiteUserEnvelope",
    mapper: StaticSiteUserARMResource
};
const environmentName1 = {
    parameterPath: "environmentName",
    mapper: {
        serializedName: "environmentName",
        required: true,
        xmlName: "environmentName",
        type: {
            name: "String"
        }
    }
};
const appSettings = {
    parameterPath: "appSettings",
    mapper: StringDictionary
};
const functionAppName = {
    parameterPath: "functionAppName",
    mapper: {
        serializedName: "functionAppName",
        required: true,
        xmlName: "functionAppName",
        type: {
            name: "String"
        }
    }
};
const staticSiteUserProvidedFunctionEnvelope = {
    parameterPath: "staticSiteUserProvidedFunctionEnvelope",
    mapper: StaticSiteUserProvidedFunctionAppARMResource
};
const isForced = {
    parameterPath: ["options", "isForced"],
    mapper: {
        serializedName: "isForced",
        xmlName: "isForced",
        type: {
            name: "Boolean"
        }
    }
};
const staticSiteZipDeploymentEnvelope = {
    parameterPath: "staticSiteZipDeploymentEnvelope",
    mapper: StaticSiteZipDeploymentARMResource
};
const staticSiteUserRolesInvitationEnvelope = {
    parameterPath: "staticSiteUserRolesInvitationEnvelope",
    mapper: StaticSiteUserInvitationRequestResource
};
const staticSiteCustomDomainRequestPropertiesEnvelope = {
    parameterPath: "staticSiteCustomDomainRequestPropertiesEnvelope",
    mapper: StaticSiteCustomDomainRequestPropertiesARMResource
};
const resetPropertiesEnvelope = {
    parameterPath: "resetPropertiesEnvelope",
    mapper: StaticSiteResetPropertiesARMResource
};
const staticSiteLinkedBackendEnvelope = {
    parameterPath: "staticSiteLinkedBackendEnvelope",
    mapper: StaticSiteLinkedBackendARMResource
};
const linkedBackendName = {
    parameterPath: "linkedBackendName",
    mapper: {
        serializedName: "linkedBackendName",
        required: true,
        xmlName: "linkedBackendName",
        type: {
            name: "String"
        }
    }
};
const isCleaningAuthConfig = {
    parameterPath: ["options", "isCleaningAuthConfig"],
    mapper: {
        serializedName: "isCleaningAuthConfig",
        xmlName: "isCleaningAuthConfig",
        type: {
            name: "Boolean"
        }
    }
};
const includeSlots = {
    parameterPath: ["options", "includeSlots"],
    mapper: {
        serializedName: "includeSlots",
        xmlName: "includeSlots",
        type: {
            name: "Boolean"
        }
    }
};
const siteEnvelope = {
    parameterPath: "siteEnvelope",
    mapper: Site
};
const deleteMetrics = {
    parameterPath: ["options", "deleteMetrics"],
    mapper: {
        serializedName: "deleteMetrics",
        xmlName: "deleteMetrics",
        type: {
            name: "Boolean"
        }
    }
};
const deleteEmptyServerFarm = {
    parameterPath: ["options", "deleteEmptyServerFarm"],
    mapper: {
        serializedName: "deleteEmptyServerFarm",
        xmlName: "deleteEmptyServerFarm",
        type: {
            name: "Boolean"
        }
    }
};
const siteEnvelope1 = {
    parameterPath: "siteEnvelope",
    mapper: SitePatchResource
};
const hostName = {
    parameterPath: ["options", "hostName"],
    mapper: {
        serializedName: "hostName",
        xmlName: "hostName",
        type: {
            name: "String"
        }
    }
};
const slotSwapEntity = {
    parameterPath: "slotSwapEntity",
    mapper: CsmSlotEntity
};
const request1 = {
    parameterPath: "request",
    mapper: BackupRequest
};
const backupId = {
    parameterPath: "backupId",
    mapper: {
        serializedName: "backupId",
        required: true,
        xmlName: "backupId",
        type: {
            name: "String"
        }
    }
};
const request2 = {
    parameterPath: "request",
    mapper: RestoreRequest
};
const csmPublishingAccessPoliciesEntity = {
    parameterPath: "csmPublishingAccessPoliciesEntity",
    mapper: CsmPublishingCredentialsPoliciesEntity
};
const siteAuthSettings = {
    parameterPath: "siteAuthSettings",
    mapper: SiteAuthSettings
};
const siteAuthSettingsV2 = {
    parameterPath: "siteAuthSettingsV2",
    mapper: SiteAuthSettingsV2
};
const azureStorageAccounts = {
    parameterPath: "azureStorageAccounts",
    mapper: AzureStoragePropertyDictionaryResource
};
const appSettingKey = {
    parameterPath: "appSettingKey",
    mapper: {
        serializedName: "appSettingKey",
        required: true,
        xmlName: "appSettingKey",
        type: {
            name: "String"
        }
    }
};
const connectionStringKey = {
    parameterPath: "connectionStringKey",
    mapper: {
        serializedName: "connectionStringKey",
        required: true,
        xmlName: "connectionStringKey",
        type: {
            name: "String"
        }
    }
};
const connectionStrings = {
    parameterPath: "connectionStrings",
    mapper: ConnectionStringDictionary
};
const siteLogsConfig = {
    parameterPath: "siteLogsConfig",
    mapper: SiteLogsConfig
};
const metadata = {
    parameterPath: "metadata",
    mapper: StringDictionary
};
const pushSettings = {
    parameterPath: "pushSettings",
    mapper: PushSettings
};
const slotConfigNames = {
    parameterPath: "slotConfigNames",
    mapper: SlotConfigNamesResource
};
const siteConfig = {
    parameterPath: "siteConfig",
    mapper: SiteConfigResource
};
const snapshotId = {
    parameterPath: "snapshotId",
    mapper: {
        serializedName: "snapshotId",
        required: true,
        xmlName: "snapshotId",
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/zip",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const webJobName = {
    parameterPath: "webJobName",
    mapper: {
        serializedName: "webJobName",
        required: true,
        xmlName: "webJobName",
        type: {
            name: "String"
        }
    }
};
const deploymentStatusId = {
    parameterPath: "deploymentStatusId",
    mapper: {
        serializedName: "deploymentStatusId",
        required: true,
        xmlName: "deploymentStatusId",
        type: {
            name: "String"
        }
    }
};
const id = {
    parameterPath: "id",
    mapper: {
        serializedName: "id",
        required: true,
        xmlName: "id",
        type: {
            name: "String"
        }
    }
};
const deployment = {
    parameterPath: "deployment",
    mapper: Deployment
};
const domainOwnershipIdentifierName = {
    parameterPath: "domainOwnershipIdentifierName",
    mapper: {
        serializedName: "domainOwnershipIdentifierName",
        required: true,
        xmlName: "domainOwnershipIdentifierName",
        type: {
            name: "String"
        }
    }
};
const domainOwnershipIdentifier1 = {
    parameterPath: "domainOwnershipIdentifier",
    mapper: Identifier
};
const mSDeploy = {
    parameterPath: "mSDeploy",
    mapper: MSDeploy
};
const functionName = {
    parameterPath: "functionName",
    mapper: {
        serializedName: "functionName",
        required: true,
        xmlName: "functionName",
        type: {
            name: "String"
        }
    }
};
const functionEnvelope = {
    parameterPath: "functionEnvelope",
    mapper: FunctionEnvelope
};
const key = {
    parameterPath: "key",
    mapper: KeyInfo
};
const keyName = {
    parameterPath: "keyName",
    mapper: {
        serializedName: "keyName",
        required: true,
        xmlName: "keyName",
        type: {
            name: "String"
        }
    }
};
const keyType = {
    parameterPath: "keyType",
    mapper: {
        serializedName: "keyType",
        required: true,
        xmlName: "keyType",
        type: {
            name: "String"
        }
    }
};
const hostName1 = {
    parameterPath: "hostName",
    mapper: {
        serializedName: "hostName",
        required: true,
        xmlName: "hostName",
        type: {
            name: "String"
        }
    }
};
const hostNameBinding = {
    parameterPath: "hostNameBinding",
    mapper: HostNameBinding
};
const connectionEnvelope1 = {
    parameterPath: "connectionEnvelope",
    mapper: HybridConnection
};
const entityName = {
    parameterPath: "entityName",
    mapper: {
        serializedName: "entityName",
        required: true,
        xmlName: "entityName",
        type: {
            name: "String"
        }
    }
};
const connectionEnvelope2 = {
    parameterPath: "connectionEnvelope",
    mapper: RelayServiceConnectionEntity
};
const instanceId = {
    parameterPath: "instanceId",
    mapper: {
        serializedName: "instanceId",
        required: true,
        xmlName: "instanceId",
        type: {
            name: "String"
        }
    }
};
const processId = {
    parameterPath: "processId",
    mapper: {
        serializedName: "processId",
        required: true,
        xmlName: "processId",
        type: {
            name: "String"
        }
    }
};
const baseAddress = {
    parameterPath: "baseAddress",
    mapper: {
        serializedName: "baseAddress",
        required: true,
        xmlName: "baseAddress",
        type: {
            name: "String"
        }
    }
};
const migrationOptions = {
    parameterPath: "migrationOptions",
    mapper: StorageMigrationOptions
};
const subscriptionName = {
    parameterPath: "subscriptionName",
    mapper: {
        serializedName: "subscriptionName",
        required: true,
        xmlName: "subscriptionName",
        type: {
            name: "String"
        }
    }
};
const migrationRequestEnvelope = {
    parameterPath: "migrationRequestEnvelope",
    mapper: MigrateMySqlRequest
};
const connectionEnvelope3 = {
    parameterPath: "connectionEnvelope",
    mapper: SwiftVirtualNetwork
};
const view = {
    parameterPath: "view",
    mapper: {
        serializedName: "view",
        required: true,
        xmlName: "view",
        type: {
            name: "String"
        }
    }
};
const durationInSeconds = {
    parameterPath: ["options", "durationInSeconds"],
    mapper: {
        serializedName: "durationInSeconds",
        xmlName: "durationInSeconds",
        type: {
            name: "Number"
        }
    }
};
const maxFrameLength = {
    parameterPath: ["options", "maxFrameLength"],
    mapper: {
        serializedName: "maxFrameLength",
        xmlName: "maxFrameLength",
        type: {
            name: "Number"
        }
    }
};
const sasUrl = {
    parameterPath: ["options", "sasUrl"],
    mapper: {
        serializedName: "sasUrl",
        xmlName: "sasUrl",
        type: {
            name: "String"
        }
    }
};
const premierAddOnName = {
    parameterPath: "premierAddOnName",
    mapper: {
        serializedName: "premierAddOnName",
        required: true,
        xmlName: "premierAddOnName",
        type: {
            name: "String"
        }
    }
};
const premierAddOn = {
    parameterPath: "premierAddOn",
    mapper: PremierAddOn
};
const premierAddOn1 = {
    parameterPath: "premierAddOn",
    mapper: PremierAddOnPatchResource
};
const access = {
    parameterPath: "access",
    mapper: PrivateAccess
};
const publicCertificateName = {
    parameterPath: "publicCertificateName",
    mapper: {
        serializedName: "publicCertificateName",
        required: true,
        xmlName: "publicCertificateName",
        type: {
            name: "String"
        }
    }
};
const publicCertificate = {
    parameterPath: "publicCertificate",
    mapper: PublicCertificate
};
const publishingProfileOptions = {
    parameterPath: "publishingProfileOptions",
    mapper: CsmPublishingProfileOptions
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const synchronous = {
    parameterPath: ["options", "synchronous"],
    mapper: {
        serializedName: "synchronous",
        xmlName: "synchronous",
        type: {
            name: "Boolean"
        }
    }
};
const restoreRequest = {
    parameterPath: "restoreRequest",
    mapper: DeletedAppRestoreRequest
};
const restoreRequest1 = {
    parameterPath: "restoreRequest",
    mapper: SnapshotRestoreRequest
};
const siteExtensionId = {
    parameterPath: "siteExtensionId",
    mapper: {
        serializedName: "siteExtensionId",
        required: true,
        xmlName: "siteExtensionId",
        type: {
            name: "String"
        }
    }
};
const siteSourceControl = {
    parameterPath: "siteSourceControl",
    mapper: SiteSourceControl
};
const additionalFlags = {
    parameterPath: ["options", "additionalFlags"],
    mapper: {
        serializedName: "additionalFlags",
        xmlName: "additionalFlags",
        type: {
            name: "String"
        }
    }
};
const connectionEnvelope4 = {
    parameterPath: "connectionEnvelope",
    mapper: VnetInfoResource
};
const keyType1 = {
    parameterPath: "keyType",
    mapper: RegenerateActionParameter
};
const workflowName = {
    parameterPath: "workflowName",
    mapper: {
        serializedName: "workflowName",
        required: true,
        xmlName: "workflowName",
        type: {
            name: "String"
        }
    }
};
const validate = {
    parameterPath: "validate",
    mapper: Workflow
};
const top1 = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        xmlName: "$top",
        type: {
            name: "Number"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        xmlName: "$filter",
        type: {
            name: "String"
        }
    }
};
const runName = {
    parameterPath: "runName",
    mapper: {
        serializedName: "runName",
        required: true,
        xmlName: "runName",
        type: {
            name: "String"
        }
    }
};
const actionName = {
    parameterPath: "actionName",
    mapper: {
        serializedName: "actionName",
        required: true,
        xmlName: "actionName",
        type: {
            name: "String"
        }
    }
};
const repetitionName = {
    parameterPath: "repetitionName",
    mapper: {
        serializedName: "repetitionName",
        required: true,
        xmlName: "repetitionName",
        type: {
            name: "String"
        }
    }
};
const requestHistoryName = {
    parameterPath: "requestHistoryName",
    mapper: {
        serializedName: "requestHistoryName",
        required: true,
        xmlName: "requestHistoryName",
        type: {
            name: "String"
        }
    }
};
const triggerName = {
    parameterPath: "triggerName",
    mapper: {
        serializedName: "triggerName",
        required: true,
        xmlName: "triggerName",
        type: {
            name: "String"
        }
    }
};
const historyName = {
    parameterPath: "historyName",
    mapper: {
        serializedName: "historyName",
        required: true,
        xmlName: "historyName",
        type: {
            name: "String"
        }
    }
};
const versionId = {
    parameterPath: "versionId",
    mapper: {
        serializedName: "versionId",
        required: true,
        xmlName: "versionId",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AppServiceCertificateOrders operations. */
class AppServiceCertificateOrdersImpl {
    /**
     * Initialize a new instance of the class AppServiceCertificateOrders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List all certificate orders in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get certificate orders in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for List all certificates associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    listCertificates(resourceGroupName, certificateOrderName, options) {
        const iter = this.listCertificatesPagingAll(resourceGroupName, certificateOrderName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCertificatesPagingPage(resourceGroupName, certificateOrderName, options);
            }
        };
    }
    listCertificatesPagingPage(resourceGroupName, certificateOrderName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCertificatesPagingPage_1() {
            let result = yield tslib.__await(this._listCertificates(resourceGroupName, certificateOrderName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCertificatesNext(resourceGroupName, certificateOrderName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCertificatesPagingAll(resourceGroupName, certificateOrderName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCertificatesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCertificatesPagingPage(resourceGroupName, certificateOrderName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for List all certificate orders in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$i);
    }
    /**
     * Description for Validate information for a certificate order.
     * @param appServiceCertificateOrder Information for a certificate order.
     * @param options The options parameters.
     */
    validatePurchaseInformation(appServiceCertificateOrder, options) {
        return this.client.sendOperationRequest({ appServiceCertificateOrder, options }, validatePurchaseInformationOperationSpec);
    }
    /**
     * Description for Get certificate orders in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$8);
    }
    /**
     * Description for Get a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order..
     * @param options The options parameters.
     */
    get(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, getOperationSpec$g);
    }
    /**
     * Description for Create or update a certificate purchase order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param certificateDistinguishedName Distinguished name to use for the certificate order.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, certificateOrderName, certificateDistinguishedName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                certificateOrderName,
                certificateDistinguishedName,
                options
            }, createOrUpdateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a certificate purchase order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param certificateDistinguishedName Distinguished name to use for the certificate order.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, certificateOrderName, certificateDistinguishedName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, certificateOrderName, certificateDistinguishedName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete an existing certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    delete(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, deleteOperationSpec$7);
    }
    /**
     * Description for Create or update a certificate purchase order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param certificateDistinguishedName Distinguished name to use for the certificate order.
     * @param options The options parameters.
     */
    update(resourceGroupName, certificateOrderName, certificateDistinguishedName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            certificateDistinguishedName,
            options
        }, updateOperationSpec$6);
    }
    /**
     * Description for List all certificates associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    _listCertificates(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, listCertificatesOperationSpec);
    }
    /**
     * Description for Get the certificate associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    getCertificate(resourceGroupName, certificateOrderName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, name, options }, getCertificateOperationSpec);
    }
    /**
     * Description for Creates or updates a certificate and associates with key vault secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param keyVaultCertificate Key vault certificate resource Id.
     * @param options The options parameters.
     */
    beginCreateOrUpdateCertificate(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                certificateOrderName,
                name,
                keyVaultCertificate,
                options
            }, createOrUpdateCertificateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates a certificate and associates with key vault secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param keyVaultCertificate Key vault certificate resource Id.
     * @param options The options parameters.
     */
    beginCreateOrUpdateCertificateAndWait(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateCertificate(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete the certificate associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    deleteCertificate(resourceGroupName, certificateOrderName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, name, options }, deleteCertificateOperationSpec);
    }
    /**
     * Description for Creates or updates a certificate and associates with key vault secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param keyVaultCertificate Key vault certificate resource Id.
     * @param options The options parameters.
     */
    updateCertificate(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            name,
            keyVaultCertificate,
            options
        }, updateCertificateOperationSpec);
    }
    /**
     * Description for Reissue an existing certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param reissueCertificateOrderRequest Parameters for the reissue.
     * @param options The options parameters.
     */
    reissue(resourceGroupName, certificateOrderName, reissueCertificateOrderRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            reissueCertificateOrderRequest,
            options
        }, reissueOperationSpec);
    }
    /**
     * Description for Renew an existing certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param renewCertificateOrderRequest Renew parameters
     * @param options The options parameters.
     */
    renew(resourceGroupName, certificateOrderName, renewCertificateOrderRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            renewCertificateOrderRequest,
            options
        }, renewOperationSpec$1);
    }
    /**
     * Description for Resend certificate email.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    resendEmail(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, resendEmailOperationSpec);
    }
    /**
     * Resend domain verification ownership email containing steps on how to verify a domain for a given
     * certificate order
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param nameIdentifier Email address
     * @param options The options parameters.
     */
    resendRequestEmails(resourceGroupName, certificateOrderName, nameIdentifier, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, nameIdentifier, options }, resendRequestEmailsOperationSpec);
    }
    /**
     * This method is used to obtain the site seal information for an issued certificate. A site seal is a
     * graphic that the certificate purchaser can embed on their web site to show their visitors
     * information about their SSL certificate. If a web site visitor clicks on the site seal image, a
     * pop-up page is displayed that contains detailed information about the SSL certificate. The site seal
     * token is used to link the site seal graphic image to the appropriate certificate details pop-up page
     * display when a user clicks on the site seal. The site seal images are expected to be static images
     * and hosted by the reseller, to minimize delays for customer page load times.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param siteSealRequest Site seal request.
     * @param options The options parameters.
     */
    retrieveSiteSeal(resourceGroupName, certificateOrderName, siteSealRequest, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, siteSealRequest, options }, retrieveSiteSealOperationSpec);
    }
    /**
     * Description for Verify domain ownership for this certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    verifyDomainOwnership(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, verifyDomainOwnershipOperationSpec);
    }
    /**
     * Description for Retrieve the list of certificate actions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate order.
     * @param options The options parameters.
     */
    retrieveCertificateActions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, retrieveCertificateActionsOperationSpec);
    }
    /**
     * Description for Retrieve email history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate order.
     * @param options The options parameters.
     */
    retrieveCertificateEmailHistory(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, retrieveCertificateEmailHistoryOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$i);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$8);
    }
    /**
     * ListCertificatesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param nextLink The nextLink from the previous successful call to the ListCertificates method.
     * @param options The options parameters.
     */
    _listCertificatesNext(resourceGroupName, certificateOrderName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, nextLink, options }, listCertificatesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.CertificateRegistration/certificateOrders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$t
};
const validatePurchaseInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.CertificateRegistration/validateCertificateRegistrationInformation",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appServiceCertificateOrder,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const listByResourceGroupOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrder
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrder
        },
        201: {
            bodyMapper: AppServiceCertificateOrder
        },
        202: {
            bodyMapper: AppServiceCertificateOrder
        },
        204: {
            bodyMapper: AppServiceCertificateOrder
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateDistinguishedName,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrder
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateDistinguishedName1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const listCertificatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const createOrUpdateCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateResource
        },
        201: {
            bodyMapper: AppServiceCertificateResource
        },
        202: {
            bodyMapper: AppServiceCertificateResource
        },
        204: {
            bodyMapper: AppServiceCertificateResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: keyVaultCertificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const deleteCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const updateCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: keyVaultCertificate1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const reissueOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/reissue",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: reissueCertificateOrderRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const renewOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/renew",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: renewCertificateOrderRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const resendEmailOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/resendEmail",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const resendRequestEmailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/resendRequestEmails",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: nameIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const retrieveSiteSealOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/retrieveSiteSeal",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteSeal
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteSealRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const verifyDomainOwnershipOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/verifyDomainOwnership",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const retrieveCertificateActionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/retrieveCertificateActions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "CertificateOrderAction" }
                    }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const retrieveCertificateEmailHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/retrieveEmailHistory",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "CertificateEmail" }
                    }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listByResourceGroupNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listCertificatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CertificateOrdersDiagnostics operations. */
class CertificateOrdersDiagnosticsImpl {
    /**
     * Initialize a new instance of the class CertificateOrdersDiagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Microsoft.CertificateRegistration to get the list of detectors for this RP.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param options The options parameters.
     */
    listAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, options) {
        const iter = this.listAppServiceCertificateOrderDetectorResponsePagingAll(resourceGroupName, certificateOrderName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAppServiceCertificateOrderDetectorResponsePagingPage(resourceGroupName, certificateOrderName, options);
            }
        };
    }
    listAppServiceCertificateOrderDetectorResponsePagingPage(resourceGroupName, certificateOrderName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServiceCertificateOrderDetectorResponsePagingPage_1() {
            let result = yield tslib.__await(this._listAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAppServiceCertificateOrderDetectorResponseNext(resourceGroupName, certificateOrderName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAppServiceCertificateOrderDetectorResponsePagingAll(resourceGroupName, certificateOrderName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServiceCertificateOrderDetectorResponsePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAppServiceCertificateOrderDetectorResponsePagingPage(resourceGroupName, certificateOrderName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Microsoft.CertificateRegistration to get the list of detectors for this RP.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param options The options parameters.
     */
    _listAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, listAppServiceCertificateOrderDetectorResponseOperationSpec);
    }
    /**
     * Description for Microsoft.CertificateRegistration call to get a detector response from App Lens.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param detectorName The detector name which needs to be run.
     * @param options The options parameters.
     */
    getAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, detectorName, options }, getAppServiceCertificateOrderDetectorResponseOperationSpec);
    }
    /**
     * ListAppServiceCertificateOrderDetectorResponseNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAppServiceCertificateOrderDetectorResponse method.
     * @param options The options parameters.
     */
    _listAppServiceCertificateOrderDetectorResponseNext(resourceGroupName, certificateOrderName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, nextLink, options }, listAppServiceCertificateOrderDetectorResponseNextOperationSpec);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listAppServiceCertificateOrderDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const getAppServiceCertificateOrderDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        detectorName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listAppServiceCertificateOrderDetectorResponseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CertificateRegistrationProvider operations. */
class CertificateRegistrationProviderImpl {
    /**
     * Initialize a new instance of the class CertificateRegistrationProvider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOperationsPagingPage(options);
            }
        };
    }
    listOperationsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result = yield tslib.__await(this._listOperations(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listOperationsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec$3);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationsOperationSpec$3 = {
    path: "/providers/Microsoft.CertificateRegistration/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$r
};
const listOperationsNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Domains operations. */
class DomainsImpl {
    /**
     * Initialize a new instance of the class Domains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all domains in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get domain name recommendations based on keywords.
     * @param parameters Search parameters for domain name recommendations.
     * @param options The options parameters.
     */
    listRecommendations(parameters, options) {
        const iter = this.listRecommendationsPagingAll(parameters, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRecommendationsPagingPage(parameters, options);
            }
        };
    }
    listRecommendationsPagingPage(parameters, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendationsPagingPage_1() {
            let result = yield tslib.__await(this._listRecommendations(parameters, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendationsNext(parameters, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRecommendationsPagingAll(parameters, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendationsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRecommendationsPagingPage(parameters, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all domains in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Lists domain ownership identifiers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param options The options parameters.
     */
    listOwnershipIdentifiers(resourceGroupName, domainName, options) {
        const iter = this.listOwnershipIdentifiersPagingAll(resourceGroupName, domainName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOwnershipIdentifiersPagingPage(resourceGroupName, domainName, options);
            }
        };
    }
    listOwnershipIdentifiersPagingPage(resourceGroupName, domainName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOwnershipIdentifiersPagingPage_1() {
            let result = yield tslib.__await(this._listOwnershipIdentifiers(resourceGroupName, domainName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOwnershipIdentifiersNext(resourceGroupName, domainName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOwnershipIdentifiersPagingAll(resourceGroupName, domainName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOwnershipIdentifiersPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listOwnershipIdentifiersPagingPage(resourceGroupName, domainName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Check if a domain is available for registration.
     * @param identifier Name of the domain.
     * @param options The options parameters.
     */
    checkAvailability(identifier, options) {
        return this.client.sendOperationRequest({ identifier, options }, checkAvailabilityOperationSpec);
    }
    /**
     * Description for Get all domains in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$h);
    }
    /**
     * Description for Generate a single sign-on request for the domain management portal.
     * @param options The options parameters.
     */
    getControlCenterSsoRequest(options) {
        return this.client.sendOperationRequest({ options }, getControlCenterSsoRequestOperationSpec);
    }
    /**
     * Description for Get domain name recommendations based on keywords.
     * @param parameters Search parameters for domain name recommendations.
     * @param options The options parameters.
     */
    _listRecommendations(parameters, options) {
        return this.client.sendOperationRequest({ parameters, options }, listRecommendationsOperationSpec);
    }
    /**
     * Description for Get all domains in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$7);
    }
    /**
     * Description for Get a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    get(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, getOperationSpec$f);
    }
    /**
     * Description for Creates or updates a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param domain Domain registration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, domainName, domain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, domain, options }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param domain Domain registration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, domainName, domain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, domainName, domain, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    delete(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, deleteOperationSpec$6);
    }
    /**
     * Description for Creates or updates a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param domain Domain registration information.
     * @param options The options parameters.
     */
    update(resourceGroupName, domainName, domain, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, domain, options }, updateOperationSpec$5);
    }
    /**
     * Description for Lists domain ownership identifiers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param options The options parameters.
     */
    _listOwnershipIdentifiers(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, listOwnershipIdentifiersOperationSpec);
    }
    /**
     * Description for Get ownership identifier for domain
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param options The options parameters.
     */
    getOwnershipIdentifier(resourceGroupName, domainName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, name, options }, getOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates an ownership identifier for a domain or updates identifier details for an
     * existing identifier
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    createOrUpdateOwnershipIdentifier(resourceGroupName, domainName, name, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            name,
            domainOwnershipIdentifier,
            options
        }, createOrUpdateOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Delete ownership identifier for domain
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param options The options parameters.
     */
    deleteOwnershipIdentifier(resourceGroupName, domainName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, name, options }, deleteOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates an ownership identifier for a domain or updates identifier details for an
     * existing identifier
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    updateOwnershipIdentifier(resourceGroupName, domainName, name, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            name,
            domainOwnershipIdentifier,
            options
        }, updateOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Renew a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    renew(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, renewOperationSpec);
    }
    /**
     * Transfer out domain to another registrar
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param options The options parameters.
     */
    transferOut(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, transferOutOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$h);
    }
    /**
     * ListRecommendationsNext
     * @param parameters Search parameters for domain name recommendations.
     * @param nextLink The nextLink from the previous successful call to the ListRecommendations method.
     * @param options The options parameters.
     */
    _listRecommendationsNext(parameters, nextLink, options) {
        return this.client.sendOperationRequest({ parameters, nextLink, options }, listRecommendationsNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$7);
    }
    /**
     * ListOwnershipIdentifiersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param nextLink The nextLink from the previous successful call to the ListOwnershipIdentifiers
     *                 method.
     * @param options The options parameters.
     */
    _listOwnershipIdentifiersNext(resourceGroupName, domainName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, nextLink, options }, listOwnershipIdentifiersNextOperationSpec);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/checkDomainAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DomainAvailabilityCheckResult
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: identifier,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/domains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$q
};
const getControlCenterSsoRequestOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/generateSsoRequest",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DomainControlCenterSsoRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$q
};
const listRecommendationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/listDomainRecommendations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NameIdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listByResourceGroupOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Domain
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Domain
        },
        201: {
            bodyMapper: Domain
        },
        202: {
            bodyMapper: Domain
        },
        204: {
            bodyMapper: Domain
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domain,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, forceHardDeleteDomain],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Domain
        },
        202: {
            bodyMapper: Domain
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domain1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listOwnershipIdentifiersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const createOrUpdateOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domainOwnershipIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const deleteOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const updateOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domainOwnershipIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const renewOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/renew",
    httpMethod: "POST",
    responses: {
        200: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const transferOutOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/transferOut",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Domain
        },
        400: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listRecommendationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NameIdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listByResourceGroupNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listOwnershipIdentifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TopLevelDomains operations. */
class TopLevelDomainsImpl {
    /**
     * Initialize a new instance of the class TopLevelDomains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all top-level domains supported for registration.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets all legal agreements that user needs to accept before purchasing a domain.
     * @param name Name of the top-level domain.
     * @param agreementOption Domain agreement options.
     * @param options The options parameters.
     */
    listAgreements(name, agreementOption, options) {
        const iter = this.listAgreementsPagingAll(name, agreementOption, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAgreementsPagingPage(name, agreementOption, options);
            }
        };
    }
    listAgreementsPagingPage(name, agreementOption, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAgreementsPagingPage_1() {
            let result = yield tslib.__await(this._listAgreements(name, agreementOption, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAgreementsNext(name, agreementOption, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAgreementsPagingAll(name, agreementOption, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAgreementsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAgreementsPagingPage(name, agreementOption, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all top-level domains supported for registration.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$g);
    }
    /**
     * Description for Get details of a top-level domain.
     * @param name Name of the top-level domain.
     * @param options The options parameters.
     */
    get(name, options) {
        return this.client.sendOperationRequest({ name, options }, getOperationSpec$e);
    }
    /**
     * Description for Gets all legal agreements that user needs to accept before purchasing a domain.
     * @param name Name of the top-level domain.
     * @param agreementOption Domain agreement options.
     * @param options The options parameters.
     */
    _listAgreements(name, agreementOption, options) {
        return this.client.sendOperationRequest({ name, agreementOption, options }, listAgreementsOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$g);
    }
    /**
     * ListAgreementsNext
     * @param name Name of the top-level domain.
     * @param agreementOption Domain agreement options.
     * @param nextLink The nextLink from the previous successful call to the ListAgreements method.
     * @param options The options parameters.
     */
    _listAgreementsNext(name, agreementOption, nextLink, options) {
        return this.client.sendOperationRequest({ name, agreementOption, nextLink, options }, listAgreementsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/topLevelDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopLevelDomainCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/topLevelDomains/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopLevelDomain
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$p
};
const listAgreementsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/topLevelDomains/{name}/listAgreements",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TldLegalAgreementCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: agreementOption,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopLevelDomainCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listAgreementsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TldLegalAgreementCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        name,
        nextLink
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DomainRegistrationProvider operations. */
class DomainRegistrationProviderImpl {
    /**
     * Initialize a new instance of the class DomainRegistrationProvider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOperationsPagingPage(options);
            }
        };
    }
    listOperationsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result = yield tslib.__await(this._listOperations(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listOperationsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec$2);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationsOperationSpec$2 = {
    path: "/providers/Microsoft.DomainRegistration/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$o
};
const listOperationsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AppServiceEnvironments operations. */
class AppServiceEnvironmentsImpl {
    /**
     * Initialize a new instance of the class AppServiceEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all App Service Environments for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all App Service Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get the used, available, and total worker capacity an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listCapacities(resourceGroupName, name, options) {
        const iter = this.listCapacitiesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCapacitiesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listCapacitiesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCapacitiesPagingPage_1() {
            let result = yield tslib.__await(this._listCapacities(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCapacitiesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCapacitiesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCapacitiesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCapacitiesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Move an App Service Environment to a different VNET.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param vnetInfo Details for the new virtual network.
     * @param options The options parameters.
     */
    beginListChangeVnetAndWait(resourceGroupName, name, vnetInfo, options) {
        const iter = this.changeVnetPagingAll(resourceGroupName, name, vnetInfo, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.changeVnetPagingPage(resourceGroupName, name, vnetInfo, options);
            }
        };
    }
    changeVnetPagingPage(resourceGroupName, name, vnetInfo, options) {
        return tslib.__asyncGenerator(this, arguments, function* changeVnetPagingPage_1() {
            const poller = yield tslib.__await(this._changeVnet(resourceGroupName, name, vnetInfo, options));
            let result = yield tslib.__await(poller.pollUntilDone());
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._changeVnetNext(resourceGroupName, name, vnetInfo, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    changeVnetPagingAll(resourceGroupName, name, vnetInfo, options) {
        return tslib.__asyncGenerator(this, arguments, function* changeVnetPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.changeVnetPagingPage(resourceGroupName, name, vnetInfo, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get the network endpoints of all inbound dependencies of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listInboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        const iter = this.getInboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getInboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getInboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getInboundNetworkDependenciesEndpointsPagingPage_1() {
            let result = yield tslib.__await(this._getInboundNetworkDependenciesEndpoints(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getInboundNetworkDependenciesEndpointsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getInboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getInboundNetworkDependenciesEndpointsPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getInboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Get all multi-role pools.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRolePools(resourceGroupName, name, options) {
        const iter = this.listMultiRolePoolsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMultiRolePoolsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listMultiRolePoolsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolsPagingPage_1() {
            let result = yield tslib.__await(this._listMultiRolePools(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listMultiRolePoolsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolsPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMultiRolePoolsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a specific instance of a multi-role pool of an App
     * Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param instance Name of the instance in the multi-role pool.
     * @param options The options parameters.
     */
    listMultiRolePoolInstanceMetricDefinitions(resourceGroupName, name, instance, options) {
        const iter = this.listMultiRolePoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, instance, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMultiRolePoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, instance, options);
            }
        };
    }
    listMultiRolePoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, instance, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolInstanceMetricDefinitionsPagingPage_1() {
            let result = yield tslib.__await(this._listMultiRolePoolInstanceMetricDefinitions(resourceGroupName, name, instance, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolInstanceMetricDefinitionsNext(resourceGroupName, name, instance, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listMultiRolePoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, instance, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolInstanceMetricDefinitionsPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMultiRolePoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, instance, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRoleMetricDefinitions(resourceGroupName, name, options) {
        const iter = this.listMultiRoleMetricDefinitionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMultiRoleMetricDefinitionsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listMultiRoleMetricDefinitionsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleMetricDefinitionsPagingPage_1() {
            let result = yield tslib.__await(this._listMultiRoleMetricDefinitions(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRoleMetricDefinitionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listMultiRoleMetricDefinitionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleMetricDefinitionsPagingAll_1() {
            var e_8, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMultiRoleMetricDefinitionsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for Get available SKUs for scaling a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRolePoolSkus(resourceGroupName, name, options) {
        const iter = this.listMultiRolePoolSkusPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMultiRolePoolSkusPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listMultiRolePoolSkusPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolSkusPagingPage_1() {
            let result = yield tslib.__await(this._listMultiRolePoolSkus(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolSkusNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listMultiRolePoolSkusPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolSkusPagingAll_1() {
            var e_9, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMultiRolePoolSkusPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * Description for Get usage metrics for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRoleUsages(resourceGroupName, name, options) {
        const iter = this.listMultiRoleUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMultiRoleUsagesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listMultiRoleUsagesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleUsagesPagingPage_1() {
            let result = yield tslib.__await(this._listMultiRoleUsages(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRoleUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listMultiRoleUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleUsagesPagingAll_1() {
            var e_10, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMultiRoleUsagesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Description for Get the network endpoints of all outbound dependencies of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        const iter = this.getOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getOutboundNetworkDependenciesEndpointsPagingPage_1() {
            let result = yield tslib.__await(this._getOutboundNetworkDependenciesEndpoints(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getOutboundNetworkDependenciesEndpointsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getOutboundNetworkDependenciesEndpointsPagingAll_1() {
            var e_11, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoints associated with a hosting environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionList(resourceGroupName, name, options) {
        const iter = this.getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingPage_1() {
            let result = yield tslib.__await(this._getPrivateEndpointConnectionList(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingAll_1() {
            var e_12, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    }
    /**
     * Description for Resume an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginListResumeAndWait(resourceGroupName, name, options) {
        const iter = this.resumePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.resumePagingPage(resourceGroupName, name, options);
            }
        };
    }
    resumePagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* resumePagingPage_1() {
            const poller = yield tslib.__await(this._resume(resourceGroupName, name, options));
            let result = yield tslib.__await(poller.pollUntilDone());
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._resumeNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    resumePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* resumePagingAll_1() {
            var e_13, _a;
            try {
                for (var _b = tslib.__asyncValues(this.resumePagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_13) throw e_13.error; }
            }
        });
    }
    /**
     * Description for Get all App Service plans in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listAppServicePlans(resourceGroupName, name, options) {
        const iter = this.listAppServicePlansPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAppServicePlansPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listAppServicePlansPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServicePlansPagingPage_1() {
            let result = yield tslib.__await(this._listAppServicePlans(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAppServicePlansNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAppServicePlansPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServicePlansPagingAll_1() {
            var e_14, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAppServicePlansPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_14) throw e_14.error; }
            }
        });
    }
    /**
     * Description for Get all apps in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listWebApps(resourceGroupName, name, options) {
        const iter = this.listWebAppsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebAppsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listWebAppsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingPage_1() {
            let result = yield tslib.__await(this._listWebApps(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebAppsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebAppsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingAll_1() {
            var e_15, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebAppsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_15) throw e_15.error; }
            }
        });
    }
    /**
     * Description for Suspend an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginListSuspendAndWait(resourceGroupName, name, options) {
        const iter = this.suspendPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.suspendPagingPage(resourceGroupName, name, options);
            }
        };
    }
    suspendPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* suspendPagingPage_1() {
            const poller = yield tslib.__await(this._suspend(resourceGroupName, name, options));
            let result = yield tslib.__await(poller.pollUntilDone());
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._suspendNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    suspendPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* suspendPagingAll_1() {
            var e_16, _a;
            try {
                for (var _b = tslib.__asyncValues(this.suspendPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_16) throw e_16.error; }
            }
        });
    }
    /**
     * Description for Get global usage metrics of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, name, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUsagesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result = yield tslib.__await(this._listUsages(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var e_17, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_17) throw e_17.error; }
            }
        });
    }
    /**
     * Description for Get all worker pools of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listWorkerPools(resourceGroupName, name, options) {
        const iter = this.listWorkerPoolsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWorkerPoolsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listWorkerPoolsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolsPagingPage_1() {
            let result = yield tslib.__await(this._listWorkerPools(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWorkerPoolsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolsPagingAll_1() {
            var e_18, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWorkerPoolsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_18) throw e_18.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a specific instance of a worker pool of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param instance Name of the instance in the worker pool.
     * @param options The options parameters.
     */
    listWorkerPoolInstanceMetricDefinitions(resourceGroupName, name, workerPoolName, instance, options) {
        const iter = this.listWorkerPoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, instance, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWorkerPoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, instance, options);
            }
        };
    }
    listWorkerPoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, instance, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolInstanceMetricDefinitionsPagingPage_1() {
            let result = yield tslib.__await(this._listWorkerPoolInstanceMetricDefinitions(resourceGroupName, name, workerPoolName, instance, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolInstanceMetricDefinitionsNext(resourceGroupName, name, workerPoolName, instance, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWorkerPoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, instance, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolInstanceMetricDefinitionsPagingAll_1() {
            var e_19, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWorkerPoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, instance, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_19) throw e_19.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    listWebWorkerMetricDefinitions(resourceGroupName, name, workerPoolName, options) {
        const iter = this.listWebWorkerMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebWorkerMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, options);
            }
        };
    }
    listWebWorkerMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerMetricDefinitionsPagingPage_1() {
            let result = yield tslib.__await(this._listWebWorkerMetricDefinitions(resourceGroupName, name, workerPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebWorkerMetricDefinitionsNext(resourceGroupName, name, workerPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebWorkerMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerMetricDefinitionsPagingAll_1() {
            var e_20, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebWorkerMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_20_1) { e_20 = { error: e_20_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_20) throw e_20.error; }
            }
        });
    }
    /**
     * Description for Get available SKUs for scaling a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    listWorkerPoolSkus(resourceGroupName, name, workerPoolName, options) {
        const iter = this.listWorkerPoolSkusPagingAll(resourceGroupName, name, workerPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWorkerPoolSkusPagingPage(resourceGroupName, name, workerPoolName, options);
            }
        };
    }
    listWorkerPoolSkusPagingPage(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolSkusPagingPage_1() {
            let result = yield tslib.__await(this._listWorkerPoolSkus(resourceGroupName, name, workerPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolSkusNext(resourceGroupName, name, workerPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWorkerPoolSkusPagingAll(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolSkusPagingAll_1() {
            var e_21, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWorkerPoolSkusPagingPage(resourceGroupName, name, workerPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_21) throw e_21.error; }
            }
        });
    }
    /**
     * Description for Get usage metrics for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    listWebWorkerUsages(resourceGroupName, name, workerPoolName, options) {
        const iter = this.listWebWorkerUsagesPagingAll(resourceGroupName, name, workerPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebWorkerUsagesPagingPage(resourceGroupName, name, workerPoolName, options);
            }
        };
    }
    listWebWorkerUsagesPagingPage(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerUsagesPagingPage_1() {
            let result = yield tslib.__await(this._listWebWorkerUsages(resourceGroupName, name, workerPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebWorkerUsagesNext(resourceGroupName, name, workerPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebWorkerUsagesPagingAll(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerUsagesPagingAll_1() {
            var e_22, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebWorkerUsagesPagingPage(resourceGroupName, name, workerPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_22) throw e_22.error; }
            }
        });
    }
    /**
     * Description for Get all App Service Environments for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$f);
    }
    /**
     * Description for Get all App Service Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * Description for Get the properties of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$d);
    }
    /**
     * Description for Create or update an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param hostingEnvironmentEnvelope Configuration details of the App Service Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, hostingEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, hostingEnvironmentEnvelope, options }, createOrUpdateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param hostingEnvironmentEnvelope Configuration details of the App Service Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, hostingEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, hostingEnvironmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Delete an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Create or update an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param hostingEnvironmentEnvelope Configuration details of the App Service Environment.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, hostingEnvironmentEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostingEnvironmentEnvelope, options }, updateOperationSpec$4);
    }
    /**
     * Description for Get the used, available, and total worker capacity an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listCapacities(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listCapacitiesOperationSpec);
    }
    /**
     * Description for Get IP addresses assigned to an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getVipInfo(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getVipInfoOperationSpec);
    }
    /**
     * Description for Move an App Service Environment to a different VNET.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param vnetInfo Details for the new virtual network.
     * @param options The options parameters.
     */
    _changeVnet(resourceGroupName, name, vnetInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, vnetInfo, options }, changeVnetOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Get Custom Dns Suffix configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getAseCustomDnsSuffixConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAseCustomDnsSuffixConfigurationOperationSpec);
    }
    /**
     * Update Custom Dns Suffix configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param customDnsSuffixConfiguration Full view of the custom domain suffix configuration for ASEv3.
     * @param options The options parameters.
     */
    updateAseCustomDnsSuffixConfiguration(resourceGroupName, name, customDnsSuffixConfiguration, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, customDnsSuffixConfiguration, options }, updateAseCustomDnsSuffixConfigurationOperationSpec);
    }
    /**
     * Delete Custom Dns Suffix configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    deleteAseCustomDnsSuffixConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteAseCustomDnsSuffixConfigurationOperationSpec);
    }
    /**
     * Description for Get networking configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getAseV3NetworkingConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAseV3NetworkingConfigurationOperationSpec);
    }
    /**
     * Description for Update networking configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param aseNetworkingConfiguration Full view of networking configuration for an ASE.
     * @param options The options parameters.
     */
    updateAseNetworkingConfiguration(resourceGroupName, name, aseNetworkingConfiguration, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, aseNetworkingConfiguration, options }, updateAseNetworkingConfigurationOperationSpec);
    }
    /**
     * Description for Get diagnostic information for an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listDiagnostics(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listDiagnosticsOperationSpec);
    }
    /**
     * Description for Get a diagnostics item for an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param diagnosticsName Name of the diagnostics item.
     * @param options The options parameters.
     */
    getDiagnosticsItem(resourceGroupName, name, diagnosticsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, diagnosticsName, options }, getDiagnosticsItemOperationSpec);
    }
    /**
     * Description for Get the network endpoints of all inbound dependencies of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _getInboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getInboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * Description for Get all multi-role pools.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRolePools(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRolePoolsOperationSpec);
    }
    /**
     * Description for Get properties of a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getMultiRolePool(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMultiRolePoolOperationSpec);
    }
    /**
     * Description for Create or update a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param multiRolePoolEnvelope Properties of the multi-role pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateMultiRolePool(resourceGroupName, name, multiRolePoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, multiRolePoolEnvelope, options }, createOrUpdateMultiRolePoolOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param multiRolePoolEnvelope Properties of the multi-role pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateMultiRolePoolAndWait(resourceGroupName, name, multiRolePoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateMultiRolePool(resourceGroupName, name, multiRolePoolEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Create or update a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param multiRolePoolEnvelope Properties of the multi-role pool.
     * @param options The options parameters.
     */
    updateMultiRolePool(resourceGroupName, name, multiRolePoolEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, multiRolePoolEnvelope, options }, updateMultiRolePoolOperationSpec);
    }
    /**
     * Description for Get metric definitions for a specific instance of a multi-role pool of an App
     * Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param instance Name of the instance in the multi-role pool.
     * @param options The options parameters.
     */
    _listMultiRolePoolInstanceMetricDefinitions(resourceGroupName, name, instance, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instance, options }, listMultiRolePoolInstanceMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get metric definitions for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRoleMetricDefinitions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRoleMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get available SKUs for scaling a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRolePoolSkus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRolePoolSkusOperationSpec);
    }
    /**
     * Send a test notification that an upgrade is available for this App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    testUpgradeAvailableNotification(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, testUpgradeAvailableNotificationOperationSpec);
    }
    /**
     * Description for Initiate an upgrade of an App Service Environment if one is available.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginUpgrade(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, upgradeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Initiate an upgrade of an App Service Environment if one is available.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginUpgradeAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpgrade(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get usage metrics for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRoleUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRoleUsagesOperationSpec);
    }
    /**
     * Description for List all currently running operations on the App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listOperations(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listOperationsOperationSpec$1);
    }
    /**
     * Description for Get the network endpoints of all outbound dependencies of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _getOutboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoints associated with a hosting environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionList(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateEndpointConnectionListOperationSpec$2);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getPrivateEndpointConnectionOperationSpec$2);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Private Endpoint Connection Approval ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                privateEndpointConnectionName,
                privateEndpointWrapper,
                options
            }, approveOrRejectPrivateEndpointConnectionOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Private Endpoint Connection Approval ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, privateEndpointConnectionName, options }, deletePrivateEndpointConnectionOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateLinkResourcesOperationSpec$2);
    }
    /**
     * Description for Reboot all machines in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    reboot(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, rebootOperationSpec);
    }
    /**
     * Description for Resume an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _resume(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, resumeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Get all App Service plans in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listAppServicePlans(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listAppServicePlansOperationSpec);
    }
    /**
     * Description for Get all apps in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listWebApps(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWebAppsOperationSpec$1);
    }
    /**
     * Description for Suspend an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _suspend(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, suspendOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Get global usage metrics of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listUsagesOperationSpec$2);
    }
    /**
     * Description for Get all worker pools of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listWorkerPools(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWorkerPoolsOperationSpec);
    }
    /**
     * Description for Get properties of a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    getWorkerPool(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, getWorkerPoolOperationSpec);
    }
    /**
     * Description for Create or update a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param workerPoolEnvelope Properties of the worker pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateWorkerPool(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, workerPoolName, workerPoolEnvelope, options }, createOrUpdateWorkerPoolOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param workerPoolEnvelope Properties of the worker pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateWorkerPoolAndWait(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateWorkerPool(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Create or update a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param workerPoolEnvelope Properties of the worker pool.
     * @param options The options parameters.
     */
    updateWorkerPool(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, workerPoolEnvelope, options }, updateWorkerPoolOperationSpec);
    }
    /**
     * Description for Get metric definitions for a specific instance of a worker pool of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param instance Name of the instance in the worker pool.
     * @param options The options parameters.
     */
    _listWorkerPoolInstanceMetricDefinitions(resourceGroupName, name, workerPoolName, instance, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, instance, options }, listWorkerPoolInstanceMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get metric definitions for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    _listWebWorkerMetricDefinitions(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, listWebWorkerMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get available SKUs for scaling a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    _listWorkerPoolSkus(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, listWorkerPoolSkusOperationSpec);
    }
    /**
     * Description for Get usage metrics for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    _listWebWorkerUsages(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, listWebWorkerUsagesOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$f);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$6);
    }
    /**
     * ListCapacitiesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListCapacities method.
     * @param options The options parameters.
     */
    _listCapacitiesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listCapacitiesNextOperationSpec);
    }
    /**
     * ChangeVnetNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param vnetInfo Details for the new virtual network.
     * @param nextLink The nextLink from the previous successful call to the ChangeVnet method.
     * @param options The options parameters.
     */
    _changeVnetNext(resourceGroupName, name, vnetInfo, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetInfo, nextLink, options }, changeVnetNextOperationSpec);
    }
    /**
     * GetInboundNetworkDependenciesEndpointsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetInboundNetworkDependenciesEndpoints method.
     * @param options The options parameters.
     */
    _getInboundNetworkDependenciesEndpointsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getInboundNetworkDependenciesEndpointsNextOperationSpec);
    }
    /**
     * ListMultiRolePoolsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRolePools method.
     * @param options The options parameters.
     */
    _listMultiRolePoolsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRolePoolsNextOperationSpec);
    }
    /**
     * ListMultiRolePoolInstanceMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param instance Name of the instance in the multi-role pool.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListMultiRolePoolInstanceMetricDefinitions method.
     * @param options The options parameters.
     */
    _listMultiRolePoolInstanceMetricDefinitionsNext(resourceGroupName, name, instance, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instance, nextLink, options }, listMultiRolePoolInstanceMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListMultiRoleMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRoleMetricDefinitions
     *                 method.
     * @param options The options parameters.
     */
    _listMultiRoleMetricDefinitionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRoleMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListMultiRolePoolSkusNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRolePoolSkus method.
     * @param options The options parameters.
     */
    _listMultiRolePoolSkusNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRolePoolSkusNextOperationSpec);
    }
    /**
     * ListMultiRoleUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRoleUsages method.
     * @param options The options parameters.
     */
    _listMultiRoleUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRoleUsagesNextOperationSpec);
    }
    /**
     * GetOutboundNetworkDependenciesEndpointsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetOutboundNetworkDependenciesEndpoints method.
     * @param options The options parameters.
     */
    _getOutboundNetworkDependenciesEndpointsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getOutboundNetworkDependenciesEndpointsNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionList method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getPrivateEndpointConnectionListNextOperationSpec$2);
    }
    /**
     * ResumeNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the Resume method.
     * @param options The options parameters.
     */
    _resumeNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, resumeNextOperationSpec);
    }
    /**
     * ListAppServicePlansNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListAppServicePlans method.
     * @param options The options parameters.
     */
    _listAppServicePlansNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listAppServicePlansNextOperationSpec);
    }
    /**
     * ListWebAppsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListWebApps method.
     * @param options The options parameters.
     */
    _listWebAppsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWebAppsNextOperationSpec$1);
    }
    /**
     * SuspendNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the Suspend method.
     * @param options The options parameters.
     */
    _suspendNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, suspendNextOperationSpec);
    }
    /**
     * ListUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListUsages method.
     * @param options The options parameters.
     */
    _listUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listUsagesNextOperationSpec$2);
    }
    /**
     * ListWorkerPoolsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListWorkerPools method.
     * @param options The options parameters.
     */
    _listWorkerPoolsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWorkerPoolsNextOperationSpec);
    }
    /**
     * ListWorkerPoolInstanceMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param instance Name of the instance in the worker pool.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListWorkerPoolInstanceMetricDefinitions method.
     * @param options The options parameters.
     */
    _listWorkerPoolInstanceMetricDefinitionsNext(resourceGroupName, name, workerPoolName, instance, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, instance, nextLink, options }, listWorkerPoolInstanceMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListWebWorkerMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param nextLink The nextLink from the previous successful call to the ListWebWorkerMetricDefinitions
     *                 method.
     * @param options The options parameters.
     */
    _listWebWorkerMetricDefinitionsNext(resourceGroupName, name, workerPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, nextLink, options }, listWebWorkerMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListWorkerPoolSkusNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param nextLink The nextLink from the previous successful call to the ListWorkerPoolSkus method.
     * @param options The options parameters.
     */
    _listWorkerPoolSkusNext(resourceGroupName, name, workerPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, nextLink, options }, listWorkerPoolSkusNextOperationSpec);
    }
    /**
     * ListWebWorkerUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param nextLink The nextLink from the previous successful call to the ListWebWorkerUsages method.
     * @param options The options parameters.
     */
    _listWebWorkerUsagesNext(resourceGroupName, name, workerPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, nextLink, options }, listWebWorkerUsagesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/hostingEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentResource
        },
        201: {
            bodyMapper: AppServiceEnvironmentResource
        },
        202: {
            bodyMapper: AppServiceEnvironmentResource
        },
        204: {
            bodyMapper: AppServiceEnvironmentResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: hostingEnvironmentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, forceDelete],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentResource
        },
        201: {
            bodyMapper: AppServiceEnvironmentResource
        },
        202: {
            bodyMapper: AppServiceEnvironmentResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: hostingEnvironmentEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const listCapacitiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/compute",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StampCapacityCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getVipInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/virtualip",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AddressResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const changeVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/changeVirtualNetwork",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        201: {
            bodyMapper: WebAppCollection
        },
        202: {
            bodyMapper: WebAppCollection
        },
        204: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: vnetInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const getAseCustomDnsSuffixConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/customdnssuffix",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomDnsSuffixConfiguration
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateAseCustomDnsSuffixConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/customdnssuffix",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomDnsSuffixConfiguration
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: customDnsSuffixConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteAseCustomDnsSuffixConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/customdnssuffix",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getAseV3NetworkingConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AseV3NetworkingConfiguration
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateAseNetworkingConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AseV3NetworkingConfiguration
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: aseNetworkingConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const listDiagnosticsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostingEnvironmentDiagnostics"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getDiagnosticsItemOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics/{diagnosticsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostingEnvironmentDiagnostics
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        diagnosticsName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getInboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/inboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundEnvironmentEndpointCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRolePoolsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getMultiRolePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateMultiRolePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource
        },
        201: {
            bodyMapper: WorkerPoolResource
        },
        202: {
            bodyMapper: WorkerPoolResource
        },
        204: {
            bodyMapper: WorkerPoolResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: multiRolePoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const updateMultiRolePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource
        },
        202: {
            bodyMapper: WorkerPoolResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: multiRolePoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const listMultiRolePoolInstanceMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/instances/{instance}/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instance
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRoleMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRolePoolSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const testUpgradeAvailableNotificationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/testUpgradeAvailableNotification",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const upgradeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/upgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRoleUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listOperationsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Operation" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getPrivateEndpointConnectionListOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getPrivateEndpointConnectionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const approveOrRejectPrivateEndpointConnectionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deletePrivateEndpointConnectionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getPrivateLinkResourcesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const rebootOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/reboot",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const resumeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/resume",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        201: {
            bodyMapper: WebAppCollection
        },
        202: {
            bodyMapper: WebAppCollection
        },
        204: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listAppServicePlansOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/serverfarms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWebAppsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, propertiesToInclude],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const suspendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/suspend",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        201: {
            bodyMapper: WebAppCollection
        },
        202: {
            bodyMapper: WebAppCollection
        },
        204: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listUsagesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWorkerPoolsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getWorkerPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateWorkerPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource
        },
        201: {
            bodyMapper: WorkerPoolResource
        },
        202: {
            bodyMapper: WorkerPoolResource
        },
        204: {
            bodyMapper: WorkerPoolResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: workerPoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const updateWorkerPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource
        },
        202: {
            bodyMapper: WorkerPoolResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: workerPoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const listWorkerPoolInstanceMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/instances/{instance}/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instance,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWebWorkerMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWorkerPoolSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWebWorkerUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByResourceGroupNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listCapacitiesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StampCapacityCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const changeVnetNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        202: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const getInboundNetworkDependenciesEndpointsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundEnvironmentEndpointCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRolePoolsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRolePoolInstanceMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instance
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRoleMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRolePoolSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listMultiRoleUsagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOutboundNetworkDependenciesEndpointsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getPrivateEndpointConnectionListNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const resumeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        202: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listAppServicePlansNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWebAppsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, propertiesToInclude],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const suspendNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        202: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listUsagesNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWorkerPoolsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWorkerPoolInstanceMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instance,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWebWorkerMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWorkerPoolSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listWebWorkerUsagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workerPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AppServicePlans operations. */
class AppServicePlansImpl {
    /**
     * Initialize a new instance of the class AppServicePlans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all App Service plans for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all App Service plans in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all apps that use a Hybrid Connection in an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Hybrid Connection namespace.
     * @param relayName Name of the Hybrid Connection relay.
     * @param options The options parameters.
     */
    listWebAppsByHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        const iter = this.listWebAppsByHybridConnectionPagingAll(resourceGroupName, name, namespaceName, relayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebAppsByHybridConnectionPagingPage(resourceGroupName, name, namespaceName, relayName, options);
            }
        };
    }
    listWebAppsByHybridConnectionPagingPage(resourceGroupName, name, namespaceName, relayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsByHybridConnectionPagingPage_1() {
            let result = yield tslib.__await(this._listWebAppsByHybridConnection(resourceGroupName, name, namespaceName, relayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebAppsByHybridConnectionNext(resourceGroupName, name, namespaceName, relayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebAppsByHybridConnectionPagingAll(resourceGroupName, name, namespaceName, relayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsByHybridConnectionPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebAppsByHybridConnectionPagingPage(resourceGroupName, name, namespaceName, relayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Retrieve all Hybrid Connections in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listHybridConnections(resourceGroupName, name, options) {
        const iter = this.listHybridConnectionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHybridConnectionsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listHybridConnectionsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHybridConnectionsPagingPage_1() {
            let result = yield tslib.__await(this._listHybridConnections(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHybridConnectionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHybridConnectionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHybridConnectionsPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHybridConnectionsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get all apps associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listWebApps(resourceGroupName, name, options) {
        const iter = this.listWebAppsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebAppsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listWebAppsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingPage_1() {
            let result = yield tslib.__await(this._listWebApps(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebAppsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebAppsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebAppsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Gets server farm usage information
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, name, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUsagesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result = yield tslib.__await(this._listUsages(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get all App Service plans for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * Description for Get all App Service plans in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * Description for Get an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$c);
    }
    /**
     * Description for Creates or updates an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param appServicePlan Details of the App Service plan.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, appServicePlan, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, appServicePlan, options }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param appServicePlan Details of the App Service plan.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, appServicePlan, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, appServicePlan, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec$4);
    }
    /**
     * Description for Creates or updates an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param appServicePlan Details of the App Service plan.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, appServicePlan, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appServicePlan, options }, updateOperationSpec$3);
    }
    /**
     * Description for List all capabilities of an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listCapabilities(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listCapabilitiesOperationSpec);
    }
    /**
     * Description for Retrieve a Hybrid Connection in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Service Bus namespace.
     * @param relayName Name of the Service Bus relay.
     * @param options The options parameters.
     */
    getHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, getHybridConnectionOperationSpec$1);
    }
    /**
     * Description for Delete a Hybrid Connection in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Service Bus namespace.
     * @param relayName Name of the Service Bus relay.
     * @param options The options parameters.
     */
    deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, deleteHybridConnectionOperationSpec$1);
    }
    /**
     * Description for Get the send key name and value of a Hybrid Connection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName The name of the Service Bus namespace.
     * @param relayName The name of the Service Bus relay.
     * @param options The options parameters.
     */
    listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, listHybridConnectionKeysOperationSpec);
    }
    /**
     * Description for Get all apps that use a Hybrid Connection in an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Hybrid Connection namespace.
     * @param relayName Name of the Hybrid Connection relay.
     * @param options The options parameters.
     */
    _listWebAppsByHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, listWebAppsByHybridConnectionOperationSpec);
    }
    /**
     * Description for Get the maximum number of Hybrid Connections allowed in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    getHybridConnectionPlanLimit(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getHybridConnectionPlanLimitOperationSpec);
    }
    /**
     * Description for Retrieve all Hybrid Connections in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    _listHybridConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHybridConnectionsOperationSpec$1);
    }
    /**
     * Description for Restart all apps in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    restartWebApps(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, restartWebAppsOperationSpec);
    }
    /**
     * Description for Get all apps associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    _listWebApps(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWebAppsOperationSpec);
    }
    /**
     * Description for Gets all selectable SKUs for a given App Service Plan
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param options The options parameters.
     */
    getServerFarmSkus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getServerFarmSkusOperationSpec);
    }
    /**
     * Description for Gets server farm usage information
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listUsagesOperationSpec$1);
    }
    /**
     * Description for Get all Virtual Networks associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listVnets(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listVnetsOperationSpec);
    }
    /**
     * Description for Get a Virtual Network associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param options The options parameters.
     */
    getVnetFromServerFarm(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, getVnetFromServerFarmOperationSpec);
    }
    /**
     * Description for Get a Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @param options The options parameters.
     */
    getVnetGateway(resourceGroupName, name, vnetName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, gatewayName, options }, getVnetGatewayOperationSpec);
    }
    /**
     * Description for Update a Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @param connectionEnvelope Definition of the gateway.
     * @param options The options parameters.
     */
    updateVnetGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            connectionEnvelope,
            options
        }, updateVnetGatewayOperationSpec);
    }
    /**
     * Description for Get all routes that are associated with a Virtual Network in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param options The options parameters.
     */
    listRoutesForVnet(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, listRoutesForVnetOperationSpec);
    }
    /**
     * Description for Get a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param options The options parameters.
     */
    getRouteForVnet(resourceGroupName, name, vnetName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, options }, getRouteForVnetOperationSpec);
    }
    /**
     * Description for Create or update a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param route Definition of the Virtual Network route.
     * @param options The options parameters.
     */
    createOrUpdateVnetRoute(resourceGroupName, name, vnetName, routeName, route, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, route, options }, createOrUpdateVnetRouteOperationSpec);
    }
    /**
     * Description for Delete a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param options The options parameters.
     */
    deleteVnetRoute(resourceGroupName, name, vnetName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, options }, deleteVnetRouteOperationSpec);
    }
    /**
     * Description for Create or update a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param route Definition of the Virtual Network route.
     * @param options The options parameters.
     */
    updateVnetRoute(resourceGroupName, name, vnetName, routeName, route, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, route, options }, updateVnetRouteOperationSpec);
    }
    /**
     * Description for Reboot a worker machine in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param workerName Name of worker machine, which typically starts with RD.
     * @param options The options parameters.
     */
    rebootWorker(resourceGroupName, name, workerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerName, options }, rebootWorkerOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$e);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
    /**
     * ListWebAppsByHybridConnectionNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Hybrid Connection namespace.
     * @param relayName Name of the Hybrid Connection relay.
     * @param nextLink The nextLink from the previous successful call to the ListWebAppsByHybridConnection
     *                 method.
     * @param options The options parameters.
     */
    _listWebAppsByHybridConnectionNext(resourceGroupName, name, namespaceName, relayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, nextLink, options }, listWebAppsByHybridConnectionNextOperationSpec);
    }
    /**
     * ListHybridConnectionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param nextLink The nextLink from the previous successful call to the ListHybridConnections method.
     * @param options The options parameters.
     */
    _listHybridConnectionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listHybridConnectionsNextOperationSpec);
    }
    /**
     * ListWebAppsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param nextLink The nextLink from the previous successful call to the ListWebApps method.
     * @param options The options parameters.
     */
    _listWebAppsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWebAppsNextOperationSpec);
    }
    /**
     * ListUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param nextLink The nextLink from the previous successful call to the ListUsages method.
     * @param options The options parameters.
     */
    _listUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listUsagesNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/serverfarms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, detailed],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$m
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlan
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServicePlan
        },
        201: {
            bodyMapper: AppServicePlan
        },
        202: {
            bodyMapper: AppServicePlan
        },
        204: {
            bodyMapper: AppServicePlan
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appServicePlan,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServicePlan
        },
        202: {
            bodyMapper: AppServicePlan
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appServicePlan1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const listCapabilitiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/capabilities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Capability" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getHybridConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const deleteHybridConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listHybridConnectionKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: HybridConnectionKey
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listWebAppsByHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getHybridConnectionPlanLimitOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionPlanLimits/limit",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnectionLimits
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listHybridConnectionsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionRelays",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const restartWebAppsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/restartSites",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, softRestart],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listWebAppsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        skipToken,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getServerFarmSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listUsagesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listVnetsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "VnetInfoResource" }
                    }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getVnetFromServerFarmOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getVnetGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const updateVnetGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const listRoutesForVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "VnetRoute" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getRouteForVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "VnetRoute" } }
                }
            }
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createOrUpdateVnetRouteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetRoute
        },
        400: {
            isError: true
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: route,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteVnetRouteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const updateVnetRouteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetRoute
        },
        400: {
            isError: true
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: route,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const rebootWorkerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/workers/{workerName}/reboot",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, detailed],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listWebAppsByHybridConnectionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listHybridConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listWebAppsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        skipToken,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listUsagesNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Certificates operations. */
class CertificatesImpl {
    /**
     * Initialize a new instance of the class Certificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all certificates for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all certificates in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all certificates for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$d);
    }
    /**
     * Description for Get all certificates in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * Description for Get a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$b);
    }
    /**
     * Description for Create or update a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param certificateEnvelope Details of certificate, if it exists already.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, name, certificateEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, certificateEnvelope, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Description for Delete a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec$3);
    }
    /**
     * Description for Create or update a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param certificateEnvelope Details of certificate, if it exists already.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, certificateEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, certificateEnvelope, options }, updateOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$d);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerApps operations. */
class ContainerAppsImpl {
    /**
     * Initialize a new instance of the class ContainerApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Container Apps in a given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Container Apps in a given resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the Container Apps in a given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Get the Container Apps in a given resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Get the properties of a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$a);
    }
    /**
     * Description for Create or update a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param containerAppEnvelope Container App.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, containerAppEnvelope, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param containerAppEnvelope Container App.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, containerAppEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Delete a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List secrets for a container app
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    listSecrets(name, options) {
        return this.client.sendOperationRequest({ name, options }, listSecretsOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/containerApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        201: {
            bodyMapper: ContainerApp
        },
        202: {
            bodyMapper: ContainerApp
        },
        204: {
            bodyMapper: ContainerApp
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: containerAppEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/containerApps/{name}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SecretsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$k
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerAppsRevisions operations. */
class ContainerAppsRevisionsImpl {
    /**
     * Initialize a new instance of the class ContainerAppsRevisions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    listRevisions(resourceGroupName, containerAppName, options) {
        const iter = this.listRevisionsPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRevisionsPagingPage(resourceGroupName, containerAppName, options);
            }
        };
    }
    listRevisionsPagingPage(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingPage_1() {
            let result = yield tslib.__await(this._listRevisions(resourceGroupName, containerAppName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRevisionsNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRevisionsPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRevisionsPagingPage(resourceGroupName, containerAppName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    _listRevisions(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listRevisionsOperationSpec);
    }
    /**
     * Get a revision of a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision.
     * @param options The options parameters.
     */
    getRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, getRevisionOperationSpec);
    }
    /**
     * Activates a revision for a Container App
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision to activate
     * @param options The options parameters.
     */
    activateRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, activateRevisionOperationSpec);
    }
    /**
     * Deactivates a revision for a Container App
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision to deactivate
     * @param options The options parameters.
     */
    deactivateRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, deactivateRevisionOperationSpec);
    }
    /**
     * Restarts a revision for a Container App
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision to restart
     * @param options The options parameters.
     */
    restartRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, restartRevisionOperationSpec);
    }
    /**
     * ListRevisionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param nextLink The nextLink from the previous successful call to the ListRevisions method.
     * @param options The options parameters.
     */
    _listRevisionsNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listRevisionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listRevisionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Revision
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const activateRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}/activate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const deactivateRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}/deactivate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const restartRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listRevisionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeletedWebApps operations. */
class DeletedWebAppsImpl {
    /**
     * Initialize a new instance of the class DeletedWebApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all deleted apps for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all deleted apps for a subscription at location
     * @param location
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(location, options);
            }
        };
    }
    listByLocationPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all deleted apps for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Description for Get all deleted apps for a subscription at location
     * @param location
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec);
    }
    /**
     * Description for Get deleted app for a subscription at location.
     * @param location
     * @param deletedSiteId The numeric ID of the deleted app, e.g. 12345
     * @param options The options parameters.
     */
    getDeletedWebAppByLocation(location, deletedSiteId, options) {
        return this.client.sendOperationRequest({ location, deletedSiteId, options }, getDeletedWebAppByLocationOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$c);
    }
    /**
     * ListByLocationNext
     * @param location
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listByLocationNextOperationSpec);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deletedSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/deletedSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getDeletedWebAppByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/deletedSites/{deletedSiteId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedSite
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        deletedSiteId
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Diagnostics operations. */
class DiagnosticsImpl {
    /**
     * Initialize a new instance of the class Diagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List Hosting Environment Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name
     * @param options The options parameters.
     */
    listHostingEnvironmentDetectorResponses(resourceGroupName, name, options) {
        const iter = this.listHostingEnvironmentDetectorResponsesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHostingEnvironmentDetectorResponsesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listHostingEnvironmentDetectorResponsesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostingEnvironmentDetectorResponsesPagingPage_1() {
            let result = yield tslib.__await(this._listHostingEnvironmentDetectorResponses(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHostingEnvironmentDetectorResponsesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHostingEnvironmentDetectorResponsesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostingEnvironmentDetectorResponsesPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHostingEnvironmentDetectorResponsesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    listSiteDetectorResponses(resourceGroupName, siteName, options) {
        const iter = this.listSiteDetectorResponsesPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteDetectorResponsesPagingPage(resourceGroupName, siteName, options);
            }
        };
    }
    listSiteDetectorResponsesPagingPage(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesPagingPage_1() {
            let result = yield tslib.__await(this._listSiteDetectorResponses(resourceGroupName, siteName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorResponsesNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteDetectorResponsesPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteDetectorResponsesPagingPage(resourceGroupName, siteName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    listSiteDiagnosticCategories(resourceGroupName, siteName, options) {
        const iter = this.listSiteDiagnosticCategoriesPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteDiagnosticCategoriesPagingPage(resourceGroupName, siteName, options);
            }
        };
    }
    listSiteDiagnosticCategoriesPagingPage(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesPagingPage_1() {
            let result = yield tslib.__await(this._listSiteDiagnosticCategories(resourceGroupName, siteName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDiagnosticCategoriesNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteDiagnosticCategoriesPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteDiagnosticCategoriesPagingPage(resourceGroupName, siteName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    listSiteAnalyses(resourceGroupName, siteName, diagnosticCategory, options) {
        const iter = this.listSiteAnalysesPagingAll(resourceGroupName, siteName, diagnosticCategory, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteAnalysesPagingPage(resourceGroupName, siteName, diagnosticCategory, options);
            }
        };
    }
    listSiteAnalysesPagingPage(resourceGroupName, siteName, diagnosticCategory, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesPagingPage_1() {
            let result = yield tslib.__await(this._listSiteAnalyses(resourceGroupName, siteName, diagnosticCategory, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteAnalysesNext(resourceGroupName, siteName, diagnosticCategory, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteAnalysesPagingAll(resourceGroupName, siteName, diagnosticCategory, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteAnalysesPagingPage(resourceGroupName, siteName, diagnosticCategory, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    listSiteDetectors(resourceGroupName, siteName, diagnosticCategory, options) {
        const iter = this.listSiteDetectorsPagingAll(resourceGroupName, siteName, diagnosticCategory, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteDetectorsPagingPage(resourceGroupName, siteName, diagnosticCategory, options);
            }
        };
    }
    listSiteDetectorsPagingPage(resourceGroupName, siteName, diagnosticCategory, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsPagingPage_1() {
            let result = yield tslib.__await(this._listSiteDetectors(resourceGroupName, siteName, diagnosticCategory, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorsNext(resourceGroupName, siteName, diagnosticCategory, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteDetectorsPagingAll(resourceGroupName, siteName, diagnosticCategory, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteDetectorsPagingPage(resourceGroupName, siteName, diagnosticCategory, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteDetectorResponsesSlot(resourceGroupName, siteName, slot, options) {
        const iter = this.listSiteDetectorResponsesSlotPagingAll(resourceGroupName, siteName, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteDetectorResponsesSlotPagingPage(resourceGroupName, siteName, slot, options);
            }
        };
    }
    listSiteDetectorResponsesSlotPagingPage(resourceGroupName, siteName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSiteDetectorResponsesSlot(resourceGroupName, siteName, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorResponsesSlotNext(resourceGroupName, siteName, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteDetectorResponsesSlotPagingAll(resourceGroupName, siteName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesSlotPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteDetectorResponsesSlotPagingPage(resourceGroupName, siteName, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteDiagnosticCategoriesSlot(resourceGroupName, siteName, slot, options) {
        const iter = this.listSiteDiagnosticCategoriesSlotPagingAll(resourceGroupName, siteName, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteDiagnosticCategoriesSlotPagingPage(resourceGroupName, siteName, slot, options);
            }
        };
    }
    listSiteDiagnosticCategoriesSlotPagingPage(resourceGroupName, siteName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSiteDiagnosticCategoriesSlot(resourceGroupName, siteName, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDiagnosticCategoriesSlotNext(resourceGroupName, siteName, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteDiagnosticCategoriesSlotPagingAll(resourceGroupName, siteName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesSlotPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteDiagnosticCategoriesSlotPagingPage(resourceGroupName, siteName, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteAnalysesSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        const iter = this.listSiteAnalysesSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteAnalysesSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options);
            }
        };
    }
    listSiteAnalysesSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSiteAnalysesSlot(resourceGroupName, siteName, diagnosticCategory, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteAnalysesSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteAnalysesSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesSlotPagingAll_1() {
            var e_8, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteAnalysesSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteDetectorsSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        const iter = this.listSiteDetectorsSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteDetectorsSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options);
            }
        };
    }
    listSiteDetectorsSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSiteDetectorsSlot(resourceGroupName, siteName, diagnosticCategory, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorsSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteDetectorsSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsSlotPagingAll_1() {
            var e_9, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteDetectorsSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * Description for List Hosting Environment Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name
     * @param options The options parameters.
     */
    _listHostingEnvironmentDetectorResponses(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHostingEnvironmentDetectorResponsesOperationSpec);
    }
    /**
     * Description for Get Hosting Environment Detector Response
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name App Service Environment Name
     * @param detectorName Detector Resource Name
     * @param options The options parameters.
     */
    getHostingEnvironmentDetectorResponse(resourceGroupName, name, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, detectorName, options }, getHostingEnvironmentDetectorResponseOperationSpec);
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    _listSiteDetectorResponses(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listSiteDetectorResponsesOperationSpec);
    }
    /**
     * Description for Get site detector response
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param options The options parameters.
     */
    getSiteDetectorResponse(resourceGroupName, siteName, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, detectorName, options }, getSiteDetectorResponseOperationSpec);
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategories(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listSiteDiagnosticCategoriesOperationSpec);
    }
    /**
     * Description for Get Diagnostics Category
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    getSiteDiagnosticCategory(resourceGroupName, siteName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, options }, getSiteDiagnosticCategoryOperationSpec);
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    _listSiteAnalyses(resourceGroupName, siteName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, options }, listSiteAnalysesOperationSpec);
    }
    /**
     * Description for Get Site Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param analysisName Analysis Name
     * @param options The options parameters.
     */
    getSiteAnalysis(resourceGroupName, siteName, diagnosticCategory, analysisName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            options
        }, getSiteAnalysisOperationSpec);
    }
    /**
     * Description for Execute Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Category Name
     * @param analysisName Analysis Resource Name
     * @param options The options parameters.
     */
    executeSiteAnalysis(resourceGroupName, siteName, diagnosticCategory, analysisName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            options
        }, executeSiteAnalysisOperationSpec);
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    _listSiteDetectors(resourceGroupName, siteName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, options }, listSiteDetectorsOperationSpec);
    }
    /**
     * Description for Get Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param detectorName Detector Name
     * @param options The options parameters.
     */
    getSiteDetector(resourceGroupName, siteName, diagnosticCategory, detectorName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            detectorName,
            options
        }, getSiteDetectorOperationSpec);
    }
    /**
     * Description for Execute Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param diagnosticCategory Category Name
     * @param options The options parameters.
     */
    executeSiteDetector(resourceGroupName, siteName, detectorName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            detectorName,
            diagnosticCategory,
            options
        }, executeSiteDetectorOperationSpec);
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteDetectorResponsesSlot(resourceGroupName, siteName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, options }, listSiteDetectorResponsesSlotOperationSpec);
    }
    /**
     * Description for Get site detector response
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    getSiteDetectorResponseSlot(resourceGroupName, siteName, detectorName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, detectorName, slot, options }, getSiteDetectorResponseSlotOperationSpec);
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategoriesSlot(resourceGroupName, siteName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, options }, listSiteDiagnosticCategoriesSlotOperationSpec);
    }
    /**
     * Description for Get Diagnostics Category
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    getSiteDiagnosticCategorySlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, slot, options }, getSiteDiagnosticCategorySlotOperationSpec);
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteAnalysesSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, slot, options }, listSiteAnalysesSlotOperationSpec);
    }
    /**
     * Description for Get Site Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param analysisName Analysis Name
     * @param slot Slot - optional
     * @param options The options parameters.
     */
    getSiteAnalysisSlot(resourceGroupName, siteName, diagnosticCategory, analysisName, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            slot,
            options
        }, getSiteAnalysisSlotOperationSpec);
    }
    /**
     * Description for Execute Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Category Name
     * @param analysisName Analysis Resource Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    executeSiteAnalysisSlot(resourceGroupName, siteName, diagnosticCategory, analysisName, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            slot,
            options
        }, executeSiteAnalysisSlotOperationSpec);
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteDetectorsSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, slot, options }, listSiteDetectorsSlotOperationSpec);
    }
    /**
     * Description for Get Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param detectorName Detector Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    getSiteDetectorSlot(resourceGroupName, siteName, diagnosticCategory, detectorName, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            detectorName,
            slot,
            options
        }, getSiteDetectorSlotOperationSpec);
    }
    /**
     * Description for Execute Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param diagnosticCategory Category Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    executeSiteDetectorSlot(resourceGroupName, siteName, detectorName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            detectorName,
            diagnosticCategory,
            slot,
            options
        }, executeSiteDetectorSlotOperationSpec);
    }
    /**
     * ListHostingEnvironmentDetectorResponsesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListHostingEnvironmentDetectorResponses method.
     * @param options The options parameters.
     */
    _listHostingEnvironmentDetectorResponsesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listHostingEnvironmentDetectorResponsesNextOperationSpec);
    }
    /**
     * ListSiteDetectorResponsesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectorResponses
     *                 method.
     * @param options The options parameters.
     */
    _listSiteDetectorResponsesNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listSiteDetectorResponsesNextOperationSpec);
    }
    /**
     * ListSiteDiagnosticCategoriesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDiagnosticCategories
     *                 method.
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategoriesNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listSiteDiagnosticCategoriesNextOperationSpec);
    }
    /**
     * ListSiteAnalysesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param nextLink The nextLink from the previous successful call to the ListSiteAnalyses method.
     * @param options The options parameters.
     */
    _listSiteAnalysesNext(resourceGroupName, siteName, diagnosticCategory, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, nextLink, options }, listSiteAnalysesNextOperationSpec);
    }
    /**
     * ListSiteDetectorsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectors method.
     * @param options The options parameters.
     */
    _listSiteDetectorsNext(resourceGroupName, siteName, diagnosticCategory, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, nextLink, options }, listSiteDetectorsNextOperationSpec);
    }
    /**
     * ListSiteDetectorResponsesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectorResponsesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listSiteDetectorResponsesSlotNext(resourceGroupName, siteName, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, nextLink, options }, listSiteDetectorResponsesSlotNextOperationSpec);
    }
    /**
     * ListSiteDiagnosticCategoriesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSiteDiagnosticCategoriesSlot method.
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategoriesSlotNext(resourceGroupName, siteName, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, nextLink, options }, listSiteDiagnosticCategoriesSlotNextOperationSpec);
    }
    /**
     * ListSiteAnalysesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteAnalysesSlot method.
     * @param options The options parameters.
     */
    _listSiteAnalysesSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            slot,
            nextLink,
            options
        }, listSiteAnalysesSlotNextOperationSpec);
    }
    /**
     * ListSiteDetectorsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectorsSlot method.
     * @param options The options parameters.
     */
    _listSiteDetectorsSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            slot,
            nextLink,
            options
        }, listSiteDetectorsSlotNextOperationSpec);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listHostingEnvironmentDetectorResponsesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getHostingEnvironmentDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        detectorName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorResponsesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDiagnosticCategoriesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteDiagnosticCategoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategory
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteAnalysesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteAnalysisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalysisDefinition
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const executeSiteAnalysisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysis
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteDetectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorDefinitionResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const executeSiteDetectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorResponsesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteDetectorResponseSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDiagnosticCategoriesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteDiagnosticCategorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategory
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteAnalysesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteAnalysisSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalysisDefinition
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const executeSiteAnalysisSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysis
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getSiteDetectorSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorDefinitionResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const executeSiteDetectorSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listHostingEnvironmentDetectorResponsesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorResponsesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDiagnosticCategoriesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteAnalysesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorResponsesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDiagnosticCategoriesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteAnalysesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listSiteDetectorsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Global operations. */
class GlobalImpl {
    /**
     * Initialize a new instance of the class Global class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get deleted app for a subscription.
     * @param deletedSiteId The numeric ID of the deleted app, e.g. 12345
     * @param options The options parameters.
     */
    getDeletedWebApp(deletedSiteId, options) {
        return this.client.sendOperationRequest({ deletedSiteId, options }, getDeletedWebAppOperationSpec);
    }
    /**
     * Description for Get all deleted apps for a subscription.
     * @param deletedSiteId The numeric ID of the deleted app, e.g. 12345
     * @param options The options parameters.
     */
    getDeletedWebAppSnapshots(deletedSiteId, options) {
        return this.client.sendOperationRequest({ deletedSiteId, options }, getDeletedWebAppSnapshotsOperationSpec);
    }
    /**
     * Description for Gets an operation in a subscription and given region
     * @param location Location name
     * @param operationId Operation Id
     * @param options The options parameters.
     */
    getSubscriptionOperationWithAsyncResponse(location, operationId, options) {
        return this.client.sendOperationRequest({ location, operationId, options }, getSubscriptionOperationWithAsyncResponseOperationSpec);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getDeletedWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deletedSites/{deletedSiteId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedSite
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        deletedSiteId
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getDeletedWebAppSnapshotsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deletedSites/{deletedSiteId}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Snapshot" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        deletedSiteId
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getSubscriptionOperationWithAsyncResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KubeEnvironments operations. */
class KubeEnvironmentsImpl {
    /**
     * Initialize a new instance of the class KubeEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all Kubernetes Environments for a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all the Kubernetes Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all Kubernetes Environments for a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Description for Get all the Kubernetes Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Description for Get the properties of a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$9);
    }
    /**
     * Description for Creates or updates a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param kubeEnvironmentEnvelope Configuration details of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, kubeEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, kubeEnvironmentEnvelope, options }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param kubeEnvironmentEnvelope Configuration details of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, kubeEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, kubeEnvironmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Delete a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates or updates a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param kubeEnvironmentEnvelope Configuration details of the Kubernetes Environment.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, kubeEnvironmentEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, kubeEnvironmentEnvelope, options }, updateOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/kubeEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KubeEnvironment
        },
        201: {
            bodyMapper: KubeEnvironment
        },
        202: {
            bodyMapper: KubeEnvironment
        },
        204: {
            bodyMapper: KubeEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: kubeEnvironmentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: KubeEnvironment
        },
        201: {
            bodyMapper: KubeEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: kubeEnvironmentEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Provider operations. */
class ProviderImpl {
    /**
     * Initialize a new instance of the class Provider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    listAvailableStacks(options) {
        const iter = this.getAvailableStacksPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getAvailableStacksPagingPage(options);
            }
        };
    }
    getAvailableStacksPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksPagingPage_1() {
            let result = yield tslib.__await(this._getAvailableStacks(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getAvailableStacksNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getAvailableStacksPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getAvailableStacksPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get available Function app frameworks and their versions
     * @param options The options parameters.
     */
    listFunctionAppStacks(options) {
        const iter = this.getFunctionAppStacksPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getFunctionAppStacksPagingPage(options);
            }
        };
    }
    getFunctionAppStacksPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksPagingPage_1() {
            let result = yield tslib.__await(this._getFunctionAppStacks(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getFunctionAppStacksNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getFunctionAppStacksPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getFunctionAppStacksPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get available Function app frameworks and their versions for location
     * @param location Function App stack location.
     * @param options The options parameters.
     */
    listFunctionAppStacksForLocation(location, options) {
        const iter = this.getFunctionAppStacksForLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getFunctionAppStacksForLocationPagingPage(location, options);
            }
        };
    }
    getFunctionAppStacksForLocationPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksForLocationPagingPage_1() {
            let result = yield tslib.__await(this._getFunctionAppStacksForLocation(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getFunctionAppStacksForLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getFunctionAppStacksForLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksForLocationPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getFunctionAppStacksForLocationPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get available Web app frameworks and their versions for location
     * @param location Web App stack location.
     * @param options The options parameters.
     */
    listWebAppStacksForLocation(location, options) {
        const iter = this.getWebAppStacksForLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getWebAppStacksForLocationPagingPage(location, options);
            }
        };
    }
    getWebAppStacksForLocationPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksForLocationPagingPage_1() {
            let result = yield tslib.__await(this._getWebAppStacksForLocation(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getWebAppStacksForLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getWebAppStacksForLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksForLocationPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getWebAppStacksForLocationPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Gets all available operations for the Microsoft.Web resource provider. Also exposes
     * resource metric definitions
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOperationsPagingPage(options);
            }
        };
    }
    listOperationsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result = yield tslib.__await(this._listOperations(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listOperationsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Get available Web app frameworks and their versions
     * @param options The options parameters.
     */
    listWebAppStacks(options) {
        const iter = this.getWebAppStacksPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getWebAppStacksPagingPage(options);
            }
        };
    }
    getWebAppStacksPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksPagingPage_1() {
            let result = yield tslib.__await(this._getWebAppStacks(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getWebAppStacksNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getWebAppStacksPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getWebAppStacksPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    listAvailableStacksOnPrem(options) {
        const iter = this.getAvailableStacksOnPremPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getAvailableStacksOnPremPagingPage(options);
            }
        };
    }
    getAvailableStacksOnPremPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksOnPremPagingPage_1() {
            let result = yield tslib.__await(this._getAvailableStacksOnPrem(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getAvailableStacksOnPremNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getAvailableStacksOnPremPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksOnPremPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getAvailableStacksOnPremPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    _getAvailableStacks(options) {
        return this.client.sendOperationRequest({ options }, getAvailableStacksOperationSpec);
    }
    /**
     * Description for Get available Function app frameworks and their versions
     * @param options The options parameters.
     */
    _getFunctionAppStacks(options) {
        return this.client.sendOperationRequest({ options }, getFunctionAppStacksOperationSpec);
    }
    /**
     * Description for Get available Function app frameworks and their versions for location
     * @param location Function App stack location.
     * @param options The options parameters.
     */
    _getFunctionAppStacksForLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, getFunctionAppStacksForLocationOperationSpec);
    }
    /**
     * Description for Get available Web app frameworks and their versions for location
     * @param location Web App stack location.
     * @param options The options parameters.
     */
    _getWebAppStacksForLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, getWebAppStacksForLocationOperationSpec);
    }
    /**
     * Description for Gets all available operations for the Microsoft.Web resource provider. Also exposes
     * resource metric definitions
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec);
    }
    /**
     * Description for Get available Web app frameworks and their versions
     * @param options The options parameters.
     */
    _getWebAppStacks(options) {
        return this.client.sendOperationRequest({ options }, getWebAppStacksOperationSpec);
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    _getAvailableStacksOnPrem(options) {
        return this.client.sendOperationRequest({ options }, getAvailableStacksOnPremOperationSpec);
    }
    /**
     * GetAvailableStacksNext
     * @param nextLink The nextLink from the previous successful call to the GetAvailableStacks method.
     * @param options The options parameters.
     */
    _getAvailableStacksNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getAvailableStacksNextOperationSpec);
    }
    /**
     * GetFunctionAppStacksNext
     * @param nextLink The nextLink from the previous successful call to the GetFunctionAppStacks method.
     * @param options The options parameters.
     */
    _getFunctionAppStacksNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getFunctionAppStacksNextOperationSpec);
    }
    /**
     * GetFunctionAppStacksForLocationNext
     * @param location Function App stack location.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetFunctionAppStacksForLocation method.
     * @param options The options parameters.
     */
    _getFunctionAppStacksForLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, getFunctionAppStacksForLocationNextOperationSpec);
    }
    /**
     * GetWebAppStacksForLocationNext
     * @param location Web App stack location.
     * @param nextLink The nextLink from the previous successful call to the GetWebAppStacksForLocation
     *                 method.
     * @param options The options parameters.
     */
    _getWebAppStacksForLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, getWebAppStacksForLocationNextOperationSpec);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec);
    }
    /**
     * GetWebAppStacksNext
     * @param nextLink The nextLink from the previous successful call to the GetWebAppStacks method.
     * @param options The options parameters.
     */
    _getWebAppStacksNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getWebAppStacksNextOperationSpec);
    }
    /**
     * GetAvailableStacksOnPremNext
     * @param nextLink The nextLink from the previous successful call to the GetAvailableStacksOnPrem
     *                 method.
     * @param options The options parameters.
     */
    _getAvailableStacksOnPremNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getAvailableStacksOnPremNextOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getAvailableStacksOperationSpec = {
    path: "/providers/Microsoft.Web/availableStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, osTypeSelected],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$e
};
const getFunctionAppStacksOperationSpec = {
    path: "/providers/Microsoft.Web/functionAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$e
};
const getFunctionAppStacksForLocationOperationSpec = {
    path: "/providers/Microsoft.Web/locations/{location}/functionAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType1],
    urlParameters: [$host, location],
    headerParameters: [accept],
    serializer: serializer$e
};
const getWebAppStacksForLocationOperationSpec = {
    path: "/providers/Microsoft.Web/locations/{location}/webAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType2],
    urlParameters: [$host, location],
    headerParameters: [accept],
    serializer: serializer$e
};
const listOperationsOperationSpec = {
    path: "/providers/Microsoft.Web/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$e
};
const getWebAppStacksOperationSpec = {
    path: "/providers/Microsoft.Web/webAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType3],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$e
};
const getAvailableStacksOnPremOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/availableStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, osTypeSelected1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$e
};
const getAvailableStacksNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, osTypeSelected],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$e
};
const getFunctionAppStacksNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$e
};
const getFunctionAppStacksForLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType1],
    urlParameters: [$host, nextLink, location],
    headerParameters: [accept],
    serializer: serializer$e
};
const getWebAppStacksForLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType2],
    urlParameters: [$host, nextLink, location],
    headerParameters: [accept],
    serializer: serializer$e
};
const listOperationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$e
};
const getWebAppStacksNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, stackOsType3],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$e
};
const getAvailableStacksOnPremNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, osTypeSelected1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Recommendations operations. */
class RecommendationsImpl {
    /**
     * Initialize a new instance of the class Recommendations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List all recommendations for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param options The options parameters.
     */
    listHistoryForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        const iter = this.listHistoryForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHistoryForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options);
            }
        };
    }
    listHistoryForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForHostingEnvironmentPagingPage_1() {
            let result = yield tslib.__await(this._listHistoryForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHistoryForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHistoryForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForHostingEnvironmentPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHistoryForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all recommendations for a hosting environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the app.
     * @param options The options parameters.
     */
    listRecommendedRulesForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        const iter = this.listRecommendedRulesForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRecommendedRulesForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options);
            }
        };
    }
    listRecommendedRulesForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForHostingEnvironmentPagingPage_1() {
            let result = yield tslib.__await(this._listRecommendedRulesForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedRulesForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRecommendedRulesForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForHostingEnvironmentPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRecommendedRulesForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    listHistoryForWebApp(resourceGroupName, siteName, options) {
        const iter = this.listHistoryForWebAppPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHistoryForWebAppPagingPage(resourceGroupName, siteName, options);
            }
        };
    }
    listHistoryForWebAppPagingPage(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForWebAppPagingPage_1() {
            let result = yield tslib.__await(this._listHistoryForWebApp(resourceGroupName, siteName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHistoryForWebAppNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHistoryForWebAppPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForWebAppPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHistoryForWebAppPagingPage(resourceGroupName, siteName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    listRecommendedRulesForWebApp(resourceGroupName, siteName, options) {
        const iter = this.listRecommendedRulesForWebAppPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRecommendedRulesForWebAppPagingPage(resourceGroupName, siteName, options);
            }
        };
    }
    listRecommendedRulesForWebAppPagingPage(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForWebAppPagingPage_1() {
            let result = yield tslib.__await(this._listRecommendedRulesForWebApp(resourceGroupName, siteName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedRulesForWebAppNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRecommendedRulesForWebAppPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForWebAppPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRecommendedRulesForWebAppPagingPage(resourceGroupName, siteName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List all recommendations for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$b);
    }
    /**
     * Description for Reset all recommendation opt-out settings for a subscription.
     * @param options The options parameters.
     */
    resetAllFilters(options) {
        return this.client.sendOperationRequest({ options }, resetAllFiltersOperationSpec);
    }
    /**
     * Description for Disables the specified rule so it will not apply to a subscription in the future.
     * @param name Rule name
     * @param options The options parameters.
     */
    disableRecommendationForSubscription(name, options) {
        return this.client.sendOperationRequest({ name, options }, disableRecommendationForSubscriptionOperationSpec);
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param options The options parameters.
     */
    _listHistoryForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, options }, listHistoryForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Get all recommendations for a hosting environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the app.
     * @param options The options parameters.
     */
    _listRecommendedRulesForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, options }, listRecommendedRulesForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Disable all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param environmentName Name of the app.
     * @param hostingEnvironmentName
     * @param options The options parameters.
     */
    disableAllForHostingEnvironment(resourceGroupName, environmentName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, hostingEnvironmentName, options }, disableAllForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Reset all recommendation opt-out settings for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param environmentName Name of the app.
     * @param hostingEnvironmentName
     * @param options The options parameters.
     */
    resetAllFiltersForHostingEnvironment(resourceGroupName, environmentName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, hostingEnvironmentName, options }, resetAllFiltersForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Get a recommendation rule for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param name Name of the recommendation.
     * @param options The options parameters.
     */
    getRuleDetailsByHostingEnvironment(resourceGroupName, hostingEnvironmentName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, name, options }, getRuleDetailsByHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Disables the specific rule for a web site permanently.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param environmentName Site name
     * @param name Rule name
     * @param hostingEnvironmentName
     * @param options The options parameters.
     */
    disableRecommendationForHostingEnvironment(resourceGroupName, environmentName, name, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            name,
            hostingEnvironmentName,
            options
        }, disableRecommendationForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    _listHistoryForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listHistoryForWebAppOperationSpec);
    }
    /**
     * Description for Get all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    _listRecommendedRulesForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listRecommendedRulesForWebAppOperationSpec);
    }
    /**
     * Description for Disable all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    disableAllForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, disableAllForWebAppOperationSpec);
    }
    /**
     * Description for Reset all recommendation opt-out settings for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    resetAllFiltersForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, resetAllFiltersForWebAppOperationSpec);
    }
    /**
     * Description for Get a recommendation rule for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param name Name of the recommendation.
     * @param options The options parameters.
     */
    getRuleDetailsByWebApp(resourceGroupName, siteName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, name, options }, getRuleDetailsByWebAppOperationSpec);
    }
    /**
     * Description for Disables the specific rule for a web site permanently.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site name
     * @param name Rule name
     * @param options The options parameters.
     */
    disableRecommendationForSite(resourceGroupName, siteName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, name, options }, disableRecommendationForSiteOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$b);
    }
    /**
     * ListHistoryForHostingEnvironmentNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListHistoryForHostingEnvironment method.
     * @param options The options parameters.
     */
    _listHistoryForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, nextLink, options }, listHistoryForHostingEnvironmentNextOperationSpec);
    }
    /**
     * ListRecommendedRulesForHostingEnvironmentNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListRecommendedRulesForHostingEnvironment method.
     * @param options The options parameters.
     */
    _listRecommendedRulesForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, nextLink, options }, listRecommendedRulesForHostingEnvironmentNextOperationSpec);
    }
    /**
     * ListHistoryForWebAppNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListHistoryForWebApp method.
     * @param options The options parameters.
     */
    _listHistoryForWebAppNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listHistoryForWebAppNextOperationSpec);
    }
    /**
     * ListRecommendedRulesForWebAppNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListRecommendedRulesForWebApp
     *                 method.
     * @param options The options parameters.
     */
    _listRecommendedRulesForWebAppNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listRecommendedRulesForWebAppNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        featured
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d
};
const resetAllFiltersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations/reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d
};
const disableRecommendationForSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations/{name}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$d
};
const listHistoryForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendationHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expiredOnly
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listRecommendedRulesForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        featured
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const disableAllForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/disable",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, environmentName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const resetAllFiltersForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, environmentName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getRuleDetailsByHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationRule
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        updateSeen,
        recommendationId
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const disableRecommendationForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/{name}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, environmentName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listHistoryForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendationHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expiredOnly
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listRecommendedRulesForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        featured
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const disableAllForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/disable",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const resetAllFiltersForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getRuleDetailsByWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationRule
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        updateSeen,
        recommendationId
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const disableRecommendationForSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/{name}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        featured
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listHistoryForHostingEnvironmentNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expiredOnly
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listRecommendedRulesForHostingEnvironmentNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        featured
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        hostingEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listHistoryForWebAppNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expiredOnly
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listRecommendedRulesForWebAppNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        featured
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourceHealthMetadataOperations operations. */
class ResourceHealthMetadataOperationsImpl {
    /**
     * Initialize a new instance of the class ResourceHealthMetadataOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the resource group in the
     * subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    listBySite(resourceGroupName, name, options) {
        const iter = this.listBySitePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySitePagingPage(resourceGroupName, name, options);
            }
        };
    }
    listBySitePagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySitePagingPage_1() {
            let result = yield tslib.__await(this._listBySite(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySiteNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySitePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySitePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySitePagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    listBySiteSlot(resourceGroupName, name, slot, options) {
        const iter = this.listBySiteSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySiteSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listBySiteSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySiteSlotPagingPage_1() {
            let result = yield tslib.__await(this._listBySiteSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySiteSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySiteSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySiteSlotPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySiteSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$a);
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the resource group in the
     * subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    _listBySite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBySiteOperationSpec);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param options The options parameters.
     */
    getBySite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getBySiteOperationSpec);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    _listBySiteSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listBySiteSlotOperationSpec);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getBySiteSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getBySiteSlotOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$a);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySiteNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param nextLink The nextLink from the previous successful call to the ListBySite method.
     * @param options The options parameters.
     */
    _listBySiteNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBySiteNextOperationSpec);
    }
    /**
     * ListBySiteSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param nextLink The nextLink from the previous successful call to the ListBySiteSlot method.
     * @param options The options parameters.
     */
    _listBySiteSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listBySiteSlotNextOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listBySiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getBySiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resourceHealthMetadata/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadata
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listBySiteSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getBySiteSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resourceHealthMetadata/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadata
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listBySiteNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listBySiteSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StaticSites operations. */
class StaticSitesImpl {
    /**
     * Initialize a new instance of the class StaticSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all Static Sites for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets all static sites in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listStaticSitesByResourceGroup(resourceGroupName, options) {
        const iter = this.getStaticSitesByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getStaticSitesByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    getStaticSitesByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSitesByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._getStaticSitesByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getStaticSitesByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getStaticSitesByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSitesByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getStaticSitesByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Gets the list of users of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for the users.
     * @param options The options parameters.
     */
    listStaticSiteUsers(resourceGroupName, name, authprovider, options) {
        const iter = this.listStaticSiteUsersPagingAll(resourceGroupName, name, authprovider, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listStaticSiteUsersPagingPage(resourceGroupName, name, authprovider, options);
            }
        };
    }
    listStaticSiteUsersPagingPage(resourceGroupName, name, authprovider, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteUsersPagingPage_1() {
            let result = yield tslib.__await(this._listStaticSiteUsers(resourceGroupName, name, authprovider, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteUsersNext(resourceGroupName, name, authprovider, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listStaticSiteUsersPagingAll(resourceGroupName, name, authprovider, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteUsersPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listStaticSiteUsersPagingPage(resourceGroupName, name, authprovider, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Gets all static site builds for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteBuilds(resourceGroupName, name, options) {
        const iter = this.getStaticSiteBuildsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getStaticSiteBuildsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getStaticSiteBuildsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSiteBuildsPagingPage_1() {
            let result = yield tslib.__await(this._getStaticSiteBuilds(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getStaticSiteBuildsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getStaticSiteBuildsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSiteBuildsPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getStaticSiteBuildsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Gets the functions of a particular static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listStaticSiteBuildFunctions(resourceGroupName, name, environmentName, options) {
        const iter = this.listStaticSiteBuildFunctionsPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listStaticSiteBuildFunctionsPagingPage(resourceGroupName, name, environmentName, options);
            }
        };
    }
    listStaticSiteBuildFunctionsPagingPage(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteBuildFunctionsPagingPage_1() {
            let result = yield tslib.__await(this._listStaticSiteBuildFunctions(resourceGroupName, name, environmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteBuildFunctionsNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listStaticSiteBuildFunctionsPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteBuildFunctionsPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listStaticSiteBuildFunctionsPagingPage(resourceGroupName, name, environmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        const iter = this.getUserProvidedFunctionAppsForStaticSiteBuildPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getUserProvidedFunctionAppsForStaticSiteBuildPagingPage(resourceGroupName, name, environmentName, options);
            }
        };
    }
    getUserProvidedFunctionAppsForStaticSiteBuildPagingPage(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSiteBuildPagingPage_1() {
            let result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName, name, environmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSiteBuildNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getUserProvidedFunctionAppsForStaticSiteBuildPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSiteBuildPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getUserProvidedFunctionAppsForStaticSiteBuildPagingPage(resourceGroupName, name, environmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Gets all static site custom domains for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param options The options parameters.
     */
    listStaticSiteCustomDomains(resourceGroupName, name, options) {
        const iter = this.listStaticSiteCustomDomainsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listStaticSiteCustomDomainsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listStaticSiteCustomDomainsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteCustomDomainsPagingPage_1() {
            let result = yield tslib.__await(this._listStaticSiteCustomDomains(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteCustomDomainsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listStaticSiteCustomDomainsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteCustomDomainsPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listStaticSiteCustomDomainsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Gets the functions of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteFunctions(resourceGroupName, name, options) {
        const iter = this.listStaticSiteFunctionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listStaticSiteFunctionsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listStaticSiteFunctionsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteFunctionsPagingPage_1() {
            let result = yield tslib.__await(this._listStaticSiteFunctions(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteFunctionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listStaticSiteFunctionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteFunctionsPagingAll_1() {
            var e_8, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listStaticSiteFunctionsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionList(resourceGroupName, name, options) {
        const iter = this.getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingPage_1() {
            let result = yield tslib.__await(this._getPrivateEndpointConnectionList(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingAll_1() {
            var e_9, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listUserProvidedFunctionAppsForStaticSite(resourceGroupName, name, options) {
        const iter = this.getUserProvidedFunctionAppsForStaticSitePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getUserProvidedFunctionAppsForStaticSitePagingPage(resourceGroupName, name, options);
            }
        };
    }
    getUserProvidedFunctionAppsForStaticSitePagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSitePagingPage_1() {
            let result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSite(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSiteNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getUserProvidedFunctionAppsForStaticSitePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSitePagingAll_1() {
            var e_10, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getUserProvidedFunctionAppsForStaticSitePagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Returns details of all backends linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    listLinkedBackends(resourceGroupName, name, options) {
        const iter = this.getLinkedBackendsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getLinkedBackendsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getLinkedBackendsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsPagingPage_1() {
            let result = yield tslib.__await(this._getLinkedBackends(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getLinkedBackendsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getLinkedBackendsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsPagingAll_1() {
            var e_11, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getLinkedBackendsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    }
    /**
     * Returns details of all backends linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param options The options parameters.
     */
    listLinkedBackendsForBuild(resourceGroupName, name, environmentName, options) {
        const iter = this.getLinkedBackendsForBuildPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getLinkedBackendsForBuildPagingPage(resourceGroupName, name, environmentName, options);
            }
        };
    }
    getLinkedBackendsForBuildPagingPage(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsForBuildPagingPage_1() {
            let result = yield tslib.__await(this._getLinkedBackendsForBuild(resourceGroupName, name, environmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getLinkedBackendsForBuildNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getLinkedBackendsForBuildPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsForBuildPagingAll_1() {
            var e_12, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getLinkedBackendsForBuildPagingPage(resourceGroupName, name, environmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    }
    /**
     * Description for Generates a preview workflow file for the static site
     * @param location Location where you plan to create the static site.
     * @param staticSitesWorkflowPreviewRequest A JSON representation of the
     *                                          StaticSitesWorkflowPreviewRequest properties. See example.
     * @param options The options parameters.
     */
    previewWorkflow(location, staticSitesWorkflowPreviewRequest, options) {
        return this.client.sendOperationRequest({ location, staticSitesWorkflowPreviewRequest, options }, previewWorkflowOperationSpec);
    }
    /**
     * Description for Get all Static Sites for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$9);
    }
    /**
     * Description for Gets all static sites in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _getStaticSitesByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, getStaticSitesByResourceGroupOperationSpec);
    }
    /**
     * Description for Gets the details of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    getStaticSite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getStaticSiteOperationSpec);
    }
    /**
     * Description for Creates a new static site in an existing resource group, or updates an existing
     * static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to create or update.
     * @param staticSiteEnvelope A JSON representation of the staticsite properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSite(resourceGroupName, name, staticSiteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, staticSiteEnvelope, options }, createOrUpdateStaticSiteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new static site in an existing resource group, or updates an existing
     * static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to create or update.
     * @param staticSiteEnvelope A JSON representation of the staticsite properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSiteAndWait(resourceGroupName, name, staticSiteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateStaticSite(resourceGroupName, name, staticSiteEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSite(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, deleteStaticSiteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteStaticSite(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates a new static site in an existing resource group, or updates an existing
     * static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to create or update.
     * @param staticSiteEnvelope A JSON representation of the staticsite properties. See example.
     * @param options The options parameters.
     */
    updateStaticSite(resourceGroupName, name, staticSiteEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, staticSiteEnvelope, options }, updateStaticSiteOperationSpec);
    }
    /**
     * Description for Gets the list of users of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for the users.
     * @param options The options parameters.
     */
    _listStaticSiteUsers(resourceGroupName, name, authprovider, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, authprovider, options }, listStaticSiteUsersOperationSpec);
    }
    /**
     * Description for Deletes the user entry from the static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the staticsite.
     * @param authprovider The auth provider for this user.
     * @param userid The user id of the user.
     * @param options The options parameters.
     */
    deleteStaticSiteUser(resourceGroupName, name, authprovider, userid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, authprovider, userid, options }, deleteStaticSiteUserOperationSpec);
    }
    /**
     * Description for Updates a user entry with the listed roles
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for this user.
     * @param userid The user id of the user.
     * @param staticSiteUserEnvelope A JSON representation of the StaticSiteUser properties. See example.
     * @param options The options parameters.
     */
    updateStaticSiteUser(resourceGroupName, name, authprovider, userid, staticSiteUserEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            authprovider,
            userid,
            staticSiteUserEnvelope,
            options
        }, updateStaticSiteUserOperationSpec);
    }
    /**
     * Description for Gets all static site builds for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _getStaticSiteBuilds(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getStaticSiteBuildsOperationSpec);
    }
    /**
     * Description for Gets the details of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    getStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Deletes a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, environmentName, options }, deleteStaticSiteBuildOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteBuildAndWait(resourceGroupName, name, environmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteStaticSiteBuild(resourceGroupName, name, environmentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates or updates the app settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param appSettings The dictionary containing the static site app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteBuildAppSettings(resourceGroupName, name, environmentName, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, appSettings, options }, createOrUpdateStaticSiteBuildAppSettingsOperationSpec);
    }
    /**
     * Description for Creates or updates the function app settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param appSettings The dictionary containing the static site function app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteBuildFunctionAppSettings(resourceGroupName, name, environmentName, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, appSettings, options }, createOrUpdateStaticSiteBuildFunctionAppSettingsOperationSpec);
    }
    /**
     * Description for Gets the functions of a particular static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    _listStaticSiteBuildFunctions(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, listStaticSiteBuildFunctionsOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listStaticSiteBuildAppSettings(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, listStaticSiteBuildAppSettingsOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listStaticSiteBuildFunctionAppSettings(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, listStaticSiteBuildFunctionAppSettingsOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getUserProvidedFunctionAppsForStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function app registered with a static site
     * build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app registered with the static site build.
     * @param options The options parameters.
     */
    getUserProvidedFunctionAppForStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, functionAppName, options }, getUserProvidedFunctionAppForStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Register a user provided function app with a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app to register with the static site build.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                environmentName,
                functionAppName,
                staticSiteUserProvidedFunctionEnvelope,
                options
            }, registerUserProvidedFunctionAppWithStaticSiteBuildOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Register a user provided function app with a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app to register with the static site build.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSiteBuildAndWait(resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegisterUserProvidedFunctionAppWithStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Detach the user provided function app from the static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app registered with the static site build.
     * @param options The options parameters.
     */
    detachUserProvidedFunctionAppFromStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, functionAppName, options }, detachUserProvidedFunctionAppFromStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Deploys zipped content to a specific environment of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName Name of the environment.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSiteBuild(resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                environmentName,
                staticSiteZipDeploymentEnvelope,
                options
            }, createZipDeploymentForStaticSiteBuildOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deploys zipped content to a specific environment of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName Name of the environment.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSiteBuildAndWait(resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateZipDeploymentForStaticSiteBuild(resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates or updates the app settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param appSettings The dictionary containing the static site app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteAppSettings(resourceGroupName, name, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettings, options }, createOrUpdateStaticSiteAppSettingsOperationSpec);
    }
    /**
     * Description for Creates or updates the function app settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param appSettings The dictionary containing the static site function app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteFunctionAppSettings(resourceGroupName, name, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettings, options }, createOrUpdateStaticSiteFunctionAppSettingsOperationSpec);
    }
    /**
     * Description for Creates an invitation link for a user with the role
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param staticSiteUserRolesInvitationEnvelope Static sites user roles invitation resource.
     * @param options The options parameters.
     */
    createUserRolesInvitationLink(resourceGroupName, name, staticSiteUserRolesInvitationEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            staticSiteUserRolesInvitationEnvelope,
            options
        }, createUserRolesInvitationLinkOperationSpec);
    }
    /**
     * Description for Gets all static site custom domains for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param options The options parameters.
     */
    _listStaticSiteCustomDomains(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteCustomDomainsOperationSpec);
    }
    /**
     * Description for Gets an existing custom domain for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param domainName The custom domain name.
     * @param options The options parameters.
     */
    getStaticSiteCustomDomain(resourceGroupName, name, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainName, options }, getStaticSiteCustomDomainOperationSpec);
    }
    /**
     * Description for Creates a new static site custom domain in an existing resource group and static
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to create.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSiteCustomDomain(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                domainName,
                staticSiteCustomDomainRequestPropertiesEnvelope,
                options
            }, createOrUpdateStaticSiteCustomDomainOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new static site custom domain in an existing resource group and static
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to create.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSiteCustomDomainAndWait(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateStaticSiteCustomDomain(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a custom domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteCustomDomain(resourceGroupName, name, domainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, domainName, options }, deleteStaticSiteCustomDomainOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a custom domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteCustomDomainAndWait(resourceGroupName, name, domainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteStaticSiteCustomDomain(resourceGroupName, name, domainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Validates a particular custom domain can be added to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to validate.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginValidateCustomDomainCanBeAddedToStaticSite(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                domainName,
                staticSiteCustomDomainRequestPropertiesEnvelope,
                options
            }, validateCustomDomainCanBeAddedToStaticSiteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Validates a particular custom domain can be added to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to validate.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginValidateCustomDomainCanBeAddedToStaticSiteAndWait(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateCustomDomainCanBeAddedToStaticSite(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Detaches a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to detach.
     * @param options The options parameters.
     */
    beginDetachStaticSite(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, detachStaticSiteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Detaches a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to detach.
     * @param options The options parameters.
     */
    beginDetachStaticSiteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDetachStaticSite(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the functions of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _listStaticSiteFunctions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteFunctionsOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteAppSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteAppSettingsOperationSpec);
    }
    /**
     * Description for Lists the roles configured for the static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteConfiguredRoles(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteConfiguredRolesOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteFunctionAppSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteFunctionAppSettingsOperationSpec);
    }
    /**
     * Description for Lists the secrets for an existing static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteSecrets(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteSecretsOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionList(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateEndpointConnectionListOperationSpec$1);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getPrivateEndpointConnectionOperationSpec$1);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param privateEndpointWrapper Request body.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                privateEndpointConnectionName,
                privateEndpointWrapper,
                options
            }, approveOrRejectPrivateEndpointConnectionOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param privateEndpointWrapper Request body.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, privateEndpointConnectionName, options }, deletePrivateEndpointConnectionOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateLinkResourcesOperationSpec$1);
    }
    /**
     * Description for Resets the api key for an existing static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param resetPropertiesEnvelope Static Site Reset Properties ARM resource.
     * @param options The options parameters.
     */
    resetStaticSiteApiKey(resourceGroupName, name, resetPropertiesEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, resetPropertiesEnvelope, options }, resetStaticSiteApiKeyOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getUserProvidedFunctionAppsForStaticSiteOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function app registered with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app registered with the static site.
     * @param options The options parameters.
     */
    getUserProvidedFunctionAppForStaticSite(resourceGroupName, name, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionAppName, options }, getUserProvidedFunctionAppForStaticSiteOperationSpec);
    }
    /**
     * Description for Register a user provided function app with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app to register with the static site.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSite(resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                functionAppName,
                staticSiteUserProvidedFunctionEnvelope,
                options
            }, registerUserProvidedFunctionAppWithStaticSiteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Register a user provided function app with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app to register with the static site.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSiteAndWait(resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegisterUserProvidedFunctionAppWithStaticSite(resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Detach the user provided function app from the static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app registered with the static site.
     * @param options The options parameters.
     */
    detachUserProvidedFunctionAppFromStaticSite(resourceGroupName, name, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionAppName, options }, detachUserProvidedFunctionAppFromStaticSiteOperationSpec);
    }
    /**
     * Description for Deploys zipped content to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSite(resourceGroupName, name, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, staticSiteZipDeploymentEnvelope, options }, createZipDeploymentForStaticSiteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deploys zipped content to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSiteAndWait(resourceGroupName, name, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateZipDeploymentForStaticSite(resourceGroupName, name, staticSiteZipDeploymentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates that a backend can be linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                linkedBackendName,
                staticSiteLinkedBackendEnvelope,
                options
            }, validateBackendOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates that a backend can be linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackendAndWait(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates that a backend can be linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackendForBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                environmentName,
                linkedBackendName,
                staticSiteLinkedBackendEnvelope,
                options
            }, validateBackendForBuildOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates that a backend can be linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackendForBuildAndWait(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateBackendForBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns details of all backends linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    _getLinkedBackends(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getLinkedBackendsOperationSpec);
    }
    /**
     * Returns details of all backends linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param options The options parameters.
     */
    _getLinkedBackendsForBuild(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getLinkedBackendsForBuildOperationSpec);
    }
    /**
     * Returns the details of a linked backend linked to a static site by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param options The options parameters.
     */
    getLinkedBackend(resourceGroupName, name, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, linkedBackendName, options }, getLinkedBackendOperationSpec);
    }
    /**
     * Link backend to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                linkedBackendName,
                staticSiteLinkedBackendEnvelope,
                options
            }, linkBackendOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Link backend to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackendAndWait(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginLinkBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Unlink a backend from a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the backend linked to the static site
     * @param options The options parameters.
     */
    unlinkBackend(resourceGroupName, name, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, linkedBackendName, options }, unlinkBackendOperationSpec);
    }
    /**
     * Returns the details of a linked backend linked to a static site build by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param options The options parameters.
     */
    getLinkedBackendForBuild(resourceGroupName, name, environmentName, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, linkedBackendName, options }, getLinkedBackendForBuildOperationSpec);
    }
    /**
     * Link backend to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackendToBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                environmentName,
                linkedBackendName,
                staticSiteLinkedBackendEnvelope,
                options
            }, linkBackendToBuildOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Link backend to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackendToBuildAndWait(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginLinkBackendToBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Unlink a backend from a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the backend linked to the static site
     * @param options The options parameters.
     */
    unlinkBackendFromBuild(resourceGroupName, name, environmentName, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, linkedBackendName, options }, unlinkBackendFromBuildOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$9);
    }
    /**
     * GetStaticSitesByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the GetStaticSitesByResourceGroup
     *                 method.
     * @param options The options parameters.
     */
    _getStaticSitesByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, getStaticSitesByResourceGroupNextOperationSpec);
    }
    /**
     * ListStaticSiteUsersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for the users.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteUsers method.
     * @param options The options parameters.
     */
    _listStaticSiteUsersNext(resourceGroupName, name, authprovider, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, authprovider, nextLink, options }, listStaticSiteUsersNextOperationSpec);
    }
    /**
     * GetStaticSiteBuildsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the GetStaticSiteBuilds method.
     * @param options The options parameters.
     */
    _getStaticSiteBuildsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getStaticSiteBuildsNextOperationSpec);
    }
    /**
     * ListStaticSiteBuildFunctionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteBuildFunctions
     *                 method.
     * @param options The options parameters.
     */
    _listStaticSiteBuildFunctionsNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, listStaticSiteBuildFunctionsNextOperationSpec);
    }
    /**
     * GetUserProvidedFunctionAppsForStaticSiteBuildNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetUserProvidedFunctionAppsForStaticSiteBuild method.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSiteBuildNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, getUserProvidedFunctionAppsForStaticSiteBuildNextOperationSpec);
    }
    /**
     * ListStaticSiteCustomDomainsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteCustomDomains
     *                 method.
     * @param options The options parameters.
     */
    _listStaticSiteCustomDomainsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listStaticSiteCustomDomainsNextOperationSpec);
    }
    /**
     * ListStaticSiteFunctionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteFunctions
     *                 method.
     * @param options The options parameters.
     */
    _listStaticSiteFunctionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listStaticSiteFunctionsNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionList method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getPrivateEndpointConnectionListNextOperationSpec$1);
    }
    /**
     * GetUserProvidedFunctionAppsForStaticSiteNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetUserProvidedFunctionAppsForStaticSite method.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSiteNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getUserProvidedFunctionAppsForStaticSiteNextOperationSpec);
    }
    /**
     * GetLinkedBackendsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param nextLink The nextLink from the previous successful call to the GetLinkedBackends method.
     * @param options The options parameters.
     */
    _getLinkedBackendsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getLinkedBackendsNextOperationSpec);
    }
    /**
     * GetLinkedBackendsForBuildNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param nextLink The nextLink from the previous successful call to the GetLinkedBackendsForBuild
     *                 method.
     * @param options The options parameters.
     */
    _getLinkedBackendsForBuildNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, getLinkedBackendsForBuildNextOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const previewWorkflowOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/previewStaticSiteWorkflowFile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StaticSitesWorkflowPreview
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSitesWorkflowPreviewRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/staticSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const getStaticSitesByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteARMResource
        },
        201: {
            bodyMapper: StaticSiteARMResource
        },
        202: {
            bodyMapper: StaticSiteARMResource
        },
        204: {
            bodyMapper: StaticSiteARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const updateStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StaticSiteARMResource
        },
        202: {
            bodyMapper: StaticSiteARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listStaticSiteUsersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/listUsers",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StaticSiteUserCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        authprovider
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const deleteStaticSiteUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/users/{userid}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        authprovider,
        userid
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const updateStaticSiteUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/users/{userid}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StaticSiteUserARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteUserEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        authprovider,
        userid
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const getStaticSiteBuildsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBuildCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBuildARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const deleteStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateStaticSiteBuildAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const createOrUpdateStaticSiteBuildFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/config/functionappsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listStaticSiteBuildFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteBuildAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/listAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteBuildFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/listFunctionAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getUserProvidedFunctionAppsForStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getUserProvidedFunctionAppForStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        functionAppName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const registerUserProvidedFunctionAppWithStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        201: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        202: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        204: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteUserProvidedFunctionEnvelope,
    queryParameters: [apiVersion, isForced],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        functionAppName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const detachUserProvidedFunctionAppFromStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        functionAppName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createZipDeploymentForStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/zipdeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteZipDeploymentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const createOrUpdateStaticSiteAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const createOrUpdateStaticSiteFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/config/functionappsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const createUserRolesInvitationLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/createUserInvitation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StaticSiteUserInvitationResponseResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteUserRolesInvitationEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listStaticSiteCustomDomainsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getStaticSiteCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateStaticSiteCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource
        },
        201: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource
        },
        202: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource
        },
        204: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteCustomDomainRequestPropertiesEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteStaticSiteCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const validateCustomDomainCanBeAddedToStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteCustomDomainRequestPropertiesEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const detachStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/detach",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteConfiguredRolesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listConfiguredRoles",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringList
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listFunctionAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getPrivateEndpointConnectionListOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getPrivateEndpointConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const approveOrRejectPrivateEndpointConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deletePrivateEndpointConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getPrivateLinkResourcesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const resetStaticSiteApiKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/resetapikey",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: resetPropertiesEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const getUserProvidedFunctionAppsForStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getUserProvidedFunctionAppForStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionAppName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const registerUserProvidedFunctionAppWithStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        201: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        202: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        204: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteUserProvidedFunctionEnvelope,
    queryParameters: [apiVersion, isForced],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionAppName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const detachUserProvidedFunctionAppFromStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionAppName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createZipDeploymentForStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/zipdeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteZipDeploymentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const validateBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const validateBackendForBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const getLinkedBackendsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLinkedBackendsForBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLinkedBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const linkBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        201: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        202: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        204: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const unlinkBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, isCleaningAuthConfig],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLinkedBackendForBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const linkBackendToBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        201: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        202: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        204: {
            bodyMapper: StaticSiteLinkedBackendARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const unlinkBackendFromBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, isCleaningAuthConfig],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getStaticSitesByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteUsersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        authprovider
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getStaticSiteBuildsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBuildCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteBuildFunctionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getUserProvidedFunctionAppsForStaticSiteBuildNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteCustomDomainsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listStaticSiteFunctionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getPrivateEndpointConnectionListNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getUserProvidedFunctionAppsForStaticSiteNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLinkedBackendsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLinkedBackendsForBuildNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WebApps operations. */
class WebAppsImpl {
    /**
     * Initialize a new instance of the class WebApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all apps for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets all web, mobile, and API apps in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listBackups(resourceGroupName, name, options) {
        const iter = this.listBackupsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBackupsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listBackupsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsPagingPage_1() {
            let result = yield tslib.__await(this._listBackups(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBackupsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBackupsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBackupsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listBasicPublishingCredentialsPolicies(resourceGroupName, name, options) {
        const iter = this.listBasicPublishingCredentialsPoliciesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBasicPublishingCredentialsPoliciesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listBasicPublishingCredentialsPoliciesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesPagingPage_1() {
            let result = yield tslib.__await(this._listBasicPublishingCredentialsPolicies(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBasicPublishingCredentialsPoliciesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBasicPublishingCredentialsPoliciesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBasicPublishingCredentialsPoliciesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listConfigurations(resourceGroupName, name, options) {
        const iter = this.listConfigurationsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listConfigurationsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listConfigurationsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsPagingPage_1() {
            let result = yield tslib.__await(this._listConfigurations(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listConfigurationsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConfigurationsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listAppSettingsKeyVaultReferences(resourceGroupName, name, options) {
        const iter = this.getAppSettingsKeyVaultReferencesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getAppSettingsKeyVaultReferencesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getAppSettingsKeyVaultReferencesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesPagingPage_1() {
            let result = yield tslib.__await(this._getAppSettingsKeyVaultReferences(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getAppSettingsKeyVaultReferencesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getAppSettingsKeyVaultReferencesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getAppSettingsKeyVaultReferencesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSiteConnectionStringKeyVaultReferences(resourceGroupName, name, options) {
        const iter = this.getSiteConnectionStringKeyVaultReferencesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getSiteConnectionStringKeyVaultReferencesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getSiteConnectionStringKeyVaultReferencesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesPagingPage_1() {
            let result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferences(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferencesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getSiteConnectionStringKeyVaultReferencesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getSiteConnectionStringKeyVaultReferencesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listConfigurationSnapshotInfo(resourceGroupName, name, options) {
        const iter = this.listConfigurationSnapshotInfoPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listConfigurationSnapshotInfoPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listConfigurationSnapshotInfoPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoPagingPage_1() {
            let result = yield tslib.__await(this._listConfigurationSnapshotInfo(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationSnapshotInfoNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listConfigurationSnapshotInfoPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoPagingAll_1() {
            var e_8, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConfigurationSnapshotInfoPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listContinuousWebJobs(resourceGroupName, name, options) {
        const iter = this.listContinuousWebJobsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listContinuousWebJobsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listContinuousWebJobsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsPagingPage_1() {
            let result = yield tslib.__await(this._listContinuousWebJobs(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listContinuousWebJobsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listContinuousWebJobsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsPagingAll_1() {
            var e_9, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listContinuousWebJobsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listProductionSiteDeploymentStatuses(resourceGroupName, name, options) {
        const iter = this.listProductionSiteDeploymentStatusesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProductionSiteDeploymentStatusesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listProductionSiteDeploymentStatusesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProductionSiteDeploymentStatusesPagingPage_1() {
            let result = yield tslib.__await(this._listProductionSiteDeploymentStatuses(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProductionSiteDeploymentStatusesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProductionSiteDeploymentStatusesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProductionSiteDeploymentStatusesPagingAll_1() {
            var e_10, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProductionSiteDeploymentStatusesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listDeployments(resourceGroupName, name, options) {
        const iter = this.listDeploymentsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listDeploymentsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listDeploymentsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsPagingPage_1() {
            let result = yield tslib.__await(this._listDeployments(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listDeploymentsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listDeploymentsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsPagingAll_1() {
            var e_11, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDeploymentsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listDomainOwnershipIdentifiers(resourceGroupName, name, options) {
        const iter = this.listDomainOwnershipIdentifiersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listDomainOwnershipIdentifiersPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listDomainOwnershipIdentifiersPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersPagingPage_1() {
            let result = yield tslib.__await(this._listDomainOwnershipIdentifiers(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listDomainOwnershipIdentifiersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listDomainOwnershipIdentifiersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersPagingAll_1() {
            var e_12, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDomainOwnershipIdentifiersPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listFunctions(resourceGroupName, name, options) {
        const iter = this.listFunctionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listFunctionsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listFunctionsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listFunctionsPagingPage_1() {
            let result = yield tslib.__await(this._listFunctions(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listFunctionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listFunctionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listFunctionsPagingAll_1() {
            var e_13, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listFunctionsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_13) throw e_13.error; }
            }
        });
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listHostNameBindings(resourceGroupName, name, options) {
        const iter = this.listHostNameBindingsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHostNameBindingsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listHostNameBindingsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsPagingPage_1() {
            let result = yield tslib.__await(this._listHostNameBindings(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHostNameBindingsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHostNameBindingsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsPagingAll_1() {
            var e_14, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHostNameBindingsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_14) throw e_14.error; }
            }
        });
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listInstanceIdentifiers(resourceGroupName, name, options) {
        const iter = this.listInstanceIdentifiersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceIdentifiersPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listInstanceIdentifiersPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceIdentifiers(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceIdentifiersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceIdentifiersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersPagingAll_1() {
            var e_15, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceIdentifiersPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_15) throw e_15.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcesses(resourceGroupName, name, instanceId, options) {
        const iter = this.listInstanceProcessesPagingAll(resourceGroupName, name, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceProcessesPagingPage(resourceGroupName, name, instanceId, options);
            }
        };
    }
    listInstanceProcessesPagingPage(resourceGroupName, name, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceProcesses(resourceGroupName, name, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessesNext(resourceGroupName, name, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceProcessesPagingAll(resourceGroupName, name, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesPagingAll_1() {
            var e_16, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceProcessesPagingPage(resourceGroupName, name, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_16) throw e_16.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessModules(resourceGroupName, name, processId, instanceId, options) {
        const iter = this.listInstanceProcessModulesPagingAll(resourceGroupName, name, processId, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceProcessModulesPagingPage(resourceGroupName, name, processId, instanceId, options);
            }
        };
    }
    listInstanceProcessModulesPagingPage(resourceGroupName, name, processId, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceProcessModules(resourceGroupName, name, processId, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessModulesNext(resourceGroupName, name, processId, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceProcessModulesPagingAll(resourceGroupName, name, processId, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesPagingAll_1() {
            var e_17, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceProcessModulesPagingPage(resourceGroupName, name, processId, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_17) throw e_17.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, options) {
        const iter = this.listInstanceProcessThreadsPagingAll(resourceGroupName, name, processId, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceProcessThreadsPagingPage(resourceGroupName, name, processId, instanceId, options);
            }
        };
    }
    listInstanceProcessThreadsPagingPage(resourceGroupName, name, processId, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessThreadsNext(resourceGroupName, name, processId, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceProcessThreadsPagingAll(resourceGroupName, name, processId, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsPagingAll_1() {
            var e_18, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceProcessThreadsPagingPage(resourceGroupName, name, processId, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_18) throw e_18.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSiteBackups(resourceGroupName, name, options) {
        const iter = this.listSiteBackupsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteBackupsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listSiteBackupsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsPagingPage_1() {
            let result = yield tslib.__await(this._listSiteBackups(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteBackupsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteBackupsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsPagingAll_1() {
            var e_19, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteBackupsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_19) throw e_19.error; }
            }
        });
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    listPerfMonCounters(resourceGroupName, name, options) {
        const iter = this.listPerfMonCountersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPerfMonCountersPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listPerfMonCountersPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersPagingPage_1() {
            let result = yield tslib.__await(this._listPerfMonCounters(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPerfMonCountersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPerfMonCountersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersPagingAll_1() {
            var e_20, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPerfMonCountersPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_20_1) { e_20 = { error: e_20_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_20) throw e_20.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionList(resourceGroupName, name, options) {
        const iter = this.getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options);
            }
        };
    }
    getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingPage_1() {
            let result = yield tslib.__await(this._getPrivateEndpointConnectionList(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingAll_1() {
            var e_21, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_21) throw e_21.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listProcesses(resourceGroupName, name, options) {
        const iter = this.listProcessesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProcessesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listProcessesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesPagingPage_1() {
            let result = yield tslib.__await(this._listProcesses(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProcessesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesPagingAll_1() {
            var e_22, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProcessesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_22) throw e_22.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    listProcessModules(resourceGroupName, name, processId, options) {
        const iter = this.listProcessModulesPagingAll(resourceGroupName, name, processId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProcessModulesPagingPage(resourceGroupName, name, processId, options);
            }
        };
    }
    listProcessModulesPagingPage(resourceGroupName, name, processId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesPagingPage_1() {
            let result = yield tslib.__await(this._listProcessModules(resourceGroupName, name, processId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessModulesNext(resourceGroupName, name, processId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProcessModulesPagingAll(resourceGroupName, name, processId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesPagingAll_1() {
            var e_23, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProcessModulesPagingPage(resourceGroupName, name, processId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_23) throw e_23.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    listProcessThreads(resourceGroupName, name, processId, options) {
        const iter = this.listProcessThreadsPagingAll(resourceGroupName, name, processId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProcessThreadsPagingPage(resourceGroupName, name, processId, options);
            }
        };
    }
    listProcessThreadsPagingPage(resourceGroupName, name, processId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsPagingPage_1() {
            let result = yield tslib.__await(this._listProcessThreads(resourceGroupName, name, processId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessThreadsNext(resourceGroupName, name, processId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProcessThreadsPagingAll(resourceGroupName, name, processId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsPagingAll_1() {
            var e_24, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProcessThreadsPagingPage(resourceGroupName, name, processId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_24_1) { e_24 = { error: e_24_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_24) throw e_24.error; }
            }
        });
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listPublicCertificates(resourceGroupName, name, options) {
        const iter = this.listPublicCertificatesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPublicCertificatesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listPublicCertificatesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesPagingPage_1() {
            let result = yield tslib.__await(this._listPublicCertificates(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPublicCertificatesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPublicCertificatesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesPagingAll_1() {
            var e_25, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPublicCertificatesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_25_1) { e_25 = { error: e_25_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_25) throw e_25.error; }
            }
        });
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listSiteExtensions(resourceGroupName, name, options) {
        const iter = this.listSiteExtensionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteExtensionsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listSiteExtensionsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsPagingPage_1() {
            let result = yield tslib.__await(this._listSiteExtensions(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteExtensionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteExtensionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsPagingAll_1() {
            var e_26, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteExtensionsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_26_1) { e_26 = { error: e_26_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_26) throw e_26.error; }
            }
        });
    }
    /**
     * Description for Gets an app's deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSlots(resourceGroupName, name, options) {
        const iter = this.listSlotsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSlotsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listSlotsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotsPagingPage_1() {
            let result = yield tslib.__await(this._listSlots(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSlotsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotsPagingAll_1() {
            var e_27, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSlotsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_27_1) { e_27 = { error: e_27_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_27) throw e_27.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    listBackupsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listBackupsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBackupsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listBackupsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listBackupsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBackupsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBackupsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsSlotPagingAll_1() {
            var e_28, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBackupsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_28_1) { e_28 = { error: e_28_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_28) throw e_28.error; }
            }
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    listBasicPublishingCredentialsPoliciesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listBasicPublishingCredentialsPoliciesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBasicPublishingCredentialsPoliciesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listBasicPublishingCredentialsPoliciesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listBasicPublishingCredentialsPoliciesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBasicPublishingCredentialsPoliciesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBasicPublishingCredentialsPoliciesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesSlotPagingAll_1() {
            var e_29, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBasicPublishingCredentialsPoliciesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_29_1) { e_29 = { error: e_29_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_29) throw e_29.error; }
            }
        });
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    listConfigurationsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listConfigurationsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listConfigurationsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listConfigurationsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listConfigurationsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listConfigurationsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsSlotPagingAll_1() {
            var e_30, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConfigurationsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_30_1) { e_30 = { error: e_30_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_30) throw e_30.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    listAppSettingsKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        const iter = this.getAppSettingsKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getAppSettingsKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    getAppSettingsKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesSlotPagingPage_1() {
            let result = yield tslib.__await(this._getAppSettingsKeyVaultReferencesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getAppSettingsKeyVaultReferencesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getAppSettingsKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesSlotPagingAll_1() {
            var e_31, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getAppSettingsKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_31_1) { e_31 = { error: e_31_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_31) throw e_31.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    listSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        const iter = this.getSiteConnectionStringKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getSiteConnectionStringKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    getSiteConnectionStringKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesSlotPagingPage_1() {
            let result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferencesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getSiteConnectionStringKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesSlotPagingAll_1() {
            var e_32, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getSiteConnectionStringKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_32_1) { e_32 = { error: e_32_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_32) throw e_32.error; }
            }
        });
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options) {
        const iter = this.listConfigurationSnapshotInfoSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listConfigurationSnapshotInfoSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listConfigurationSnapshotInfoSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoSlotPagingPage_1() {
            let result = yield tslib.__await(this._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationSnapshotInfoSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listConfigurationSnapshotInfoSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoSlotPagingAll_1() {
            var e_33, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConfigurationSnapshotInfoSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_33_1) { e_33 = { error: e_33_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_33) throw e_33.error; }
            }
        });
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    listContinuousWebJobsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listContinuousWebJobsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listContinuousWebJobsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listContinuousWebJobsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listContinuousWebJobsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listContinuousWebJobsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listContinuousWebJobsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsSlotPagingAll_1() {
            var e_34, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listContinuousWebJobsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_34_1) { e_34 = { error: e_34_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_34) throw e_34.error; }
            }
        });
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param options The options parameters.
     */
    listSlotSiteDeploymentStatusesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSlotSiteDeploymentStatusesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSlotSiteDeploymentStatusesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listSlotSiteDeploymentStatusesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotSiteDeploymentStatusesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSlotSiteDeploymentStatusesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotSiteDeploymentStatusesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSlotSiteDeploymentStatusesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotSiteDeploymentStatusesSlotPagingAll_1() {
            var e_35, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSlotSiteDeploymentStatusesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_35_1) { e_35 = { error: e_35_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_35) throw e_35.error; }
            }
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listDeploymentsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listDeploymentsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listDeploymentsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listDeploymentsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listDeploymentsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listDeploymentsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listDeploymentsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsSlotPagingAll_1() {
            var e_36, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDeploymentsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_36_1) { e_36 = { error: e_36_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_36) throw e_36.error; }
            }
        });
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listDomainOwnershipIdentifiersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listDomainOwnershipIdentifiersSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listDomainOwnershipIdentifiersSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersSlotPagingPage_1() {
            let result = yield tslib.__await(this._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listDomainOwnershipIdentifiersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listDomainOwnershipIdentifiersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersSlotPagingAll_1() {
            var e_37, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDomainOwnershipIdentifiersSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_37_1) { e_37 = { error: e_37_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_37) throw e_37.error; }
            }
        });
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listInstanceFunctionsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listInstanceFunctionsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceFunctionsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listInstanceFunctionsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceFunctionsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceFunctionsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceFunctionsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceFunctionsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceFunctionsSlotPagingAll_1() {
            var e_38, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceFunctionsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_38_1) { e_38 = { error: e_38_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_38) throw e_38.error; }
            }
        });
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    listHostNameBindingsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listHostNameBindingsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHostNameBindingsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listHostNameBindingsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listHostNameBindingsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHostNameBindingsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHostNameBindingsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsSlotPagingAll_1() {
            var e_39, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHostNameBindingsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_39_1) { e_39 = { error: e_39_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_39) throw e_39.error; }
            }
        });
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param options The options parameters.
     */
    listInstanceIdentifiersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listInstanceIdentifiersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceIdentifiersSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listInstanceIdentifiersSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersSlotPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceIdentifiersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceIdentifiersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersSlotPagingAll_1() {
            var e_40, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceIdentifiersSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_40_1) { e_40 = { error: e_40_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_40) throw e_40.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, options) {
        const iter = this.listInstanceProcessesSlotPagingAll(resourceGroupName, name, slot, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceProcessesSlotPagingPage(resourceGroupName, name, slot, instanceId, options);
            }
        };
    }
    listInstanceProcessesSlotPagingPage(resourceGroupName, name, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessesSlotNext(resourceGroupName, name, slot, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceProcessesSlotPagingAll(resourceGroupName, name, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesSlotPagingAll_1() {
            var e_41, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceProcessesSlotPagingPage(resourceGroupName, name, slot, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_41_1) { e_41 = { error: e_41_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_41) throw e_41.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        const iter = this.listInstanceProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options);
            }
        };
    }
    listInstanceProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessModulesSlotNext(resourceGroupName, name, processId, slot, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesSlotPagingAll_1() {
            var e_42, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_42_1) { e_42 = { error: e_42_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_42) throw e_42.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        const iter = this.listInstanceProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInstanceProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options);
            }
        };
    }
    listInstanceProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessThreadsSlotNext(resourceGroupName, name, processId, slot, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInstanceProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsSlotPagingAll_1() {
            var e_43, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInstanceProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_43_1) { e_43 = { error: e_43_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_43) throw e_43.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    listSiteBackupsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSiteBackupsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteBackupsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listSiteBackupsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSiteBackupsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteBackupsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteBackupsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsSlotPagingAll_1() {
            var e_44, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteBackupsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_44_1) { e_44 = { error: e_44_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_44) throw e_44.error; }
            }
        });
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    listPerfMonCountersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listPerfMonCountersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPerfMonCountersSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listPerfMonCountersSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersSlotPagingPage_1() {
            let result = yield tslib.__await(this._listPerfMonCountersSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPerfMonCountersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPerfMonCountersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersSlotPagingAll_1() {
            var e_45, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPerfMonCountersSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_45_1) { e_45 = { error: e_45_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_45) throw e_45.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot Name of the site deployment slot.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionListSlot(resourceGroupName, name, slot, options) {
        const iter = this.getPrivateEndpointConnectionListSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getPrivateEndpointConnectionListSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    getPrivateEndpointConnectionListSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListSlotPagingPage_1() {
            let result = yield tslib.__await(this._getPrivateEndpointConnectionListSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getPrivateEndpointConnectionListSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListSlotPagingAll_1() {
            var e_46, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getPrivateEndpointConnectionListSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_46_1) { e_46 = { error: e_46_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_46) throw e_46.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listProcessesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listProcessesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProcessesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listProcessesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listProcessesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProcessesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesSlotPagingAll_1() {
            var e_47, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProcessesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_47_1) { e_47 = { error: e_47_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_47) throw e_47.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listProcessModulesSlot(resourceGroupName, name, processId, slot, options) {
        const iter = this.listProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, options);
            }
        };
    }
    listProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listProcessModulesSlot(resourceGroupName, name, processId, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessModulesSlotNext(resourceGroupName, name, processId, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesSlotPagingAll_1() {
            var e_48, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_48_1) { e_48 = { error: e_48_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_48) throw e_48.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listProcessThreadsSlot(resourceGroupName, name, processId, slot, options) {
        const iter = this.listProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, options);
            }
        };
    }
    listProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listProcessThreadsSlot(resourceGroupName, name, processId, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessThreadsSlotNext(resourceGroupName, name, processId, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsSlotPagingAll_1() {
            var e_49, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_49_1) { e_49 = { error: e_49_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_49) throw e_49.error; }
            }
        });
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    listPublicCertificatesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listPublicCertificatesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPublicCertificatesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listPublicCertificatesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listPublicCertificatesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPublicCertificatesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPublicCertificatesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesSlotPagingAll_1() {
            var e_50, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPublicCertificatesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_50_1) { e_50 = { error: e_50_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_50) throw e_50.error; }
            }
        });
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    listSiteExtensionsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSiteExtensionsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteExtensionsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listSiteExtensionsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSiteExtensionsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteExtensionsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteExtensionsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsSlotPagingAll_1() {
            var e_51, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteExtensionsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_51_1) { e_51 = { error: e_51_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_51) throw e_51.error; }
            }
        });
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    listSlotDifferencesSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        const iter = this.listSlotDifferencesSlotPagingAll(resourceGroupName, name, slot, slotSwapEntity, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSlotDifferencesSlotPagingPage(resourceGroupName, name, slot, slotSwapEntity, options);
            }
        };
    }
    listSlotDifferencesSlotPagingPage(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSlotDifferencesSlot(resourceGroupName, name, slot, slotSwapEntity, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotDifferencesSlotNext(resourceGroupName, name, slot, slotSwapEntity, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSlotDifferencesSlotPagingAll(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesSlotPagingAll_1() {
            var e_52, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSlotDifferencesSlotPagingPage(resourceGroupName, name, slot, slotSwapEntity, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_52_1) { e_52 = { error: e_52_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_52) throw e_52.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    listSnapshotsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSnapshotsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSnapshotsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listSnapshotsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listSnapshotsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSnapshotsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsSlotPagingAll_1() {
            var e_53, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSnapshotsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_53_1) { e_53 = { error: e_53_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_53) throw e_53.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    listSnapshotsFromDRSecondarySlot(resourceGroupName, name, slot, options) {
        const iter = this.listSnapshotsFromDRSecondarySlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSnapshotsFromDRSecondarySlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listSnapshotsFromDRSecondarySlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondarySlotPagingPage_1() {
            let result = yield tslib.__await(this._listSnapshotsFromDRSecondarySlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsFromDRSecondarySlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSnapshotsFromDRSecondarySlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondarySlotPagingAll_1() {
            var e_54, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSnapshotsFromDRSecondarySlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_54_1) { e_54 = { error: e_54_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_54) throw e_54.error; }
            }
        });
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    listTriggeredWebJobsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listTriggeredWebJobsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listTriggeredWebJobsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listTriggeredWebJobsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listTriggeredWebJobsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listTriggeredWebJobsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsSlotPagingAll_1() {
            var e_55, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listTriggeredWebJobsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_55_1) { e_55 = { error: e_55_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_55) throw e_55.error; }
            }
        });
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, options) {
        const iter = this.listTriggeredWebJobHistorySlotPagingAll(resourceGroupName, name, webJobName, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listTriggeredWebJobHistorySlotPagingPage(resourceGroupName, name, webJobName, slot, options);
            }
        };
    }
    listTriggeredWebJobHistorySlotPagingPage(resourceGroupName, name, webJobName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistorySlotPagingPage_1() {
            let result = yield tslib.__await(this._listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobHistorySlotNext(resourceGroupName, name, webJobName, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listTriggeredWebJobHistorySlotPagingAll(resourceGroupName, name, webJobName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistorySlotPagingAll_1() {
            var e_56, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listTriggeredWebJobHistorySlotPagingPage(resourceGroupName, name, webJobName, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_56_1) { e_56 = { error: e_56_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_56) throw e_56.error; }
            }
        });
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota
     *             information of the production slot.
     * @param options The options parameters.
     */
    listUsagesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listUsagesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUsagesSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listUsagesSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesSlotPagingPage_1() {
            let result = yield tslib.__await(this._listUsagesSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listUsagesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesSlotPagingAll_1() {
            var e_57, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagesSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_57_1) { e_57 = { error: e_57_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_57) throw e_57.error; }
            }
        });
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listWebJobsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listWebJobsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebJobsSlotPagingPage(resourceGroupName, name, slot, options);
            }
        };
    }
    listWebJobsSlotPagingPage(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsSlotPagingPage_1() {
            let result = yield tslib.__await(this._listWebJobsSlot(resourceGroupName, name, slot, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebJobsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebJobsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsSlotPagingAll_1() {
            var e_58, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebJobsSlotPagingPage(resourceGroupName, name, slot, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_58_1) { e_58 = { error: e_58_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_58) throw e_58.error; }
            }
        });
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options) {
        const iter = this.listSlotDifferencesFromProductionPagingAll(resourceGroupName, name, slotSwapEntity, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSlotDifferencesFromProductionPagingPage(resourceGroupName, name, slotSwapEntity, options);
            }
        };
    }
    listSlotDifferencesFromProductionPagingPage(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesFromProductionPagingPage_1() {
            let result = yield tslib.__await(this._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotDifferencesFromProductionNext(resourceGroupName, name, slotSwapEntity, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSlotDifferencesFromProductionPagingAll(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesFromProductionPagingAll_1() {
            var e_59, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSlotDifferencesFromProductionPagingPage(resourceGroupName, name, slotSwapEntity, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_59_1) { e_59 = { error: e_59_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_59) throw e_59.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    listSnapshots(resourceGroupName, name, options) {
        const iter = this.listSnapshotsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSnapshotsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listSnapshotsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsPagingPage_1() {
            let result = yield tslib.__await(this._listSnapshots(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSnapshotsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsPagingAll_1() {
            var e_60, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSnapshotsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_60_1) { e_60 = { error: e_60_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_60) throw e_60.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    listSnapshotsFromDRSecondary(resourceGroupName, name, options) {
        const iter = this.listSnapshotsFromDRSecondaryPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSnapshotsFromDRSecondaryPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listSnapshotsFromDRSecondaryPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondaryPagingPage_1() {
            let result = yield tslib.__await(this._listSnapshotsFromDRSecondary(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsFromDRSecondaryNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSnapshotsFromDRSecondaryPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondaryPagingAll_1() {
            var e_61, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSnapshotsFromDRSecondaryPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_61_1) { e_61 = { error: e_61_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_61) throw e_61.error; }
            }
        });
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listTriggeredWebJobs(resourceGroupName, name, options) {
        const iter = this.listTriggeredWebJobsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listTriggeredWebJobsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listTriggeredWebJobsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsPagingPage_1() {
            let result = yield tslib.__await(this._listTriggeredWebJobs(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listTriggeredWebJobsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsPagingAll_1() {
            var e_62, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listTriggeredWebJobsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_62_1) { e_62 = { error: e_62_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_62) throw e_62.error; }
            }
        });
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    listTriggeredWebJobHistory(resourceGroupName, name, webJobName, options) {
        const iter = this.listTriggeredWebJobHistoryPagingAll(resourceGroupName, name, webJobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listTriggeredWebJobHistoryPagingPage(resourceGroupName, name, webJobName, options);
            }
        };
    }
    listTriggeredWebJobHistoryPagingPage(resourceGroupName, name, webJobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistoryPagingPage_1() {
            let result = yield tslib.__await(this._listTriggeredWebJobHistory(resourceGroupName, name, webJobName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobHistoryNext(resourceGroupName, name, webJobName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listTriggeredWebJobHistoryPagingAll(resourceGroupName, name, webJobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistoryPagingAll_1() {
            var e_63, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listTriggeredWebJobHistoryPagingPage(resourceGroupName, name, webJobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_63_1) { e_63 = { error: e_63_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_63) throw e_63.error; }
            }
        });
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, name, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUsagesPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result = yield tslib.__await(this._listUsages(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var e_64, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_64_1) { e_64 = { error: e_64_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_64) throw e_64.error; }
            }
        });
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listWebJobs(resourceGroupName, name, options) {
        const iter = this.listWebJobsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listWebJobsPagingPage(resourceGroupName, name, options);
            }
        };
    }
    listWebJobsPagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsPagingPage_1() {
            let result = yield tslib.__await(this._listWebJobs(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listWebJobsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listWebJobsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsPagingAll_1() {
            var e_65, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listWebJobsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_65_1) { e_65 = { error: e_65_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_65) throw e_65.error; }
            }
        });
    }
    /**
     * Description for Get all apps for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * Description for Gets all web, mobile, and API apps in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Description for Gets the details of a web, mobile, or API app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$8);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, siteEnvelope, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a web, mobile, or API app, or one of the deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, siteEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteEnvelope, options }, updateOperationSpec);
    }
    /**
     * Description for Analyze a custom hostname.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    analyzeCustomHostname(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, analyzeCustomHostnameOperationSpec);
    }
    /**
     * Description for Applies the configuration settings from the target slot onto the current slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotSwapEntity, options }, applySlotConfigToProductionOperationSpec);
    }
    /**
     * Description for Creates a backup of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input
     *                here.
     * @param options The options parameters.
     */
    backup(resourceGroupName, name, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, request, options }, backupOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listBackups(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBackupsOperationSpec);
    }
    /**
     * Description for Gets a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param options The options parameters.
     */
    getBackupStatus(resourceGroupName, name, backupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, options }, getBackupStatusOperationSpec);
    }
    /**
     * Description for Deletes a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param options The options parameters.
     */
    deleteBackup(resourceGroupName, name, backupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, options }, deleteBackupOperationSpec);
    }
    /**
     * Description for Gets status of a web app backup that may be in progress, including secrets
     * associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS
     * URL for the backup if a new URL is passed in the request body.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param request Information on backup request.
     * @param options The options parameters.
     */
    listBackupStatusSecrets(resourceGroupName, name, backupId, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, request, options }, listBackupStatusSecretsOperationSpec);
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestore(resourceGroupName, name, backupId, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, backupId, request, options }, restoreOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreAndWait(resourceGroupName, name, backupId, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestore(resourceGroupName, name, backupId, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPolicies(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBasicPublishingCredentialsPoliciesOperationSpec);
    }
    /**
     * Description for Returns whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getFtpAllowed(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getFtpAllowedOperationSpec);
    }
    /**
     * Description for Updates whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateFtpAllowed(resourceGroupName, name, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, csmPublishingAccessPoliciesEntity, options }, updateFtpAllowedOperationSpec);
    }
    /**
     * Description for Returns whether Scm basic auth is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getScmAllowed(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getScmAllowedOperationSpec);
    }
    /**
     * Description for Updates whether user publishing credentials are allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateScmAllowed(resourceGroupName, name, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, csmPublishingAccessPoliciesEntity, options }, updateScmAllowedOperationSpec);
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listConfigurations(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listConfigurationsOperationSpec);
    }
    /**
     * Description for Replaces the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @param options The options parameters.
     */
    updateApplicationSettings(resourceGroupName, name, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettings, options }, updateApplicationSettingsOperationSpec);
    }
    /**
     * Description for Gets the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listApplicationSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listApplicationSettingsOperationSpec);
    }
    /**
     * Description for Updates the Authentication / Authorization settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettings Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettings(resourceGroupName, name, siteAuthSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteAuthSettings, options }, updateAuthSettingsOperationSpec);
    }
    /**
     * Description for Gets the Authentication/Authorization settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getAuthSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAuthSettingsOperationSpec);
    }
    /**
     * Description for Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getAuthSettingsV2WithoutSecrets(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAuthSettingsV2WithoutSecretsOperationSpec);
    }
    /**
     * Description for Updates site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettingsV2 Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettingsV2(resourceGroupName, name, siteAuthSettingsV2, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteAuthSettingsV2, options }, updateAuthSettingsV2OperationSpec);
    }
    /**
     * Description for Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getAuthSettingsV2(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAuthSettingsV2OperationSpec);
    }
    /**
     * Description for Updates the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param azureStorageAccounts Azure storage accounts of the app.
     * @param options The options parameters.
     */
    updateAzureStorageAccounts(resourceGroupName, name, azureStorageAccounts, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, azureStorageAccounts, options }, updateAzureStorageAccountsOperationSpec);
    }
    /**
     * Description for Gets the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listAzureStorageAccounts(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listAzureStorageAccountsOperationSpec);
    }
    /**
     * Description for Updates the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @param options The options parameters.
     */
    updateBackupConfiguration(resourceGroupName, name, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, request, options }, updateBackupConfigurationOperationSpec);
    }
    /**
     * Description for Deletes the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    deleteBackupConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteBackupConfigurationOperationSpec);
    }
    /**
     * Description for Gets the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getBackupConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getBackupConfigurationOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferences(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAppSettingsKeyVaultReferencesOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettingKey App Setting key name.
     * @param options The options parameters.
     */
    getAppSettingKeyVaultReference(resourceGroupName, name, appSettingKey, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettingKey, options }, getAppSettingKeyVaultReferenceOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferences(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSiteConnectionStringKeyVaultReferencesOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStringKey
     * @param options The options parameters.
     */
    getSiteConnectionStringKeyVaultReference(resourceGroupName, name, connectionStringKey, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionStringKey, options }, getSiteConnectionStringKeyVaultReferenceOperationSpec);
    }
    /**
     * Description for Replaces the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateConnectionStrings(resourceGroupName, name, connectionStrings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionStrings, options }, updateConnectionStringsOperationSpec);
    }
    /**
     * Description for Gets the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listConnectionStrings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listConnectionStringsOperationSpec);
    }
    /**
     * Description for Gets the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getDiagnosticLogsConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getDiagnosticLogsConfigurationOperationSpec);
    }
    /**
     * Description for Updates the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change
     *                       in the "properties" property.
     * @param options The options parameters.
     */
    updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteLogsConfig, options }, updateDiagnosticLogsConfigOperationSpec);
    }
    /**
     * Description for Replaces the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateMetadata(resourceGroupName, name, metadata, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, metadata, options }, updateMetadataOperationSpec);
    }
    /**
     * Description for Gets the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listMetadata(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMetadataOperationSpec);
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    beginListPublishingCredentials(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, listPublishingCredentialsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    beginListPublishingCredentialsAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListPublishingCredentials(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Updates the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param pushSettings Push settings associated with web app.
     * @param options The options parameters.
     */
    updateSitePushSettings(resourceGroupName, name, pushSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, pushSettings, options }, updateSitePushSettingsOperationSpec);
    }
    /**
     * Description for Gets the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    listSitePushSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSitePushSettingsOperationSpec);
    }
    /**
     * Description for Gets the names of app settings and connection strings that stick to the slot (not
     * swapped).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSlotConfigurationNames(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSlotConfigurationNamesOperationSpec);
    }
    /**
     * Description for Updates the names of application settings and connection string that remain with the
     * slot during swap operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @param options The options parameters.
     */
    updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotConfigNames, options }, updateSlotConfigurationNamesOperationSpec);
    }
    /**
     * Description for Gets the configuration of an app, such as platform version and bitness, default
     * documents, virtual applications, Always On, etc.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getConfigurationOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteConfig, options }, createOrUpdateConfigurationOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    updateConfiguration(resourceGroupName, name, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteConfig, options }, updateConfigurationOperationSpec);
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfo(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listConfigurationSnapshotInfoOperationSpec);
    }
    /**
     * Description for Gets a snapshot of the configuration of an app at a previous point in time.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param options The options parameters.
     */
    getConfigurationSnapshot(resourceGroupName, name, snapshotId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, options }, getConfigurationSnapshotOperationSpec);
    }
    /**
     * Description for Reverts the configuration of an app to a previous snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param options The options parameters.
     */
    recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, options }, recoverSiteConfigurationSnapshotOperationSpec);
    }
    /**
     * Description for Gets the last lines of docker logs for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getWebSiteContainerLogs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getWebSiteContainerLogsOperationSpec);
    }
    /**
     * Description for Gets the ZIP archived docker log files for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getContainerLogsZip(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getContainerLogsZipOperationSpec);
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listContinuousWebJobs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listContinuousWebJobsOperationSpec);
    }
    /**
     * Description for Gets a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    getContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, getContinuousWebJobOperationSpec);
    }
    /**
     * Description for Delete a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    deleteContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, deleteContinuousWebJobOperationSpec);
    }
    /**
     * Description for Start a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    startContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, startContinuousWebJobOperationSpec);
    }
    /**
     * Description for Stop a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    stopContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, stopContinuousWebJobOperationSpec);
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listProductionSiteDeploymentStatuses(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listProductionSiteDeploymentStatusesOperationSpec);
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetProductionSiteDeploymentStatus(resourceGroupName, name, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, deploymentStatusId, options }, getProductionSiteDeploymentStatusOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetProductionSiteDeploymentStatusAndWait(resourceGroupName, name, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetProductionSiteDeploymentStatus(resourceGroupName, name, deploymentStatusId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listDeployments(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listDeploymentsOperationSpec);
    }
    /**
     * Description for Get a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param options The options parameters.
     */
    getDeployment(resourceGroupName, name, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, options }, getDeploymentOperationSpec);
    }
    /**
     * Description for Create a deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @param options The options parameters.
     */
    createDeployment(resourceGroupName, name, id, deployment, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, deployment, options }, createDeploymentOperationSpec);
    }
    /**
     * Description for Delete a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param options The options parameters.
     */
    deleteDeployment(resourceGroupName, name, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, options }, deleteDeploymentOperationSpec);
    }
    /**
     * Description for List deployment log for specific deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON
     *           response from "GET /api/sites/{siteName}/deployments".
     * @param options The options parameters.
     */
    listDeploymentLog(resourceGroupName, name, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, options }, listDeploymentLogOperationSpec);
    }
    /**
     * Description for Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Use this to get information about the databases stored in a backup.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery
     *                of backup.
     * @param options The options parameters.
     */
    discoverBackup(resourceGroupName, name, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, request, options }, discoverBackupOperationSpec);
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listDomainOwnershipIdentifiersOperationSpec);
    }
    /**
     * Description for Get domain ownership identifier for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param options The options parameters.
     */
    getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, options }, getDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            domainOwnershipIdentifier,
            options
        }, createOrUpdateDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Deletes a domain ownership identifier for a web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param options The options parameters.
     */
    deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, options }, deleteDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            domainOwnershipIdentifier,
            options
        }, updateDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getMSDeployStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMSDeployStatusOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperation(resourceGroupName, name, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, mSDeploy, options }, createMSDeployOperationOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperationAndWait(resourceGroupName, name, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateMSDeployOperation(resourceGroupName, name, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getMSDeployLog(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMSDeployLogOperationSpec);
    }
    /**
     * Description for Invoke onedeploy status API /api/deployments and gets the deployment status for the
     * site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getOneDeployStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOneDeployStatusOperationSpec);
    }
    /**
     * Description for Invoke the OneDeploy publish web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    createOneDeployOperation(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, createOneDeployOperationOperationSpec);
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listFunctions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listFunctionsOperationSpec);
    }
    /**
     * Description for Fetch a short lived token that can be exchanged for a master key.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getFunctionsAdminToken(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getFunctionsAdminTokenOperationSpec);
    }
    /**
     * Description for Get function information by its ID for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    getFunction(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, getFunctionOperationSpec);
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateFunction(resourceGroupName, name, functionName, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, functionName, functionEnvelope, options }, createFunctionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateFunctionAndWait(resourceGroupName, name, functionName, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateFunction(resourceGroupName, name, functionName, functionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    deleteFunction(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, deleteFunctionOperationSpec);
    }
    /**
     * Description for Add or update a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateFunctionSecret(resourceGroupName, name, functionName, keyName, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, key, options }, createOrUpdateFunctionSecretOperationSpec);
    }
    /**
     * Description for Delete a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param options The options parameters.
     */
    deleteFunctionSecret(resourceGroupName, name, functionName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, options }, deleteFunctionSecretOperationSpec);
    }
    /**
     * Description for Get function keys for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    listFunctionKeys(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, listFunctionKeysOperationSpec);
    }
    /**
     * Description for Get function secrets for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    listFunctionSecrets(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, listFunctionSecretsOperationSpec);
    }
    /**
     * Description for Get host secrets for a function app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listHostKeys(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHostKeysOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSyncStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSyncStatusOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    syncFunctions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, syncFunctionsOperationSpec);
    }
    /**
     * Description for Add or update a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateHostSecret(resourceGroupName, name, keyType, keyName, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, key, options }, createOrUpdateHostSecretOperationSpec);
    }
    /**
     * Description for Delete a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param options The options parameters.
     */
    deleteHostSecret(resourceGroupName, name, keyType, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, options }, deleteHostSecretOperationSpec);
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listHostNameBindings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHostNameBindingsOperationSpec);
    }
    /**
     * Description for Get the named hostname binding for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    getHostNameBinding(resourceGroupName, name, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, options }, getHostNameBindingOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param options The options parameters.
     */
    createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, hostNameBinding, options }, createOrUpdateHostNameBindingOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    deleteHostNameBinding(resourceGroupName, name, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, options }, deleteHostNameBindingOperationSpec);
    }
    /**
     * Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param options The options parameters.
     */
    getHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, getHybridConnectionOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            connectionEnvelope,
            options
        }, createOrUpdateHybridConnectionOperationSpec);
    }
    /**
     * Description for Removes a Hybrid Connection from this site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param options The options parameters.
     */
    deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, deleteHybridConnectionOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            connectionEnvelope,
            options
        }, updateHybridConnectionOperationSpec);
    }
    /**
     * Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    listHybridConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHybridConnectionsOperationSpec);
    }
    /**
     * Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listRelayServiceConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listRelayServiceConnectionsOperationSpec);
    }
    /**
     * Description for Gets a hybrid connection configuration by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param options The options parameters.
     */
    getRelayServiceConnection(resourceGroupName, name, entityName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, options }, getRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, connectionEnvelope, options }, createOrUpdateRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Deletes a relay service connection by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param options The options parameters.
     */
    deleteRelayServiceConnection(resourceGroupName, name, entityName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, options }, deleteRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, connectionEnvelope, options }, updateRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listInstanceIdentifiers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listInstanceIdentifiersOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId
     * @param options The options parameters.
     */
    getInstanceInfo(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, getInstanceInfoOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMsDeployStatus(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, getInstanceMsDeployStatusOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperation(resourceGroupName, name, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, instanceId, mSDeploy, options }, createInstanceMSDeployOperationOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperationAndWait(resourceGroupName, name, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateInstanceMSDeployOperation(resourceGroupName, name, instanceId, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMSDeployLog(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, getInstanceMSDeployLogOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcesses(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, listInstanceProcessesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcess(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, getInstanceProcessOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    deleteInstanceProcess(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, deleteInstanceProcessOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessDump(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, getInstanceProcessDumpOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessModules(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, listInstanceProcessModulesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessModule(resourceGroupName, name, processId, baseAddress, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, baseAddress, instanceId, options }, getInstanceProcessModuleOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, listInstanceProcessThreadsOperationSpec);
    }
    /**
     * Description for Shows whether an app can be cloned to another resource group or subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    isCloneable(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, isCloneableOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listSiteBackups(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSiteBackupsOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSyncFunctionTriggers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSyncFunctionTriggersOperationSpec);
    }
    /**
     * Description for Restores a web app.
     * @param subscriptionName Azure subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationOptions Migration migrationOptions.
     * @param options The options parameters.
     */
    beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { subscriptionName, resourceGroupName, name, migrationOptions, options }, migrateStorageOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a web app.
     * @param subscriptionName Azure subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationOptions Migration migrationOptions.
     * @param options The options parameters.
     */
    beginMigrateStorageAndWait(subscriptionName, resourceGroupName, name, migrationOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Migrates a local (in-app) MySql database to a remote MySql database.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @param options The options parameters.
     */
    beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, migrationRequestEnvelope, options }, migrateMySqlOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Migrates a local (in-app) MySql database to a remote MySql database.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @param options The options parameters.
     */
    beginMigrateMySqlAndWait(resourceGroupName, name, migrationRequestEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns the status of MySql in app migration, if one is active, and whether or not
     * MySql in app is enabled
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getMigrateMySqlStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMigrateMySqlStatusOperationSpec);
    }
    /**
     * Description for Gets a Swift Virtual Network connection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getSwiftVirtualNetworkConnection(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSwiftVirtualNetworkConnectionOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateSwiftVirtualNetworkConnectionWithCheck(resourceGroupName, name, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionEnvelope, options }, createOrUpdateSwiftVirtualNetworkConnectionWithCheckOperationSpec);
    }
    /**
     * Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    deleteSwiftVirtualNetwork(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteSwiftVirtualNetworkOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateSwiftVirtualNetworkConnectionWithCheck(resourceGroupName, name, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionEnvelope, options }, updateSwiftVirtualNetworkConnectionWithCheckOperationSpec);
    }
    /**
     * Description for Gets all network features used by the app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. Only "summary" is supported at this time.
     * @param options The options parameters.
     */
    listNetworkFeatures(resourceGroupName, name, view, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, view, options }, listNetworkFeaturesOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTraceOperation(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTraceOperationOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site (To be deprecated).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    startWebSiteNetworkTrace(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, startWebSiteNetworkTraceOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperation(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, startWebSiteNetworkTraceOperationOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperationAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartWebSiteNetworkTraceOperation(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    stopWebSiteNetworkTrace(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, stopWebSiteNetworkTraceOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTraces(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTracesOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTraceOperationV2(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTraceOperationV2OperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTracesV2(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTracesV2OperationSpec);
    }
    /**
     * Description for Generates a new publishing password for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    generateNewSitePublishingPassword(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, generateNewSitePublishingPasswordOperationSpec);
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    _listPerfMonCounters(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listPerfMonCountersOperationSpec);
    }
    /**
     * Description for Gets web app's event logs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getSitePhpErrorLogFlag(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSitePhpErrorLogFlagOperationSpec);
    }
    /**
     * Description for Gets the premier add-ons of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listPremierAddOns(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listPremierAddOnsOperationSpec);
    }
    /**
     * Description for Gets a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param options The options parameters.
     */
    getPremierAddOn(resourceGroupName, name, premierAddOnName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, options }, getPremierAddOnOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, premierAddOn, options }, addPremierAddOnOperationSpec);
    }
    /**
     * Description for Delete a premier add-on from an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param options The options parameters.
     */
    deletePremierAddOn(resourceGroupName, name, premierAddOnName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, options }, deletePremierAddOnOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    updatePremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, premierAddOn, options }, updatePremierAddOnOperationSpec);
    }
    /**
     * Description for Gets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    getPrivateAccess(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateAccessOperationSpec);
    }
    /**
     * Description for Sets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param access The information for the private access
     * @param options The options parameters.
     */
    putPrivateAccessVnet(resourceGroupName, name, access, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, access, options }, putPrivateAccessVnetOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionList(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateEndpointConnectionListOperationSpec);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getPrivateEndpointConnectionOperationSpec);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Private Endpoint Connection Approval ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                privateEndpointConnectionName,
                privateEndpointWrapper,
                options
            }, approveOrRejectPrivateEndpointConnectionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Private Endpoint Connection Approval ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, privateEndpointConnectionName, options }, deletePrivateEndpointConnectionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateLinkResourcesOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listProcesses(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listProcessesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    getProcess(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, getProcessOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    deleteProcess(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, deleteProcessOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    getProcessDump(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, getProcessDumpOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    _listProcessModules(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, listProcessModulesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param options The options parameters.
     */
    getProcessModule(resourceGroupName, name, processId, baseAddress, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, baseAddress, options }, getProcessModuleOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    _listProcessThreads(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, listProcessThreadsOperationSpec);
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listPublicCertificates(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listPublicCertificatesOperationSpec);
    }
    /**
     * Description for Get the named public certificate for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    getPublicCertificate(resourceGroupName, name, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, publicCertificateName, options }, getPublicCertificateOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param publicCertificate Public certificate details. This is the JSON representation of a
     *                          PublicCertificate object.
     * @param options The options parameters.
     */
    createOrUpdatePublicCertificate(resourceGroupName, name, publicCertificateName, publicCertificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            publicCertificateName,
            publicCertificate,
            options
        }, createOrUpdatePublicCertificateOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    deletePublicCertificate(resourceGroupName, name, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, publicCertificateName, options }, deletePublicCertificateOperationSpec);
    }
    /**
     * Description for Gets the publishing profile for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publishingProfileOptions Specifies publishingProfileOptions for publishing profile. For
     *                                 example, use {"format": "FileZilla3"} to get a FileZilla publishing profile.
     * @param options The options parameters.
     */
    listPublishingProfileXmlWithSecrets(resourceGroupName, name, publishingProfileOptions, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, publishingProfileOptions, options }, listPublishingProfileXmlWithSecretsOperationSpec);
    }
    /**
     * Description for Resets the configuration settings of the current slot if they were previously
     * modified by calling the API with POST.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    resetProductionSlotConfig(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, resetProductionSlotConfigOperationSpec);
    }
    /**
     * Description for Restarts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    restart(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, restartOperationSpec);
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlob(resourceGroupName, name, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, request, options }, restoreFromBackupBlobOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlobAndWait(resourceGroupName, name, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromBackupBlob(resourceGroupName, name, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedApp(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, restoreRequest, options }, restoreFromDeletedAppOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedAppAndWait(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromDeletedApp(resourceGroupName, name, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshot(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, restoreRequest, options }, restoreSnapshotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshotAndWait(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreSnapshot(resourceGroupName, name, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listSiteExtensions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSiteExtensionsOperationSpec);
    }
    /**
     * Description for Get site extension information by its ID for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    getSiteExtension(resourceGroupName, name, siteExtensionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, options }, getSiteExtensionOperationSpec);
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    beginInstallSiteExtension(resourceGroupName, name, siteExtensionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, siteExtensionId, options }, installSiteExtensionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    beginInstallSiteExtensionAndWait(resourceGroupName, name, siteExtensionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInstallSiteExtension(resourceGroupName, name, siteExtensionId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Remove a site extension from a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    deleteSiteExtension(resourceGroupName, name, siteExtensionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, options }, deleteSiteExtensionOperationSpec);
    }
    /**
     * Description for Gets an app's deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listSlots(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSlotsOperationSpec);
    }
    /**
     * Description for Gets the details of a web, mobile, or API app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @param options The options parameters.
     */
    getSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSlotOperationSpec);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create
     *             or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSlot(resourceGroupName, name, slot, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, siteEnvelope, options }, createOrUpdateSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create
     *             or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSlotAndWait(resourceGroupName, name, slot, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSlot(resourceGroupName, name, slot, siteEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a web, mobile, or API app, or one of the deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param options The options parameters.
     */
    deleteSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteSlotOperationSpec);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create
     *             or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    updateSlot(resourceGroupName, name, slot, siteEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteEnvelope, options }, updateSlotOperationSpec);
    }
    /**
     * Description for Analyze a custom hostname.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    analyzeCustomHostnameSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, analyzeCustomHostnameSlotOperationSpec);
    }
    /**
     * Description for Applies the configuration settings from the target slot onto the current slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    applySlotConfigurationSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, slotSwapEntity, options }, applySlotConfigurationSlotOperationSpec);
    }
    /**
     * Description for Creates a backup of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup
     *             for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input
     *                here.
     * @param options The options parameters.
     */
    backupSlot(resourceGroupName, name, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, request, options }, backupSlotOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    _listBackupsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listBackupsSlotOperationSpec);
    }
    /**
     * Description for Gets a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of
     *             the production slot.
     * @param options The options parameters.
     */
    getBackupStatusSlot(resourceGroupName, name, backupId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, slot, options }, getBackupStatusSlotOperationSpec);
    }
    /**
     * Description for Deletes a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of
     *             the production slot.
     * @param options The options parameters.
     */
    deleteBackupSlot(resourceGroupName, name, backupId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, slot, options }, deleteBackupSlotOperationSpec);
    }
    /**
     * Description for Gets status of a web app backup that may be in progress, including secrets
     * associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS
     * URL for the backup if a new URL is passed in the request body.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request.
     * @param options The options parameters.
     */
    listBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, slot, request, options }, listBackupStatusSecretsSlotOperationSpec);
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreSlot(resourceGroupName, name, backupId, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, backupId, slot, request, options }, restoreSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreSlotAndWait(resourceGroupName, name, backupId, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreSlot(resourceGroupName, name, backupId, slot, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPoliciesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listBasicPublishingCredentialsPoliciesSlotOperationSpec);
    }
    /**
     * Description for Returns whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    getFtpAllowedSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getFtpAllowedSlotOperationSpec);
    }
    /**
     * Description for Updates whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateFtpAllowedSlot(resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            slot,
            csmPublishingAccessPoliciesEntity,
            options
        }, updateFtpAllowedSlotOperationSpec);
    }
    /**
     * Description for Returns whether Scm basic auth is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    getScmAllowedSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getScmAllowedSlotOperationSpec);
    }
    /**
     * Description for Updates whether user publishing credentials are allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateScmAllowedSlot(resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            slot,
            csmPublishingAccessPoliciesEntity,
            options
        }, updateScmAllowedSlotOperationSpec);
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    _listConfigurationsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listConfigurationsSlotOperationSpec);
    }
    /**
     * Description for Replaces the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the
     *             application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @param options The options parameters.
     */
    updateApplicationSettingsSlot(resourceGroupName, name, slot, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, appSettings, options }, updateApplicationSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the
     *             application settings for the production slot.
     * @param options The options parameters.
     */
    listApplicationSettingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listApplicationSettingsSlotOperationSpec);
    }
    /**
     * Description for Updates the Authentication / Authorization settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettingsSlot(resourceGroupName, name, slot, siteAuthSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteAuthSettings, options }, updateAuthSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the Authentication/Authorization settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings
     *             for the production slot.
     * @param options The options parameters.
     */
    getAuthSettingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAuthSettingsSlotOperationSpec);
    }
    /**
     * Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings
     *             for the production slot.
     * @param options The options parameters.
     */
    getAuthSettingsV2WithoutSecretsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAuthSettingsV2WithoutSecretsSlotOperationSpec);
    }
    /**
     * Description for Updates site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettingsV2 Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettingsV2Slot(resourceGroupName, name, slot, siteAuthSettingsV2, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteAuthSettingsV2, options }, updateAuthSettingsV2SlotOperationSpec);
    }
    /**
     * Description for Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings
     *             for the production slot.
     * @param options The options parameters.
     */
    getAuthSettingsV2Slot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAuthSettingsV2SlotOperationSpec);
    }
    /**
     * Description for Updates the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the Azure
     *             storage account configurations for the production slot.
     * @param azureStorageAccounts Azure storage accounts of the app.
     * @param options The options parameters.
     */
    updateAzureStorageAccountsSlot(resourceGroupName, name, slot, azureStorageAccounts, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, azureStorageAccounts, options }, updateAzureStorageAccountsSlotOperationSpec);
    }
    /**
     * Description for Gets the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the Azure
     *             storage account configurations for the production slot.
     * @param options The options parameters.
     */
    listAzureStorageAccountsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listAzureStorageAccountsSlotOperationSpec);
    }
    /**
     * Description for Updates the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup
     *             configuration for the production slot.
     * @param request Edited backup configuration.
     * @param options The options parameters.
     */
    updateBackupConfigurationSlot(resourceGroupName, name, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, request, options }, updateBackupConfigurationSlotOperationSpec);
    }
    /**
     * Description for Deletes the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    deleteBackupConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteBackupConfigurationSlotOperationSpec);
    }
    /**
     * Description for Gets the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getBackupConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getBackupConfigurationSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAppSettingsKeyVaultReferencesSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettingKey App Setting key name.
     * @param slot
     * @param options The options parameters.
     */
    getAppSettingKeyVaultReferenceSlot(resourceGroupName, name, appSettingKey, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettingKey, slot, options }, getAppSettingKeyVaultReferenceSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSiteConnectionStringKeyVaultReferencesSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStringKey
     * @param slot
     * @param options The options parameters.
     */
    getSiteConnectionStringKeyVaultReferenceSlot(resourceGroupName, name, connectionStringKey, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionStringKey, slot, options }, getSiteConnectionStringKeyVaultReferenceSlotOperationSpec);
    }
    /**
     * Description for Replaces the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the
     *             connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateConnectionStringsSlot(resourceGroupName, name, slot, connectionStrings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, connectionStrings, options }, updateConnectionStringsSlotOperationSpec);
    }
    /**
     * Description for Gets the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection
     *             settings for the production slot.
     * @param options The options parameters.
     */
    listConnectionStringsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listConnectionStringsSlotOperationSpec);
    }
    /**
     * Description for Gets the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getDiagnosticLogsConfigurationSlotOperationSpec);
    }
    /**
     * Description for Updates the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging
     *             configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change
     *                       in the "properties" property.
     * @param options The options parameters.
     */
    updateDiagnosticLogsConfigSlot(resourceGroupName, name, slot, siteLogsConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteLogsConfig, options }, updateDiagnosticLogsConfigSlotOperationSpec);
    }
    /**
     * Description for Replaces the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the
     *             metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateMetadataSlot(resourceGroupName, name, slot, metadata, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, metadata, options }, updateMetadataSlotOperationSpec);
    }
    /**
     * Description for Gets the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata
     *             for the production slot.
     * @param options The options parameters.
     */
    listMetadataSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listMetadataSlotOperationSpec);
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing
     *             credentials for the production slot.
     * @param options The options parameters.
     */
    beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, options }, listPublishingCredentialsSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing
     *             credentials for the production slot.
     * @param options The options parameters.
     */
    beginListPublishingCredentialsSlotAndWait(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Updates the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app.
     * @param options The options parameters.
     */
    updateSitePushSettingsSlot(resourceGroupName, name, slot, pushSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, pushSettings, options }, updateSitePushSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    listSitePushSettingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSitePushSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the configuration of an app, such as platform version and bitness, default
     * documents, virtual applications, Always On, etc.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getConfigurationSlotOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update
     *             configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    createOrUpdateConfigurationSlot(resourceGroupName, name, slot, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteConfig, options }, createOrUpdateConfigurationSlotOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update
     *             configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    updateConfigurationSlot(resourceGroupName, name, slot, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteConfig, options }, updateConfigurationSlotOperationSpec);
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listConfigurationSnapshotInfoSlotOperationSpec);
    }
    /**
     * Description for Gets a snapshot of the configuration of an app at a previous point in time.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, slot, options }, getConfigurationSnapshotSlotOperationSpec);
    }
    /**
     * Description for Reverts the configuration of an app to a previous snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, slot, options }, recoverSiteConfigurationSnapshotSlotOperationSpec);
    }
    /**
     * Description for Gets the last lines of docker logs for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getWebSiteContainerLogsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getWebSiteContainerLogsSlotOperationSpec);
    }
    /**
     * Description for Gets the ZIP archived docker log files for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getContainerLogsZipSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getContainerLogsZipSlotOperationSpec);
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    _listContinuousWebJobsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listContinuousWebJobsSlotOperationSpec);
    }
    /**
     * Description for Gets a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    getContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, getContinuousWebJobSlotOperationSpec);
    }
    /**
     * Description for Delete a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, deleteContinuousWebJobSlotOperationSpec);
    }
    /**
     * Description for Start a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    startContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, startContinuousWebJobSlotOperationSpec);
    }
    /**
     * Description for Stop a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    stopContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, stopContinuousWebJobSlotOperationSpec);
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param options The options parameters.
     */
    _listSlotSiteDeploymentStatusesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSlotSiteDeploymentStatusesSlotOperationSpec);
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetSlotSiteDeploymentStatusSlot(resourceGroupName, name, slot, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, deploymentStatusId, options }, getSlotSiteDeploymentStatusSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetSlotSiteDeploymentStatusSlotAndWait(resourceGroupName, name, slot, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetSlotSiteDeploymentStatusSlot(resourceGroupName, name, slot, deploymentStatusId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listDeploymentsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listDeploymentsSlotOperationSpec);
    }
    /**
     * Description for Get a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for
     *             the production slot.
     * @param options The options parameters.
     */
    getDeploymentSlot(resourceGroupName, name, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, options }, getDeploymentSlotOperationSpec);
    }
    /**
     * Description for Create a deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment
     *             for the production slot.
     * @param deployment Deployment details.
     * @param options The options parameters.
     */
    createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, deployment, options }, createDeploymentSlotOperationSpec);
    }
    /**
     * Description for Delete a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteDeploymentSlot(resourceGroupName, name, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, options }, deleteDeploymentSlotOperationSpec);
    }
    /**
     * Description for List deployment log for specific deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON
     *           response from "GET /api/sites/{siteName}/deployments".
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listDeploymentLogSlot(resourceGroupName, name, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, options }, listDeploymentLogSlotOperationSpec);
    }
    /**
     * Description for Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Use this to get information about the databases stored in a backup.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery
     *             for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery
     *                of backup.
     * @param options The options parameters.
     */
    discoverBackupSlot(resourceGroupName, name, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, request, options }, discoverBackupSlotOperationSpec);
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listDomainOwnershipIdentifiersSlotOperationSpec);
    }
    /**
     * Description for Get domain ownership identifier for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, slot, options }, getDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            slot,
            domainOwnershipIdentifier,
            options
        }, createOrUpdateDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Deletes a domain ownership identifier for a web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, slot, options }, deleteDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            slot,
            domainOwnershipIdentifier,
            options
        }, updateDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getMSDeployStatusSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getMSDeployStatusSlotOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperationSlot(resourceGroupName, name, slot, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, mSDeploy, options }, createMSDeployOperationSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperationSlotAndWait(resourceGroupName, name, slot, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateMSDeployOperationSlot(resourceGroupName, name, slot, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getMSDeployLogSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getMSDeployLogSlotOperationSpec);
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    _listInstanceFunctionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listInstanceFunctionsSlotOperationSpec);
    }
    /**
     * Description for Fetch a short lived token that can be exchanged for a master key.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getFunctionsAdminTokenSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getFunctionsAdminTokenSlotOperationSpec);
    }
    /**
     * Description for Get function information by its ID for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    getInstanceFunctionSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, getInstanceFunctionSlotOperationSpec);
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateInstanceFunctionSlot(resourceGroupName, name, functionName, slot, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                functionName,
                slot,
                functionEnvelope,
                options
            }, createInstanceFunctionSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateInstanceFunctionSlotAndWait(resourceGroupName, name, functionName, slot, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateInstanceFunctionSlot(resourceGroupName, name, functionName, slot, functionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deleteInstanceFunctionSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, deleteInstanceFunctionSlotOperationSpec);
    }
    /**
     * Description for Add or update a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateFunctionSecretSlot(resourceGroupName, name, functionName, keyName, slot, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, slot, key, options }, createOrUpdateFunctionSecretSlotOperationSpec);
    }
    /**
     * Description for Delete a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deleteFunctionSecretSlot(resourceGroupName, name, functionName, keyName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, slot, options }, deleteFunctionSecretSlotOperationSpec);
    }
    /**
     * Description for Get function keys for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listFunctionKeysSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, listFunctionKeysSlotOperationSpec);
    }
    /**
     * Description for Get function secrets for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listFunctionSecretsSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, listFunctionSecretsSlotOperationSpec);
    }
    /**
     * Description for Get host secrets for a function app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listHostKeysSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listHostKeysSlotOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listSyncStatusSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSyncStatusSlotOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    syncFunctionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, syncFunctionsSlotOperationSpec);
    }
    /**
     * Description for Add or update a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateHostSecretSlot(resourceGroupName, name, keyType, keyName, slot, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, slot, key, options }, createOrUpdateHostSecretSlotOperationSpec);
    }
    /**
     * Description for Delete a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deleteHostSecretSlot(resourceGroupName, name, keyType, keyName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, slot, options }, deleteHostSecretSlotOperationSpec);
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    _listHostNameBindingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listHostNameBindingsSlotOperationSpec);
    }
    /**
     * Description for Get the named hostname binding for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for
     *             the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, hostName, options }, getHostNameBindingSlotOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding
     *             for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param options The options parameters.
     */
    createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, slot, hostNameBinding, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, slot, hostNameBinding, options }, createOrUpdateHostNameBindingSlotOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, hostName, options }, deleteHostNameBindingSlotOperationSpec);
    }
    /**
     * Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, slot, options }, getHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            slot,
            connectionEnvelope,
            options
        }, createOrUpdateHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Removes a Hybrid Connection from this site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, slot, options }, deleteHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            slot,
            connectionEnvelope,
            options
        }, updateHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    listHybridConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listHybridConnectionsSlotOperationSpec);
    }
    /**
     * Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid
     *             connections for the production slot.
     * @param options The options parameters.
     */
    listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listRelayServiceConnectionsSlotOperationSpec);
    }
    /**
     * Description for Gets a hybrid connection configuration by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid
     *             connection for the production slot.
     * @param options The options parameters.
     */
    getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, slot, options }, getRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a
     *             hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            entityName,
            slot,
            connectionEnvelope,
            options
        }, createOrUpdateRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Deletes a relay service connection by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid
     *             connection for the production slot.
     * @param options The options parameters.
     */
    deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, slot, options }, deleteRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a
     *             hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            entityName,
            slot,
            connectionEnvelope,
            options
        }, updateRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param options The options parameters.
     */
    _listInstanceIdentifiersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listInstanceIdentifiersSlotOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param options The options parameters.
     */
    getInstanceInfoSlot(resourceGroupName, name, instanceId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, slot, options }, getInstanceInfoSlotOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMsDeployStatusSlot(resourceGroupName, name, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, options }, getInstanceMsDeployStatusSlotOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperationSlot(resourceGroupName, name, slot, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, instanceId, mSDeploy, options }, createInstanceMSDeployOperationSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperationSlotAndWait(resourceGroupName, name, slot, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateInstanceMSDeployOperationSlot(resourceGroupName, name, slot, instanceId, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMSDeployLogSlot(resourceGroupName, name, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, options }, getInstanceMSDeployLogSlotOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, options }, listInstanceProcessesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, getInstanceProcessSlotOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    deleteInstanceProcessSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, deleteInstanceProcessSlotOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessDumpSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, getInstanceProcessDumpSlotOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, listInstanceProcessModulesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessModuleSlot(resourceGroupName, name, processId, baseAddress, slot, instanceId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            processId,
            baseAddress,
            slot,
            instanceId,
            options
        }, getInstanceProcessModuleSlotOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, listInstanceProcessThreadsSlotOperationSpec);
    }
    /**
     * Description for Shows whether an app can be cloned to another resource group or subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production
     *             slot.
     * @param options The options parameters.
     */
    isCloneableSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, isCloneableSlotOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    _listSiteBackupsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSiteBackupsSlotOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listSyncFunctionTriggersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSyncFunctionTriggersSlotOperationSpec);
    }
    /**
     * Description for Returns the status of MySql in app migration, if one is active, and whether or not
     * MySql in app is enabled
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getMigrateMySqlStatusSlotOperationSpec);
    }
    /**
     * Description for Gets a Swift Virtual Network connection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for
     *             the production slot's Virtual Network.
     * @param options The options parameters.
     */
    getSwiftVirtualNetworkConnectionSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSwiftVirtualNetworkConnectionSlotOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot(resourceGroupName, name, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, connectionEnvelope, options }, createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec);
    }
    /**
     * Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the
     *             connection for the production slot.
     * @param options The options parameters.
     */
    deleteSwiftVirtualNetworkSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteSwiftVirtualNetworkSlotOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateSwiftVirtualNetworkConnectionWithCheckSlot(resourceGroupName, name, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, connectionEnvelope, options }, updateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec);
    }
    /**
     * Description for Gets all network features used by the app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. Only "summary" is supported at this time.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network
     *             features for the production slot.
     * @param options The options parameters.
     */
    listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, view, slot, options }, listNetworkFeaturesSlotOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTraceOperationSlot(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTraceOperationSlotOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site (To be deprecated).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, startWebSiteNetworkTraceSlotOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperationSlot(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, options }, startWebSiteNetworkTraceOperationSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperationSlotAndWait(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartWebSiteNetworkTraceOperationSlot(resourceGroupName, name, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, stopWebSiteNetworkTraceSlotOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTracesSlot(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTracesSlotOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTraceOperationSlotV2(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTraceOperationSlotV2OperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTracesSlotV2(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTracesSlotV2OperationSpec);
    }
    /**
     * Description for Generates a new publishing password for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new
     *             publishing password for the production slot.
     * @param options The options parameters.
     */
    generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, generateNewSitePublishingPasswordSlotOperationSpec);
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    _listPerfMonCountersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listPerfMonCountersSlotOperationSpec);
    }
    /**
     * Description for Gets web app's event logs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSitePhpErrorLogFlagSlotOperationSpec);
    }
    /**
     * Description for Gets the premier add-ons of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier
     *             add-ons for the production slot.
     * @param options The options parameters.
     */
    listPremierAddOnsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listPremierAddOnsSlotOperationSpec);
    }
    /**
     * Description for Gets a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named
     *             add-on for the production slot.
     * @param options The options parameters.
     */
    getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, slot, options }, getPremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named
     *             add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, premierAddOn, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            premierAddOnName,
            slot,
            premierAddOn,
            options
        }, addPremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Delete a premier add-on from an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named
     *             add-on for the production slot.
     * @param options The options parameters.
     */
    deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, slot, options }, deletePremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named
     *             add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    updatePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, premierAddOn, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            premierAddOnName,
            slot,
            premierAddOn,
            options
        }, updatePremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Gets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    getPrivateAccessSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getPrivateAccessSlotOperationSpec);
    }
    /**
     * Description for Sets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param access The information for the private access
     * @param options The options parameters.
     */
    putPrivateAccessVnetSlot(resourceGroupName, name, slot, access, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, access, options }, putPrivateAccessVnetSlotOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot Name of the site deployment slot.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getPrivateEndpointConnectionListSlotOperationSpec);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param slot Name of the site deployment slot.
     * @param options The options parameters.
     */
    getPrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, slot, options }, getPrivateEndpointConnectionSlotOperationSpec);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param privateEndpointWrapper Private Endpoint Connection Approval ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                privateEndpointConnectionName,
                slot,
                privateEndpointWrapper,
                options
            }, approveOrRejectPrivateEndpointConnectionSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param privateEndpointWrapper Private Endpoint Connection Approval ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionSlotAndWait(resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, privateEndpointConnectionName, slot, options }, deletePrivateEndpointConnectionSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionSlotAndWait(resourceGroupName, name, privateEndpointConnectionName, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot
     * @param options The options parameters.
     */
    getPrivateLinkResourcesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getPrivateLinkResourcesSlotOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listProcessesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listProcessesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getProcessSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, getProcessSlotOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    deleteProcessSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, deleteProcessSlotOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getProcessDumpSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, getProcessDumpSlotOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listProcessModulesSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, listProcessModulesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getProcessModuleSlot(resourceGroupName, name, processId, baseAddress, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, baseAddress, slot, options }, getProcessModuleSlotOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listProcessThreadsSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, listProcessThreadsSlotOperationSpec);
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    _listPublicCertificatesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listPublicCertificatesSlotOperationSpec);
    }
    /**
     * Description for Get the named public certificate for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for
     *             the production slot.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    getPublicCertificateSlot(resourceGroupName, name, slot, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, publicCertificateName, options }, getPublicCertificateSlotOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding
     *             for the production slot.
     * @param publicCertificate Public certificate details. This is the JSON representation of a
     *                          PublicCertificate object.
     * @param options The options parameters.
     */
    createOrUpdatePublicCertificateSlot(resourceGroupName, name, publicCertificateName, slot, publicCertificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            publicCertificateName,
            slot,
            publicCertificate,
            options
        }, createOrUpdatePublicCertificateSlotOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    deletePublicCertificateSlot(resourceGroupName, name, slot, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, publicCertificateName, options }, deletePublicCertificateSlotOperationSpec);
    }
    /**
     * Description for Gets the publishing profile for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing
     *             profile for the production slot.
     * @param publishingProfileOptions Specifies publishingProfileOptions for publishing profile. For
     *                                 example, use {"format": "FileZilla3"} to get a FileZilla publishing profile.
     * @param options The options parameters.
     */
    listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, publishingProfileOptions, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, publishingProfileOptions, options }, listPublishingProfileXmlWithSecretsSlotOperationSpec);
    }
    /**
     * Description for Resets the configuration settings of the current slot if they were previously
     * modified by calling the API with POST.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration
     *             settings for the production slot.
     * @param options The options parameters.
     */
    resetSlotConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, resetSlotConfigurationSlotOperationSpec);
    }
    /**
     * Description for Restarts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the
     *             production slot.
     * @param options The options parameters.
     */
    restartSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, restartSlotOperationSpec);
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlobSlot(resourceGroupName, name, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, request, options }, restoreFromBackupBlobSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlobSlotAndWait(resourceGroupName, name, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromBackupBlobSlot(resourceGroupName, name, slot, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedAppSlot(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, restoreRequest, options }, restoreFromDeletedAppSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedAppSlotAndWait(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromDeletedAppSlot(resourceGroupName, name, slot, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshotSlot(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, restoreRequest, options }, restoreSnapshotSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshotSlotAndWait(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreSnapshotSlot(resourceGroupName, name, slot, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    _listSiteExtensionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSiteExtensionsSlotOperationSpec);
    }
    /**
     * Description for Get site extension information by its ID for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    getSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, slot, options }, getSiteExtensionSlotOperationSpec);
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    beginInstallSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, siteExtensionId, slot, options }, installSiteExtensionSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    beginInstallSiteExtensionSlotAndWait(resourceGroupName, name, siteExtensionId, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInstallSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Remove a site extension from a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, slot, options }, deleteSiteExtensionSlotOperationSpec);
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    _listSlotDifferencesSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, slotSwapEntity, options }, listSlotDifferencesSlotOperationSpec);
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, slotSwapEntity, options }, swapSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlotAndWait(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSwapSlot(resourceGroupName, name, slot, slotSwapEntity, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    _listSnapshotsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSnapshotsSlotOperationSpec);
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondarySlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSnapshotsFromDRSecondarySlotOperationSpec);
    }
    /**
     * Description for Gets the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source
     *             control configuration for the production slot.
     * @param options The options parameters.
     */
    getSourceControlSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSourceControlSlotOperationSpec);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source
     *             control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, slot, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, siteSourceControl, options }, createOrUpdateSourceControlSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source
     *             control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControlSlotAndWait(resourceGroupName, name, slot, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, slot, siteSourceControl, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source
     *             control configuration for the production slot.
     * @param options The options parameters.
     */
    deleteSourceControlSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteSourceControlSlotOperationSpec);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source
     *             control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    updateSourceControlSlot(resourceGroupName, name, slot, siteSourceControl, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteSourceControl, options }, updateSourceControlSlotOperationSpec);
    }
    /**
     * Description for Starts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the
     *             production slot.
     * @param options The options parameters.
     */
    startSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, startSlotOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slot, options }, startNetworkTraceSlotOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartNetworkTraceSlotAndWait(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartNetworkTraceSlot(resourceGroupName, name, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stops an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the
     *             production slot.
     * @param options The options parameters.
     */
    stopSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, stopSlotOperationSpec);
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    stopNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, stopNetworkTraceSlotOperationSpec);
    }
    /**
     * Description for Sync web app repository.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    syncRepositorySlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, syncRepositorySlotOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    syncFunctionTriggersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, syncFunctionTriggersSlotOperationSpec);
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    _listTriggeredWebJobsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listTriggeredWebJobsSlotOperationSpec);
    }
    /**
     * Description for Gets a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    getTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, getTriggeredWebJobSlotOperationSpec);
    }
    /**
     * Description for Delete a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes web job for the
     *             production slot.
     * @param options The options parameters.
     */
    deleteTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, deleteTriggeredWebJobSlotOperationSpec);
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, listTriggeredWebJobHistorySlotOperationSpec);
    }
    /**
     * Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    getTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, id, slot, options }, getTriggeredWebJobHistorySlotOperationSpec);
    }
    /**
     * Description for Run a triggered web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    runTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, runTriggeredWebJobSlotOperationSpec);
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota
     *             information of the production slot.
     * @param options The options parameters.
     */
    _listUsagesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listUsagesSlotOperationSpec);
    }
    /**
     * Description for Gets the virtual networks the app (or deployment slot) is connected to.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual
     *             network connections for the production slot.
     * @param options The options parameters.
     */
    listVnetConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listVnetConnectionsSlotOperationSpec);
    }
    /**
     * Description for Gets a virtual network the app (or deployment slot) is connected to by name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named
     *             virtual network for the production slot.
     * @param options The options parameters.
     */
    getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, options }, getVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, connectionEnvelope, options }, createOrUpdateVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Deletes a connection from an app (or deployment slot to a named virtual network.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the
     *             connection for the production slot.
     * @param options The options parameters.
     */
    deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, options }, deleteVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, connectionEnvelope, options }, updateVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Gets an app's Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for
     *             the production slot's Virtual Network.
     * @param options The options parameters.
     */
    getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, gatewayName, slot, options }, getVnetConnectionGatewaySlotOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a
     *             gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            slot,
            connectionEnvelope,
            options
        }, createOrUpdateVnetConnectionGatewaySlotOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a
     *             gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            slot,
            connectionEnvelope,
            options
        }, updateVnetConnectionGatewaySlotOperationSpec);
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listWebJobsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listWebJobsSlotOperationSpec);
    }
    /**
     * Description for Get webjob information for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, getWebJobSlotOperationSpec);
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    _listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotSwapEntity, options }, listSlotDifferencesFromProductionOperationSpec);
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, slotSwapEntity, options }, swapSlotWithProductionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlotWithProductionAndWait(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    _listSnapshots(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSnapshotsOperationSpec);
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondary(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSnapshotsFromDRSecondaryOperationSpec);
    }
    /**
     * Description for Gets the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getSourceControl(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSourceControlOperationSpec$1);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, siteSourceControl, options }, createOrUpdateSourceControlOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControlAndWait(resourceGroupName, name, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    deleteSourceControl(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteSourceControlOperationSpec);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    updateSourceControl(resourceGroupName, name, siteSourceControl, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteSourceControl, options }, updateSourceControlOperationSpec$1);
    }
    /**
     * Description for Starts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    start(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, startOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartNetworkTrace(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, startNetworkTraceOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartNetworkTraceAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartNetworkTrace(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stops an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    stop(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, stopOperationSpec);
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    stopNetworkTrace(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, stopNetworkTraceOperationSpec);
    }
    /**
     * Description for Sync web app repository.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    syncRepository(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, syncRepositoryOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    syncFunctionTriggers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, syncFunctionTriggersOperationSpec);
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listTriggeredWebJobs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listTriggeredWebJobsOperationSpec);
    }
    /**
     * Description for Gets a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    getTriggeredWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, getTriggeredWebJobOperationSpec);
    }
    /**
     * Description for Delete a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    deleteTriggeredWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, deleteTriggeredWebJobOperationSpec);
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistory(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, listTriggeredWebJobHistoryOperationSpec);
    }
    /**
     * Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param options The options parameters.
     */
    getTriggeredWebJobHistory(resourceGroupName, name, webJobName, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, id, options }, getTriggeredWebJobHistoryOperationSpec);
    }
    /**
     * Description for Run a triggered web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    runTriggeredWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, runTriggeredWebJobOperationSpec);
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listUsagesOperationSpec);
    }
    /**
     * Description for Gets the virtual networks the app (or deployment slot) is connected to.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listVnetConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listVnetConnectionsOperationSpec);
    }
    /**
     * Description for Gets a virtual network the app (or deployment slot) is connected to by name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param options The options parameters.
     */
    getVnetConnection(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, getVnetConnectionOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, connectionEnvelope, options }, createOrUpdateVnetConnectionOperationSpec);
    }
    /**
     * Description for Deletes a connection from an app (or deployment slot to a named virtual network.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param options The options parameters.
     */
    deleteVnetConnection(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, deleteVnetConnectionOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, connectionEnvelope, options }, updateVnetConnectionOperationSpec);
    }
    /**
     * Description for Gets an app's Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param options The options parameters.
     */
    getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, gatewayName, options }, getVnetConnectionGatewayOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            connectionEnvelope,
            options
        }, createOrUpdateVnetConnectionGatewayOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            connectionEnvelope,
            options
        }, updateVnetConnectionGatewayOperationSpec);
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listWebJobs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWebJobsOperationSpec);
    }
    /**
     * Description for Get webjob information for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param options The options parameters.
     */
    getWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, getWebJobOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$8);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBackupsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListBackups method.
     * @param options The options parameters.
     */
    _listBackupsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBackupsNextOperationSpec);
    }
    /**
     * ListBasicPublishingCredentialsPoliciesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListBasicPublishingCredentialsPolicies method.
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPoliciesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBasicPublishingCredentialsPoliciesNextOperationSpec);
    }
    /**
     * ListConfigurationsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListConfigurations method.
     * @param options The options parameters.
     */
    _listConfigurationsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listConfigurationsNextOperationSpec);
    }
    /**
     * GetAppSettingsKeyVaultReferencesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetAppSettingsKeyVaultReferences method.
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferencesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getAppSettingsKeyVaultReferencesNextOperationSpec);
    }
    /**
     * GetSiteConnectionStringKeyVaultReferencesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetSiteConnectionStringKeyVaultReferences method.
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferencesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getSiteConnectionStringKeyVaultReferencesNextOperationSpec);
    }
    /**
     * ListConfigurationSnapshotInfoNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListConfigurationSnapshotInfo
     *                 method.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfoNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listConfigurationSnapshotInfoNextOperationSpec);
    }
    /**
     * ListContinuousWebJobsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListContinuousWebJobs method.
     * @param options The options parameters.
     */
    _listContinuousWebJobsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listContinuousWebJobsNextOperationSpec);
    }
    /**
     * ListProductionSiteDeploymentStatusesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListProductionSiteDeploymentStatuses method.
     * @param options The options parameters.
     */
    _listProductionSiteDeploymentStatusesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listProductionSiteDeploymentStatusesNextOperationSpec);
    }
    /**
     * ListDeploymentsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListDeployments method.
     * @param options The options parameters.
     */
    _listDeploymentsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listDeploymentsNextOperationSpec);
    }
    /**
     * ListDomainOwnershipIdentifiersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListDomainOwnershipIdentifiers
     *                 method.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listDomainOwnershipIdentifiersNextOperationSpec);
    }
    /**
     * ListFunctionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListFunctions method.
     * @param options The options parameters.
     */
    _listFunctionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listFunctionsNextOperationSpec);
    }
    /**
     * ListHostNameBindingsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListHostNameBindings method.
     * @param options The options parameters.
     */
    _listHostNameBindingsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listHostNameBindingsNextOperationSpec);
    }
    /**
     * ListInstanceIdentifiersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceIdentifiers
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceIdentifiersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listInstanceIdentifiersNextOperationSpec);
    }
    /**
     * ListInstanceProcessesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcesses method.
     * @param options The options parameters.
     */
    _listInstanceProcessesNext(resourceGroupName, name, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, nextLink, options }, listInstanceProcessesNextOperationSpec);
    }
    /**
     * ListInstanceProcessModulesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessModules
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessModulesNext(resourceGroupName, name, processId, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, nextLink, options }, listInstanceProcessModulesNextOperationSpec);
    }
    /**
     * ListInstanceProcessThreadsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessThreads
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessThreadsNext(resourceGroupName, name, processId, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, nextLink, options }, listInstanceProcessThreadsNextOperationSpec);
    }
    /**
     * ListSiteBackupsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListSiteBackups method.
     * @param options The options parameters.
     */
    _listSiteBackupsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSiteBackupsNextOperationSpec);
    }
    /**
     * ListPerfMonCountersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param nextLink The nextLink from the previous successful call to the ListPerfMonCounters method.
     * @param options The options parameters.
     */
    _listPerfMonCountersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listPerfMonCountersNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionList method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getPrivateEndpointConnectionListNextOperationSpec);
    }
    /**
     * ListProcessesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListProcesses method.
     * @param options The options parameters.
     */
    _listProcessesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listProcessesNextOperationSpec);
    }
    /**
     * ListProcessModulesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param nextLink The nextLink from the previous successful call to the ListProcessModules method.
     * @param options The options parameters.
     */
    _listProcessModulesNext(resourceGroupName, name, processId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, nextLink, options }, listProcessModulesNextOperationSpec);
    }
    /**
     * ListProcessThreadsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param nextLink The nextLink from the previous successful call to the ListProcessThreads method.
     * @param options The options parameters.
     */
    _listProcessThreadsNext(resourceGroupName, name, processId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, nextLink, options }, listProcessThreadsNextOperationSpec);
    }
    /**
     * ListPublicCertificatesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListPublicCertificates method.
     * @param options The options parameters.
     */
    _listPublicCertificatesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listPublicCertificatesNextOperationSpec);
    }
    /**
     * ListSiteExtensionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListSiteExtensions method.
     * @param options The options parameters.
     */
    _listSiteExtensionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSiteExtensionsNextOperationSpec);
    }
    /**
     * ListSlotsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListSlots method.
     * @param options The options parameters.
     */
    _listSlotsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSlotsNextOperationSpec);
    }
    /**
     * ListBackupsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param nextLink The nextLink from the previous successful call to the ListBackupsSlot method.
     * @param options The options parameters.
     */
    _listBackupsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listBackupsSlotNextOperationSpec);
    }
    /**
     * ListBasicPublishingCredentialsPoliciesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListBasicPublishingCredentialsPoliciesSlot method.
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPoliciesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listBasicPublishingCredentialsPoliciesSlotNextOperationSpec);
    }
    /**
     * ListConfigurationsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListConfigurationsSlot method.
     * @param options The options parameters.
     */
    _listConfigurationsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listConfigurationsSlotNextOperationSpec);
    }
    /**
     * GetAppSettingsKeyVaultReferencesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetAppSettingsKeyVaultReferencesSlot method.
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferencesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, getAppSettingsKeyVaultReferencesSlotNextOperationSpec);
    }
    /**
     * GetSiteConnectionStringKeyVaultReferencesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetSiteConnectionStringKeyVaultReferencesSlot method.
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferencesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, getSiteConnectionStringKeyVaultReferencesSlotNextOperationSpec);
    }
    /**
     * ListConfigurationSnapshotInfoSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListConfigurationSnapshotInfoSlot method.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfoSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listConfigurationSnapshotInfoSlotNextOperationSpec);
    }
    /**
     * ListContinuousWebJobsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListContinuousWebJobsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listContinuousWebJobsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listContinuousWebJobsSlotNextOperationSpec);
    }
    /**
     * ListSlotSiteDeploymentStatusesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSlotSiteDeploymentStatusesSlot method.
     * @param options The options parameters.
     */
    _listSlotSiteDeploymentStatusesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSlotSiteDeploymentStatusesSlotNextOperationSpec);
    }
    /**
     * ListDeploymentsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListDeploymentsSlot method.
     * @param options The options parameters.
     */
    _listDeploymentsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listDeploymentsSlotNextOperationSpec);
    }
    /**
     * ListDomainOwnershipIdentifiersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListDomainOwnershipIdentifiersSlot method.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listDomainOwnershipIdentifiersSlotNextOperationSpec);
    }
    /**
     * ListInstanceFunctionsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceFunctionsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceFunctionsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listInstanceFunctionsSlotNextOperationSpec);
    }
    /**
     * ListHostNameBindingsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListHostNameBindingsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listHostNameBindingsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listHostNameBindingsSlotNextOperationSpec);
    }
    /**
     * ListInstanceIdentifiersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceIdentifiersSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceIdentifiersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listInstanceIdentifiersSlotNextOperationSpec);
    }
    /**
     * ListInstanceProcessesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessesSlotNext(resourceGroupName, name, slot, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, nextLink, options }, listInstanceProcessesSlotNextOperationSpec);
    }
    /**
     * ListInstanceProcessModulesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessModulesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessModulesSlotNext(resourceGroupName, name, processId, slot, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            processId,
            slot,
            instanceId,
            nextLink,
            options
        }, listInstanceProcessModulesSlotNextOperationSpec);
    }
    /**
     * ListInstanceProcessThreadsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessThreadsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessThreadsSlotNext(resourceGroupName, name, processId, slot, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            processId,
            slot,
            instanceId,
            nextLink,
            options
        }, listInstanceProcessThreadsSlotNextOperationSpec);
    }
    /**
     * ListSiteBackupsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param nextLink The nextLink from the previous successful call to the ListSiteBackupsSlot method.
     * @param options The options parameters.
     */
    _listSiteBackupsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSiteBackupsSlotNextOperationSpec);
    }
    /**
     * ListPerfMonCountersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param nextLink The nextLink from the previous successful call to the ListPerfMonCountersSlot
     *                 method.
     * @param options The options parameters.
     */
    _listPerfMonCountersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listPerfMonCountersSlotNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot Name of the site deployment slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionListSlot method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, getPrivateEndpointConnectionListSlotNextOperationSpec);
    }
    /**
     * ListProcessesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListProcessesSlot method.
     * @param options The options parameters.
     */
    _listProcessesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listProcessesSlotNextOperationSpec);
    }
    /**
     * ListProcessModulesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListProcessModulesSlot method.
     * @param options The options parameters.
     */
    _listProcessModulesSlotNext(resourceGroupName, name, processId, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, nextLink, options }, listProcessModulesSlotNextOperationSpec);
    }
    /**
     * ListProcessThreadsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListProcessThreadsSlot method.
     * @param options The options parameters.
     */
    _listProcessThreadsSlotNext(resourceGroupName, name, processId, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, nextLink, options }, listProcessThreadsSlotNextOperationSpec);
    }
    /**
     * ListPublicCertificatesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListPublicCertificatesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listPublicCertificatesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listPublicCertificatesSlotNextOperationSpec);
    }
    /**
     * ListSiteExtensionsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param nextLink The nextLink from the previous successful call to the ListSiteExtensionsSlot method.
     * @param options The options parameters.
     */
    _listSiteExtensionsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSiteExtensionsSlotNextOperationSpec);
    }
    /**
     * ListSlotDifferencesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param nextLink The nextLink from the previous successful call to the ListSlotDifferencesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listSlotDifferencesSlotNext(resourceGroupName, name, slot, slotSwapEntity, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, slotSwapEntity, nextLink, options }, listSlotDifferencesSlotNextOperationSpec);
    }
    /**
     * ListSnapshotsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param nextLink The nextLink from the previous successful call to the ListSnapshotsSlot method.
     * @param options The options parameters.
     */
    _listSnapshotsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSnapshotsSlotNextOperationSpec);
    }
    /**
     * ListSnapshotsFromDRSecondarySlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSnapshotsFromDRSecondarySlot method.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondarySlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSnapshotsFromDRSecondarySlotNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listTriggeredWebJobsSlotNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobHistorySlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobHistorySlot
     *                 method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistorySlotNext(resourceGroupName, name, webJobName, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, nextLink, options }, listTriggeredWebJobHistorySlotNextOperationSpec);
    }
    /**
     * ListUsagesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota
     *             information of the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListUsagesSlot method.
     * @param options The options parameters.
     */
    _listUsagesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listUsagesSlotNextOperationSpec);
    }
    /**
     * ListWebJobsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListWebJobsSlot method.
     * @param options The options parameters.
     */
    _listWebJobsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listWebJobsSlotNextOperationSpec);
    }
    /**
     * ListSlotDifferencesFromProductionNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSlotDifferencesFromProduction method.
     * @param options The options parameters.
     */
    _listSlotDifferencesFromProductionNext(resourceGroupName, name, slotSwapEntity, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotSwapEntity, nextLink, options }, listSlotDifferencesFromProductionNextOperationSpec);
    }
    /**
     * ListSnapshotsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param nextLink The nextLink from the previous successful call to the ListSnapshots method.
     * @param options The options parameters.
     */
    _listSnapshotsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSnapshotsNextOperationSpec);
    }
    /**
     * ListSnapshotsFromDRSecondaryNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param nextLink The nextLink from the previous successful call to the ListSnapshotsFromDRSecondary
     *                 method.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondaryNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSnapshotsFromDRSecondaryNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobs method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listTriggeredWebJobsNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobHistoryNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobHistory
     *                 method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistoryNext(resourceGroupName, name, webJobName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, nextLink, options }, listTriggeredWebJobHistoryNextOperationSpec);
    }
    /**
     * ListUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListUsages method.
     * @param options The options parameters.
     */
    _listUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listUsagesNextOperationSpec);
    }
    /**
     * ListWebJobsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListWebJobs method.
     * @param options The options parameters.
     */
    _listWebJobsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWebJobsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, includeSlots],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Site
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Site
        },
        201: {
            bodyMapper: Site
        },
        202: {
            bodyMapper: Site
        },
        204: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        deleteMetrics,
        deleteEmptyServerFarm
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Site
        },
        202: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const analyzeCustomHostnameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameAnalysisResult
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, hostName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const applySlotConfigToProductionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const backupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listBackupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getBackupStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItem
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteBackupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBackupStatusSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const restoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listBasicPublishingCredentialsPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getFtpAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateFtpAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getScmAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateScmAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateApplicationSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listApplicationSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateAuthSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteAuthSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getAuthSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAuthSettingsV2WithoutSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateAuthSettingsV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteAuthSettingsV2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getAuthSettingsV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2/list",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateAzureStorageAccountsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: azureStorageAccounts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listAzureStorageAccountsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateBackupConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteBackupConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getBackupConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAppSettingsKeyVaultReferencesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAppSettingKeyVaultReferenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings/{appSettingKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        appSettingKey
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteConnectionStringKeyVaultReferencesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteConnectionStringKeyVaultReferenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings/{connectionStringKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        connectionStringKey
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateConnectionStringsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionStrings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listConnectionStringsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getDiagnosticLogsConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateDiagnosticLogsConfigOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteLogsConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateMetadataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: metadata,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listMetadataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublishingCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: User
        },
        201: {
            bodyMapper: User
        },
        202: {
            bodyMapper: User
        },
        204: {
            bodyMapper: User
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSitePushSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PushSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: pushSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSitePushSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PushSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotConfigurationNamesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SlotConfigNamesResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSlotConfigurationNamesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SlotConfigNamesResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotConfigNames,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listConfigurationSnapshotInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getConfigurationSnapshotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        snapshotId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const recoverSiteConfigurationSnapshotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        snapshotId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getWebSiteContainerLogsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        204: {},
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept1],
    serializer: serializer$a
};
const getContainerLogsZipOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        204: {},
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept2],
    serializer: serializer$a
};
const listContinuousWebJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJob
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProductionSiteDeploymentStatusesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deploymentStatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProductionSiteDeploymentStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deploymentStatus/{deploymentStatusId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatus
        },
        201: {
            bodyMapper: CsmDeploymentStatus
        },
        202: {
            bodyMapper: CsmDeploymentStatus
        },
        204: {
            bodyMapper: CsmDeploymentStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        deploymentStatusId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDeploymentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getDeploymentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createDeploymentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Deployment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: deployment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteDeploymentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDeploymentLogOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const discoverBackupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RestoreRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listDomainOwnershipIdentifiersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Identifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Identifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Identifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getMSDeployStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createMSDeployOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        201: {
            bodyMapper: MSDeployStatus
        },
        202: {
            bodyMapper: MSDeployStatus
        },
        204: {
            bodyMapper: MSDeployStatus
        },
        409: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getMSDeployLogOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOneDeployStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/onedeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOneDeployOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/onedeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getFunctionsAdminTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope
        },
        201: {
            bodyMapper: FunctionEnvelope
        },
        202: {
            bodyMapper: FunctionEnvelope
        },
        204: {
            bodyMapper: FunctionEnvelope
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: functionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateFunctionSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo
        },
        201: {
            bodyMapper: KeyInfo
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
        keyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteFunctionSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listFunctionKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listFunctionSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listHostKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: HostKeys
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSyncStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listsyncstatus",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const syncFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/sync",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateHostSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo
        },
        201: {
            bodyMapper: KeyInfo
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        keyName,
        keyType
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteHostSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        keyName,
        keyType
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listHostNameBindingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getHostNameBindingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBinding
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateHostNameBindingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HostNameBinding
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: hostNameBinding,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteHostNameBindingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listHybridConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listRelayServiceConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listInstanceIdentifiersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebSiteInstanceStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceMsDeployStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createInstanceMSDeployOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        201: {
            bodyMapper: MSDeployStatus
        },
        202: {
            bodyMapper: MSDeployStatus
        },
        204: {
            bodyMapper: MSDeployStatus
        },
        409: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getInstanceMSDeployLogOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteInstanceProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceProcessDumpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessModulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceProcessModuleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
        baseAddress
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessThreadsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const isCloneableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteCloneability
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSiteBackupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listbackups",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSyncFunctionTriggersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const migrateStorageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageMigrationResponse
        },
        201: {
            bodyMapper: StorageMigrationResponse
        },
        202: {
            bodyMapper: StorageMigrationResponse
        },
        204: {
            bodyMapper: StorageMigrationResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: migrationOptions,
    queryParameters: [apiVersion, subscriptionName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const migrateMySqlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Operation
        },
        201: {
            bodyMapper: Operation
        },
        202: {
            bodyMapper: Operation
        },
        204: {
            bodyMapper: Operation
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: migrationRequestEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getMigrateMySqlStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MigrateMySqlStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSwiftVirtualNetworkConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateSwiftVirtualNetworkConnectionWithCheckOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteSwiftVirtualNetworkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSwiftVirtualNetworkConnectionWithCheckOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listNetworkFeaturesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkFeatures
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        view
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTraceOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startWebSiteNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startWebSiteNetworkTraceOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopWebSiteNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTracesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTraceOperationV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTracesV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const generateNewSitePublishingPasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPerfMonCountersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSitePhpErrorLogFlagOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SitePhpErrorLogFlag
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPremierAddOnsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const addPremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: premierAddOn,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deletePremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updatePremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: premierAddOn1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getPrivateAccessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateAccess
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const putPrivateAccessVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateAccess
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: access,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getPrivateEndpointConnectionListOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const approveOrRejectPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deletePrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPrivateLinkResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProcessDumpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessModulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProcessModuleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
        baseAddress
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessThreadsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublicCertificatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPublicCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        publicCertificateName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdatePublicCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicCertificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: publicCertificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        publicCertificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deletePublicCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        publicCertificateName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublishingProfileXmlWithSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: publishingProfileOptions,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [contentType, accept3],
    mediaType: "json",
    serializer: serializer$a
};
const resetProductionSlotConfigOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        softRestart,
        synchronous
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const restoreFromBackupBlobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const restoreFromDeletedAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: restoreRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const restoreSnapshotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: restoreRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSiteExtensionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteExtensionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteExtensionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const installSiteExtensionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo
        },
        201: {
            bodyMapper: SiteExtensionInfo
        },
        202: {
            bodyMapper: SiteExtensionInfo
        },
        204: {
            bodyMapper: SiteExtensionInfo
        },
        429: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteExtensionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteSiteExtensionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteExtensionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Site
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Site
        },
        201: {
            bodyMapper: Site
        },
        202: {
            bodyMapper: Site
        },
        204: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        deleteMetrics,
        deleteEmptyServerFarm
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Site
        },
        202: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const analyzeCustomHostnameSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameAnalysisResult
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, hostName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const applySlotConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const backupSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listBackupsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getBackupStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItem
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteBackupSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBackupStatusSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const restoreSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listBasicPublishingCredentialsPoliciesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getFtpAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateFtpAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getScmAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateScmAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listConfigurationsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateApplicationSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listApplicationSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateAuthSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteAuthSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getAuthSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAuthSettingsV2WithoutSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateAuthSettingsV2SlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteAuthSettingsV2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getAuthSettingsV2SlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2/list",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateAzureStorageAccountsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: azureStorageAccounts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listAzureStorageAccountsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateBackupConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteBackupConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getBackupConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAppSettingsKeyVaultReferencesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAppSettingKeyVaultReferenceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings/{appSettingKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        appSettingKey
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteConnectionStringKeyVaultReferencesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteConnectionStringKeyVaultReferenceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings/{connectionStringKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        connectionStringKey
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateConnectionStringsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionStrings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listConnectionStringsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getDiagnosticLogsConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateDiagnosticLogsConfigSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteLogsConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateMetadataSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: metadata,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listMetadataSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublishingCredentialsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: User
        },
        201: {
            bodyMapper: User
        },
        202: {
            bodyMapper: User
        },
        204: {
            bodyMapper: User
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSitePushSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PushSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: pushSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSitePushSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PushSettings
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listConfigurationSnapshotInfoSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getConfigurationSnapshotSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        snapshotId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const recoverSiteConfigurationSnapshotSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        snapshotId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getWebSiteContainerLogsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        204: {},
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept1],
    serializer: serializer$a
};
const getContainerLogsZipSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        204: {},
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept2],
    serializer: serializer$a
};
const listContinuousWebJobsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJob
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotSiteDeploymentStatusesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deploymentStatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSlotSiteDeploymentStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deploymentStatus/{deploymentStatusId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatus
        },
        201: {
            bodyMapper: CsmDeploymentStatus
        },
        202: {
            bodyMapper: CsmDeploymentStatus
        },
        204: {
            bodyMapper: CsmDeploymentStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        deploymentStatusId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDeploymentsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getDeploymentSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createDeploymentSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Deployment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: deployment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteDeploymentSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDeploymentLogSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const discoverBackupSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RestoreRequest
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listDomainOwnershipIdentifiersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Identifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Identifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Identifier
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getMSDeployStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createMSDeployOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        201: {
            bodyMapper: MSDeployStatus
        },
        202: {
            bodyMapper: MSDeployStatus
        },
        204: {
            bodyMapper: MSDeployStatus
        },
        409: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getMSDeployLogSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceFunctionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getFunctionsAdminTokenSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceFunctionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createInstanceFunctionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope
        },
        201: {
            bodyMapper: FunctionEnvelope
        },
        202: {
            bodyMapper: FunctionEnvelope
        },
        204: {
            bodyMapper: FunctionEnvelope
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: functionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteInstanceFunctionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateFunctionSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo
        },
        201: {
            bodyMapper: KeyInfo
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
        keyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteFunctionSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listFunctionKeysSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listFunctionSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listHostKeysSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: HostKeys
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSyncStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listsyncstatus",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const syncFunctionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/sync",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateHostSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo
        },
        201: {
            bodyMapper: KeyInfo
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        keyName,
        keyType
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteHostSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        keyName,
        keyType
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listHostNameBindingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getHostNameBindingSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBinding
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        hostName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateHostNameBindingSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HostNameBinding
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: hostNameBinding,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        hostName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteHostNameBindingSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        hostName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listHybridConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listRelayServiceConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listInstanceIdentifiersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceInfoSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebSiteInstanceStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceMsDeployStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createInstanceMSDeployOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus
        },
        201: {
            bodyMapper: MSDeployStatus
        },
        202: {
            bodyMapper: MSDeployStatus
        },
        204: {
            bodyMapper: MSDeployStatus
        },
        409: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getInstanceMSDeployLogSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteInstanceProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceProcessDumpSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessModulesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getInstanceProcessModuleSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
        baseAddress
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessThreadsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const isCloneableSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteCloneability
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSiteBackupsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listbackups",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSyncFunctionTriggersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getMigrateMySqlStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MigrateMySqlStatus
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSwiftVirtualNetworkConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteSwiftVirtualNetworkSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listNetworkFeaturesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkFeatures
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        view
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTraceOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startWebSiteNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startWebSiteNetworkTraceOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopWebSiteNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTracesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTraceOperationSlotV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getNetworkTracesSlotV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const generateNewSitePublishingPasswordSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPerfMonCountersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSitePhpErrorLogFlagSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SitePhpErrorLogFlag
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPremierAddOnsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const addPremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: premierAddOn,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deletePremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updatePremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PremierAddOn
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: premierAddOn1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getPrivateAccessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateAccess
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const putPrivateAccessVnetSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateAccess
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: access,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getPrivateEndpointConnectionListSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPrivateEndpointConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const approveOrRejectPrivateEndpointConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deletePrivateEndpointConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPrivateLinkResourcesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProcessDumpSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessModulesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getProcessModuleSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
        baseAddress
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessThreadsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublicCertificatesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPublicCertificateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        publicCertificateName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdatePublicCertificateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicCertificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: publicCertificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        publicCertificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deletePublicCertificateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        publicCertificateName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublishingProfileXmlWithSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: publishingProfileOptions,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [contentType, accept3],
    mediaType: "json",
    serializer: serializer$a
};
const resetSlotConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const restartSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        softRestart,
        synchronous
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const restoreFromBackupBlobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const restoreFromDeletedAppSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: restoreRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const restoreSnapshotSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: restoreRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSiteExtensionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteExtensionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        siteExtensionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const installSiteExtensionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo
        },
        201: {
            bodyMapper: SiteExtensionInfo
        },
        202: {
            bodyMapper: SiteExtensionInfo
        },
        204: {
            bodyMapper: SiteExtensionInfo
        },
        429: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        siteExtensionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteSiteExtensionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        siteExtensionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotDifferencesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const swapSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSnapshotsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSnapshotsFromDRSecondarySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteSourceControl
        },
        201: {
            bodyMapper: SiteSourceControl
        },
        202: {
            bodyMapper: SiteSourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteSourceControl
        },
        201: {
            bodyMapper: SiteSourceControl
        },
        202: {
            bodyMapper: SiteSourceControl
        },
        204: {
            bodyMapper: SiteSourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "DELETE",
    responses: {
        200: {},
        202: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, additionalFlags],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteSourceControl
        },
        201: {
            bodyMapper: SiteSourceControl
        },
        202: {
            bodyMapper: SiteSourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const startSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const syncRepositorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const syncFunctionTriggersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getTriggeredWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJob
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteTriggeredWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobHistorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getTriggeredWebJobHistorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistory
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const runTriggeredWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listUsagesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listVnetConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "VnetInfoResource" }
                    }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getVnetConnectionGatewaySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateVnetConnectionGatewaySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateVnetConnectionGatewaySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listWebJobsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJob
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotDifferencesFromProductionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const swapSlotWithProductionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSnapshotsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSnapshotsFromDRSecondaryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSourceControlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteSourceControl
        },
        201: {
            bodyMapper: SiteSourceControl
        },
        202: {
            bodyMapper: SiteSourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateSourceControlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteSourceControl
        },
        201: {
            bodyMapper: SiteSourceControl
        },
        202: {
            bodyMapper: SiteSourceControl
        },
        204: {
            bodyMapper: SiteSourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteSourceControlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "DELETE",
    responses: {
        200: {},
        202: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, additionalFlags],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateSourceControlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteSourceControl
        },
        201: {
            bodyMapper: SiteSourceControl
        },
        202: {
            bodyMapper: SiteSourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const startNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const stopNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const syncRepositoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const syncFunctionTriggersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getTriggeredWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJob
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteTriggeredWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getTriggeredWebJobHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistory
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const runTriggeredWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listVnetConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "VnetInfoResource" }
                    }
                }
            }
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetInfoResource
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getVnetConnectionGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateVnetConnectionGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateVnetConnectionGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetGateway
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listWebJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJob
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, includeSlots],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBackupsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBasicPublishingCredentialsPoliciesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listConfigurationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAppSettingsKeyVaultReferencesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteConnectionStringKeyVaultReferencesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listConfigurationSnapshotInfoNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listContinuousWebJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProductionSiteDeploymentStatusesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDeploymentsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDomainOwnershipIdentifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listFunctionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listHostNameBindingsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceIdentifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessModulesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSiteBackupsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPerfMonCountersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPrivateEndpointConnectionListNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessModulesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublicCertificatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSiteExtensionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBackupsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBasicPublishingCredentialsPoliciesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listConfigurationsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getAppSettingsKeyVaultReferencesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getSiteConnectionStringKeyVaultReferencesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listConfigurationSnapshotInfoSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listContinuousWebJobsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotSiteDeploymentStatusesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDeploymentsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDomainOwnershipIdentifiersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceFunctionsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listHostNameBindingsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceIdentifiersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessModulesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listInstanceProcessThreadsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        instanceId,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSiteBackupsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPerfMonCountersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getPrivateEndpointConnectionListSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessModulesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listProcessThreadsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        processId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listPublicCertificatesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSiteExtensionsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotDifferencesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSnapshotsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSnapshotsFromDRSecondarySlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobHistorySlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listUsagesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listWebJobsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSlotDifferencesFromProductionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listSnapshotsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSnapshotsFromDRSecondaryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listTriggeredWebJobHistoryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        webJobName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listUsagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listWebJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Workflows operations. */
class WorkflowsImpl {
    /**
     * Initialize a new instance of the class Workflows class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Regenerates the callback URL access key for request triggers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param keyType The access key type.
     * @param options The options parameters.
     */
    regenerateAccessKey(resourceGroupName, name, workflowName, keyType, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, keyType, options }, regenerateAccessKeyOperationSpec);
    }
    /**
     * Validates the workflow definition.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param validate The workflow.
     * @param options The options parameters.
     */
    validate(resourceGroupName, name, workflowName, validate, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, validate, options }, validateOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const regenerateAccessKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/regenerateAccessKey",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: keyType1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const validateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: validate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRuns operations. */
class WorkflowRunsImpl {
    /**
     * Initialize a new instance of the class WorkflowRuns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow runs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow runs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, listOperationSpec$7);
    }
    /**
     * Gets a workflow run.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, options }, getOperationSpec$7);
    }
    /**
     * Cancels a workflow run.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, name, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, options }, cancelOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActions operations. */
class WorkflowRunActionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow run actions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, options) {
        const iter = this.listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, options);
            }
        };
    }
    listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingPage_1() {
            let result = yield tslib.__await(this._listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, options));
            yield yield tslib.__await(result.inputs || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.inputs || []);
            }
        });
    }
    listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of workflow run actions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, options }, listOperationSpec$6);
    }
    /**
     * Gets a workflow run action.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, getOperationSpec$6);
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, listExpressionTracesOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, nextLink, options }, listNextOperationSpec$6);
    }
    /**
     * ListExpressionTracesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the ListExpressionTraces method.
     * @param options The options parameters.
     */
    _listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            nextLink,
            options
        }, listExpressionTracesNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunAction
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listExpressionTracesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/listExpressionTraces",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressionTraces
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listExpressionTracesNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressionTraces
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRepetitions operations. */
class WorkflowRunActionRepetitionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRepetitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all of a workflow run action repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, actionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        const iter = this.listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options);
            }
        };
    }
    listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingPage_1() {
            let result = yield tslib.__await(this._listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options));
            yield yield tslib.__await(result.inputs || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.inputs || []);
            }
        });
    }
    listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all of a workflow run action repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, listOperationSpec$5);
    }
    /**
     * Get a workflow run action repetition.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, getOperationSpec$5);
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    _listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, listExpressionTracesOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            nextLink,
            options
        }, listNextOperationSpec$5);
    }
    /**
     * ListExpressionTracesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param nextLink The nextLink from the previous successful call to the ListExpressionTraces method.
     * @param options The options parameters.
     */
    _listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            nextLink,
            options
        }, listExpressionTracesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listExpressionTracesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/listExpressionTraces",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressionTraces
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listExpressionTracesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressionTraces
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRepetitionsRequestHistories operations. */
class WorkflowRunActionRepetitionsRequestHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRepetitionsRequestHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List a workflow run repetition request history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List a workflow run repetition request history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, listOperationSpec$4);
    }
    /**
     * Gets a workflow run repetition request history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param requestHistoryName The request history name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, repetitionName, requestHistoryName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            requestHistoryName,
            options
        }, getOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            nextLink,
            options
        }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/requestHistories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/requestHistories/{requestHistoryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistory
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName,
        repetitionName,
        requestHistoryName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionScopeRepetitions operations. */
class WorkflowRunActionScopeRepetitionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionScopeRepetitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the workflow run action scoped repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, actionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the workflow run action scoped repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, listOperationSpec$3);
    }
    /**
     * Get a workflow run action scoped repetition.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, getOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            nextLink,
            options
        }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/scopeRepetitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/scopeRepetitions/{repetitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowTriggers operations. */
class WorkflowTriggersImpl {
    /**
     * Initialize a new instance of the class WorkflowTriggers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow triggers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow triggers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, listOperationSpec$2);
    }
    /**
     * Gets a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, getOperationSpec$2);
    }
    /**
     * Get the callback URL for a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    listCallbackUrl(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, listCallbackUrlOperationSpec);
    }
    /**
     * Runs a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    beginRun(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, workflowName, triggerName, options }, runOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Runs a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    beginRunAndWait(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRun(resourceGroupName, name, workflowName, triggerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the trigger schema as JSON.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    getSchemaJson(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, getSchemaJsonOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTrigger
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listCallbackUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/listCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const runOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getSchemaJsonOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/schemas/json",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JsonSchema
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowTriggerHistories operations. */
class WorkflowTriggerHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowTriggerHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow trigger histories.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, triggerName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, triggerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, triggerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, triggerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, triggerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, triggerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow trigger histories.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, listOperationSpec$1);
    }
    /**
     * Gets a workflow trigger history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, triggerName, historyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            triggerName,
            historyName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Resubmits a workflow run based on the trigger history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    beginResubmit(resourceGroupName, name, workflowName, triggerName, historyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                name,
                workflowName,
                triggerName,
                historyName,
                options
            }, resubmitOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resubmits a workflow run based on the trigger history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    beginResubmitAndWait(resourceGroupName, name, workflowName, triggerName, historyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResubmit(resourceGroupName, name, workflowName, triggerName, historyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, triggerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/histories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/histories/{historyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistory
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName,
        historyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const resubmitOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/histories/{historyName}/resubmit",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        triggerName,
        historyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowVersions operations. */
class WorkflowVersionsImpl {
    /**
     * Initialize a new instance of the class WorkflowVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow versions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, name, workflowName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow versions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, listOperationSpec);
    }
    /**
     * Gets a workflow version.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param versionId The workflow versionId.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, versionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, versionId, options }, getOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/versions/{versionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
        versionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
class WebSiteManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the WebSiteManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Your Azure subscription ID. This is a GUID-formatted string (e.g.
     *                       00000000-0000-0000-0000-000000000000).
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-appservice/13.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2022-03-01";
        this.appServiceCertificateOrders = new AppServiceCertificateOrdersImpl(this);
        this.certificateOrdersDiagnostics = new CertificateOrdersDiagnosticsImpl(this);
        this.certificateRegistrationProvider = new CertificateRegistrationProviderImpl(this);
        this.domains = new DomainsImpl(this);
        this.topLevelDomains = new TopLevelDomainsImpl(this);
        this.domainRegistrationProvider = new DomainRegistrationProviderImpl(this);
        this.appServiceEnvironments = new AppServiceEnvironmentsImpl(this);
        this.appServicePlans = new AppServicePlansImpl(this);
        this.certificates = new CertificatesImpl(this);
        this.containerApps = new ContainerAppsImpl(this);
        this.containerAppsRevisions = new ContainerAppsRevisionsImpl(this);
        this.deletedWebApps = new DeletedWebAppsImpl(this);
        this.diagnostics = new DiagnosticsImpl(this);
        this.global = new GlobalImpl(this);
        this.kubeEnvironments = new KubeEnvironmentsImpl(this);
        this.provider = new ProviderImpl(this);
        this.recommendations = new RecommendationsImpl(this);
        this.resourceHealthMetadataOperations = new ResourceHealthMetadataOperationsImpl(this);
        this.staticSites = new StaticSitesImpl(this);
        this.webApps = new WebAppsImpl(this);
        this.workflows = new WorkflowsImpl(this);
        this.workflowRuns = new WorkflowRunsImpl(this);
        this.workflowRunActions = new WorkflowRunActionsImpl(this);
        this.workflowRunActionRepetitions = new WorkflowRunActionRepetitionsImpl(this);
        this.workflowRunActionRepetitionsRequestHistories = new WorkflowRunActionRepetitionsRequestHistoriesImpl(this);
        this.workflowRunActionScopeRepetitions = new WorkflowRunActionScopeRepetitionsImpl(this);
        this.workflowTriggers = new WorkflowTriggersImpl(this);
        this.workflowTriggerHistories = new WorkflowTriggerHistoriesImpl(this);
        this.workflowVersions = new WorkflowVersionsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Description for Gets the source controls available for Azure websites.
     * @param options The options parameters.
     */
    listSourceControls(options) {
        const iter = this.listSourceControlsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSourceControlsPagingPage(options);
            }
        };
    }
    listSourceControlsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listSourceControlsPagingPage_1() {
            let result = yield tslib.__await(this._listSourceControls(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSourceControlsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSourceControlsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listSourceControlsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSourceControlsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets a list of meters for a given location.
     * @param options The options parameters.
     */
    listBillingMeters(options) {
        const iter = this.listBillingMetersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBillingMetersPagingPage(options);
            }
        };
    }
    listBillingMetersPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBillingMetersPagingPage_1() {
            let result = yield tslib.__await(this._listBillingMeters(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBillingMetersNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBillingMetersPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBillingMetersPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBillingMetersPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get custom hostnames under this subscription
     * @param options The options parameters.
     */
    listCustomHostNameSites(options) {
        const iter = this.listCustomHostNameSitesPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCustomHostNameSitesPagingPage(options);
            }
        };
    }
    listCustomHostNameSitesPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listCustomHostNameSitesPagingPage_1() {
            let result = yield tslib.__await(this._listCustomHostNameSites(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCustomHostNameSitesNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCustomHostNameSitesPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listCustomHostNameSitesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCustomHostNameSitesPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get a list of available geographical regions.
     * @param options The options parameters.
     */
    listGeoRegions(options) {
        const iter = this.listGeoRegionsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listGeoRegionsPagingPage(options);
            }
        };
    }
    listGeoRegionsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listGeoRegionsPagingPage_1() {
            let result = yield tslib.__await(this._listGeoRegions(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listGeoRegionsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listGeoRegionsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listGeoRegionsPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listGeoRegionsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for List all apps that are assigned to a hostname.
     * @param nameIdentifier Hostname information.
     * @param options The options parameters.
     */
    listSiteIdentifiersAssignedToHostName(nameIdentifier, options) {
        const iter = this.listSiteIdentifiersAssignedToHostNamePagingAll(nameIdentifier, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options);
            }
        };
    }
    listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteIdentifiersAssignedToHostNamePagingPage_1() {
            let result = yield tslib.__await(this._listSiteIdentifiersAssignedToHostName(nameIdentifier, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteIdentifiersAssignedToHostNameNext(nameIdentifier, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSiteIdentifiersAssignedToHostNamePagingAll(nameIdentifier, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteIdentifiersAssignedToHostNamePagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List all premier add-on offers.
     * @param options The options parameters.
     */
    listPremierAddOnOffers(options) {
        const iter = this.listPremierAddOnOffersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPremierAddOnOffersPagingPage(options);
            }
        };
    }
    listPremierAddOnOffersPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPremierAddOnOffersPagingPage_1() {
            let result = yield tslib.__await(this._listPremierAddOnOffers(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPremierAddOnOffersNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPremierAddOnOffersPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPremierAddOnOffersPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPremierAddOnOffersPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Gets publishing user
     * @param options The options parameters.
     */
    getPublishingUser(options) {
        return this.sendOperationRequest({ options }, getPublishingUserOperationSpec);
    }
    /**
     * Description for Updates publishing user
     * @param userDetails Details of publishing user
     * @param options The options parameters.
     */
    updatePublishingUser(userDetails, options) {
        return this.sendOperationRequest({ userDetails, options }, updatePublishingUserOperationSpec);
    }
    /**
     * Description for Gets the source controls available for Azure websites.
     * @param options The options parameters.
     */
    _listSourceControls(options) {
        return this.sendOperationRequest({ options }, listSourceControlsOperationSpec);
    }
    /**
     * Description for Gets source control token
     * @param sourceControlType Type of source control
     * @param options The options parameters.
     */
    getSourceControl(sourceControlType, options) {
        return this.sendOperationRequest({ sourceControlType, options }, getSourceControlOperationSpec);
    }
    /**
     * Description for Updates source control token
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @param options The options parameters.
     */
    updateSourceControl(sourceControlType, requestMessage, options) {
        return this.sendOperationRequest({ sourceControlType, requestMessage, options }, updateSourceControlOperationSpec);
    }
    /**
     * Description for Gets a list of meters for a given location.
     * @param options The options parameters.
     */
    _listBillingMeters(options) {
        return this.sendOperationRequest({ options }, listBillingMetersOperationSpec);
    }
    /**
     * Description for Check if a resource name is available.
     * @param name Resource name to verify.
     * @param typeParam Resource type used for verification.
     * @param options The options parameters.
     */
    checkNameAvailability(name, typeParam, options) {
        return this.sendOperationRequest({ name, typeParam, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Get custom hostnames under this subscription
     * @param options The options parameters.
     */
    _listCustomHostNameSites(options) {
        return this.sendOperationRequest({ options }, listCustomHostNameSitesOperationSpec);
    }
    /**
     * Description for Gets list of available geo regions plus ministamps
     * @param options The options parameters.
     */
    getSubscriptionDeploymentLocations(options) {
        return this.sendOperationRequest({ options }, getSubscriptionDeploymentLocationsOperationSpec);
    }
    /**
     * Description for Get a list of available geographical regions.
     * @param options The options parameters.
     */
    _listGeoRegions(options) {
        return this.sendOperationRequest({ options }, listGeoRegionsOperationSpec);
    }
    /**
     * Description for List all apps that are assigned to a hostname.
     * @param nameIdentifier Hostname information.
     * @param options The options parameters.
     */
    _listSiteIdentifiersAssignedToHostName(nameIdentifier, options) {
        return this.sendOperationRequest({ nameIdentifier, options }, listSiteIdentifiersAssignedToHostNameOperationSpec);
    }
    /**
     * Description for List all premier add-on offers.
     * @param options The options parameters.
     */
    _listPremierAddOnOffers(options) {
        return this.sendOperationRequest({ options }, listPremierAddOnOffersOperationSpec);
    }
    /**
     * Description for List all SKUs.
     * @param options The options parameters.
     */
    listSkus(options) {
        return this.sendOperationRequest({ options }, listSkusOperationSpec);
    }
    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the
     * Network Security Group rules.
     * @param parameters VNET information
     * @param options The options parameters.
     */
    verifyHostingEnvironmentVnet(parameters, options) {
        return this.sendOperationRequest({ parameters, options }, verifyHostingEnvironmentVnetOperationSpec);
    }
    /**
     * Description for Move resources between resource groups.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param options The options parameters.
     */
    move(resourceGroupName, moveResourceEnvelope, options) {
        return this.sendOperationRequest({ resourceGroupName, moveResourceEnvelope, options }, moveOperationSpec);
    }
    /**
     * Description for Validate if a resource can be created.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @param options The options parameters.
     */
    validate(resourceGroupName, validateRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, validateRequest, options }, validateOperationSpec);
    }
    /**
     * Description for Validate whether a resource can be moved.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param options The options parameters.
     */
    validateMove(resourceGroupName, moveResourceEnvelope, options) {
        return this.sendOperationRequest({ resourceGroupName, moveResourceEnvelope, options }, validateMoveOperationSpec);
    }
    /**
     * ListSourceControlsNext
     * @param nextLink The nextLink from the previous successful call to the ListSourceControls method.
     * @param options The options parameters.
     */
    _listSourceControlsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listSourceControlsNextOperationSpec);
    }
    /**
     * ListBillingMetersNext
     * @param nextLink The nextLink from the previous successful call to the ListBillingMeters method.
     * @param options The options parameters.
     */
    _listBillingMetersNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listBillingMetersNextOperationSpec);
    }
    /**
     * ListCustomHostNameSitesNext
     * @param nextLink The nextLink from the previous successful call to the ListCustomHostNameSites
     *                 method.
     * @param options The options parameters.
     */
    _listCustomHostNameSitesNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listCustomHostNameSitesNextOperationSpec);
    }
    /**
     * ListGeoRegionsNext
     * @param nextLink The nextLink from the previous successful call to the ListGeoRegions method.
     * @param options The options parameters.
     */
    _listGeoRegionsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listGeoRegionsNextOperationSpec);
    }
    /**
     * ListSiteIdentifiersAssignedToHostNameNext
     * @param nameIdentifier Hostname information.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSiteIdentifiersAssignedToHostName method.
     * @param options The options parameters.
     */
    _listSiteIdentifiersAssignedToHostNameNext(nameIdentifier, nextLink, options) {
        return this.sendOperationRequest({ nameIdentifier, nextLink, options }, listSiteIdentifiersAssignedToHostNameNextOperationSpec);
    }
    /**
     * ListPremierAddOnOffersNext
     * @param nextLink The nextLink from the previous successful call to the ListPremierAddOnOffers method.
     * @param options The options parameters.
     */
    _listPremierAddOnOffersNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listPremierAddOnOffersNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getPublishingUserOperationSpec = {
    path: "/providers/Microsoft.Web/publishingUsers/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: User
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer
};
const updatePublishingUserOperationSpec = {
    path: "/providers/Microsoft.Web/publishingUsers/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: User
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: userDetails,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listSourceControlsOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControlCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer
};
const getSourceControlOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, sourceControlType],
    headerParameters: [accept],
    serializer
};
const updateSourceControlOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: requestMessage,
    queryParameters: [apiVersion],
    urlParameters: [$host, sourceControlType],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listBillingMetersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BillingMeterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        billingLocation,
        osType
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceNameAvailability
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: {
        parameterPath: {
            name: ["name"],
            typeParam: ["typeParam"],
            isFqdn: ["options", "isFqdn"]
        },
        mapper: Object.assign(Object.assign({}, ResourceNameAvailabilityRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listCustomHostNameSitesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/customhostnameSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameSitesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, hostname],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const getSubscriptionDeploymentLocationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentLocations
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listGeoRegionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoRegionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        sku,
        linuxWorkersEnabled,
        xenonWorkersEnabled,
        linuxDynamicWorkersEnabled
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listSiteIdentifiersAssignedToHostNameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: nameIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listPremierAddOnOffersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOnOfferCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfos
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const verifyHostingEnvironmentVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VnetValidationFailureDetails
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const moveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: moveResourceEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: validateRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const validateMoveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: moveResourceEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listSourceControlsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControlCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer
};
const listBillingMetersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BillingMeterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        billingLocation,
        osType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listCustomHostNameSitesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameSitesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, hostname],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listGeoRegionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoRegionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        sku,
        linuxWorkersEnabled,
        xenonWorkersEnabled,
        linuxDynamicWorkersEnabled
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listSiteIdentifiersAssignedToHostNameNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listPremierAddOnOffersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOnOfferCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

exports.WebSiteManagementClient = WebSiteManagementClient;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 9626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var coreRestPipeline = __nccwpck_require__(6938);
var logger$1 = __nccwpck_require__(803);

// Copyright (c) Microsoft Corporation.
/**
 * Encodes a byte array in base64 format.
 * @param value - the Uint8Aray to encode
 * @internal
 */
function encodeByteArray(value) {
    // Buffer.from accepts <ArrayBuffer> | <SharedArrayBuffer>-- the TypeScript definition is off here
    // https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
}
/**
 * Decodes a base64 string into a byte array.
 * @param value - the base64 string to decode
 * @internal
 */
function decodeString(value) {
    return Buffer.from(value, "base64");
}
/**
 * Decodes a base64 string into a string.
 * @param value - the base64 string to decode
 * @internal
 */
function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */
const XML_ATTRKEY = "$";
/**
 * Default key used to access the XML value content.
 */
const XML_CHARKEY = "_";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A type guard for a primitive response body.
 * @param value - Value to test
 *
 * @internal
 */
function isPrimitiveBody(value, mapperTypeName) {
    return (mapperTypeName !== "Composite" &&
        mapperTypeName !== "Dictionary" &&
        (typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean" ||
            (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !==
                null ||
            value === undefined ||
            value === null));
}
const validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
/**
 * Returns true if the given string is in ISO 8601 format.
 * @param value - The value to be validated for ISO 8601 duration format.
 * @internal
 */
function isDuration(value) {
    return validateISODuration.test(value);
}
const validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Returns true if the provided uuid is valid.
 *
 * @param uuid - The uuid that needs to be validated.
 *
 * @internal
 */
function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
}
/**
 * Maps the response as follows:
 * - wraps the response body if needed (typically if its type is primitive).
 * - returns null if the combination of the headers and the body is empty.
 * - otherwise, returns the combination of the headers and the body.
 *
 * @param responseObject - a representation of the parsed response
 * @returns the response that will be returned to the user which can be null and/or wrapped
 *
 * @internal
 */
function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
    if (responseObject.hasNullableType &&
        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
        return responseObject.shouldWrapBody ? { body: null } : null;
    }
    else {
        return responseObject.shouldWrapBody
            ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
    }
}
/**
 * Take a `FullOperationResponse` and turn it into a flat
 * response object to hand back to the consumer.
 * @param fullResponse - The processed response from the operation request
 * @param responseSpec - The response map from the OperationSpec
 *
 * @internal
 */
function flattenResponse(fullResponse, responseSpec) {
    var _a, _b;
    const parsedHeaders = fullResponse.parsedHeaders;
    // head methods never have a body, but we return a boolean set to body property
    // to indicate presence/absence of the resource
    if (fullResponse.request.method === "HEAD") {
        return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
    /** If the body is asked for, we look at the expected body type to handle it */
    if (expectedBodyTypeName === "Stream") {
        return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
    }
    const modelProperties = (expectedBodyTypeName === "Composite" &&
        bodyMapper.type.modelProperties) ||
        {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];
        for (const key of Object.keys(modelProperties)) {
            if (modelProperties[key].serializedName) {
                arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
            }
        }
        if (parsedHeaders) {
            for (const key of Object.keys(parsedHeaders)) {
                arrayResponse[key] = parsedHeaders[key];
            }
        }
        return isNullable &&
            !fullResponse.parsedBody &&
            !parsedHeaders &&
            Object.getOwnPropertyNames(modelProperties).length === 0
            ? null
            : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
        body: fullResponse.parsedBody,
        headers: parsedHeaders,
        hasNullableType: isNullable,
        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),
    });
}

// Copyright (c) Microsoft Corporation.
class SerializerImpl {
    constructor(modelMappers = {}, isXML = false) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
    }
    /**
     * @deprecated Removing the constraints validation on client side.
     */
    validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
            throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value !== undefined && value !== null) {
            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems, } = mapper.constraints;
            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
                failValidation("ExclusiveMaximum", ExclusiveMaximum);
            }
            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
                failValidation("ExclusiveMinimum", ExclusiveMinimum);
            }
            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
                failValidation("InclusiveMaximum", InclusiveMaximum);
            }
            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
                failValidation("InclusiveMinimum", InclusiveMinimum);
            }
            if (MaxItems !== undefined && value.length > MaxItems) {
                failValidation("MaxItems", MaxItems);
            }
            if (MaxLength !== undefined && value.length > MaxLength) {
                failValidation("MaxLength", MaxLength);
            }
            if (MinItems !== undefined && value.length < MinItems) {
                failValidation("MinItems", MinItems);
            }
            if (MinLength !== undefined && value.length < MinLength) {
                failValidation("MinLength", MinLength);
            }
            if (MultipleOf !== undefined && value % MultipleOf !== 0) {
                failValidation("MultipleOf", MultipleOf);
            }
            if (Pattern) {
                const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
                if (typeof value !== "string" || value.match(pattern) === null) {
                    failValidation("Pattern", Pattern);
                }
            }
            if (UniqueItems &&
                value.some((item, i, ar) => ar.indexOf(item) !== i)) {
                failValidation("UniqueItems", UniqueItems);
            }
        }
    }
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param object - A valid Javascript object to be serialized
     *
     * @param objectName - Name of the serialized object
     *
     * @param options - additional options to serialization
     *
     * @returns A valid serialized Javascript object
     */
    serialize(mapper, object, objectName, options = { xml: {} }) {
        var _a, _b, _c;
        const updatedOptions = {
            xml: {
                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,
            },
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
            objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
            payload = [];
        }
        if (mapper.isConstant) {
            object = mapper.defaultValue;
        }
        // This table of allowed values should help explain
        // the mapper.required and mapper.nullable properties.
        // X means "neither undefined or null are allowed".
        //           || required
        //           || true      | false
        //  nullable || ==========================
        //      true || null      | undefined/null
        //     false || X         | undefined
        // undefined || X         | undefined/null
        const { required, nullable } = mapper;
        if (required && nullable && object === undefined) {
            throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && (object === undefined || object === null)) {
            throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
            throw new Error(`${objectName} cannot be null.`);
        }
        if (object === undefined || object === null) {
            payload = object;
        }
        else {
            if (mapperType.match(/^any$/i) !== null) {
                payload = object;
            }
            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
                payload = serializeBasicTypes(mapperType, objectName, object);
            }
            else if (mapperType.match(/^Enum$/i) !== null) {
                const enumMapper = mapper;
                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
            }
            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
                payload = serializeDateTypes(mapperType, object, objectName);
            }
            else if (mapperType.match(/^ByteArray$/i) !== null) {
                payload = serializeByteArrayType(objectName, object);
            }
            else if (mapperType.match(/^Base64Url$/i) !== null) {
                payload = serializeBase64UrlType(objectName, object);
            }
            else if (mapperType.match(/^Sequence$/i) !== null) {
                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
            else if (mapperType.match(/^Dictionary$/i) !== null) {
                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
            else if (mapperType.match(/^Composite$/i) !== null) {
                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
        }
        return payload;
    }
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param responseBody - A valid Javascript entity to be deserialized
     *
     * @param objectName - Name of the deserialized object
     *
     * @param options - Controls behavior of XML parser and builder.
     *
     * @returns A valid deserialized Javascript object
     */
    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
        var _a, _b, _c;
        const updatedOptions = {
            xml: {
                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,
            },
        };
        if (responseBody === undefined || responseBody === null) {
            if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
                // between the list being empty versus being missing,
                // so let's do the more user-friendly thing and return an empty list.
                responseBody = [];
            }
            // specifically check for undefined as default value can be a falsey value `0, "", false, null`
            if (mapper.defaultValue !== undefined) {
                responseBody = mapper.defaultValue;
            }
            return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
            objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        }
        else {
            if (this.isXML) {
                const xmlCharKey = updatedOptions.xml.xmlCharKey;
                /**
                 * If the mapper specifies this as a non-composite type value but the responseBody contains
                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
                 */
                if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
                    responseBody = responseBody[xmlCharKey];
                }
            }
            if (mapperType.match(/^Number$/i) !== null) {
                payload = parseFloat(responseBody);
                if (isNaN(payload)) {
                    payload = responseBody;
                }
            }
            else if (mapperType.match(/^Boolean$/i) !== null) {
                if (responseBody === "true") {
                    payload = true;
                }
                else if (responseBody === "false") {
                    payload = false;
                }
                else {
                    payload = responseBody;
                }
            }
            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
                payload = responseBody;
            }
            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
                payload = new Date(responseBody);
            }
            else if (mapperType.match(/^UnixTime$/i) !== null) {
                payload = unixTimeToDate(responseBody);
            }
            else if (mapperType.match(/^ByteArray$/i) !== null) {
                payload = decodeString(responseBody);
            }
            else if (mapperType.match(/^Base64Url$/i) !== null) {
                payload = base64UrlToByteArray(responseBody);
            }
            else if (mapperType.match(/^Sequence$/i) !== null) {
                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
            }
            else if (mapperType.match(/^Dictionary$/i) !== null) {
                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
            }
        }
        if (mapper.isConstant) {
            payload = mapper.defaultValue;
        }
        return payload;
    }
}
/**
 * Method that creates and returns a Serializer.
 * @param modelMappers - Known models to map
 * @param isXML - If XML should be supported
 */
function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
}
function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
        --len;
    }
    return str.substr(0, len);
}
function bufferToBase64Url(buffer) {
    if (!buffer) {
        return undefined;
    }
    if (!(buffer instanceof Uint8Array)) {
        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    // Uint8Array to Base64.
    const str = encodeByteArray(buffer);
    // Base64 to Base64Url.
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str) {
    if (!str) {
        return undefined;
    }
    if (str && typeof str.valueOf() !== "string") {
        throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    // Base64Url to Base64.
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    // Base64 to Uint8Array.
    return decodeString(str);
}
function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
        const subwords = prop.split(".");
        for (const item of subwords) {
            if (item.charAt(item.length - 1) === "\\") {
                partialclass += item.substr(0, item.length - 1) + ".";
            }
            else {
                partialclass += item;
                classes.push(partialclass);
                partialclass = "";
            }
        }
    }
    return classes;
}
function dateToUnixTime(d) {
    if (!d) {
        return undefined;
    }
    if (typeof d.valueOf() === "string") {
        d = new Date(d);
    }
    return Math.floor(d.getTime() / 1000);
}
function unixTimeToDate(n) {
    if (!n) {
        return undefined;
    }
    return new Date(n * 1000);
}
function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
        if (typeName.match(/^Number$/i) !== null) {
            if (typeof value !== "number") {
                throw new Error(`${objectName} with value ${value} must be of type number.`);
            }
        }
        else if (typeName.match(/^String$/i) !== null) {
            if (typeof value.valueOf() !== "string") {
                throw new Error(`${objectName} with value "${value}" must be of type string.`);
            }
        }
        else if (typeName.match(/^Uuid$/i) !== null) {
            if (!(typeof value.valueOf() === "string" && isValidUuid(value))) {
                throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
            }
        }
        else if (typeName.match(/^Boolean$/i) !== null) {
            if (typeof value !== "boolean") {
                throw new Error(`${objectName} with value ${value} must be of type boolean.`);
            }
        }
        else if (typeName.match(/^Stream$/i) !== null) {
            const objectType = typeof value;
            if (objectType !== "string" &&
                typeof value.pipe !== "function" &&
                !(value instanceof ArrayBuffer) &&
                !ArrayBuffer.isView(value) &&
                // File objects count as a type of Blob, so we want to use instanceof explicitly
                !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) {
                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or NodeJS.ReadableStream.`);
            }
        }
    }
    return value;
}
function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
        if (typeof item.valueOf() === "string") {
            return item.toLowerCase() === value.toLowerCase();
        }
        return item === value;
    });
    if (!isPresent) {
        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
}
function serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
        if (!(value instanceof Uint8Array)) {
            throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = encodeByteArray(value);
    }
    return value;
}
function serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
        if (!(value instanceof Uint8Array)) {
            throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = bufferToBase64Url(value);
    }
    return value;
}
function serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
        if (typeName.match(/^Date$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
            }
            value =
                value instanceof Date
                    ? value.toISOString().substring(0, 10)
                    : new Date(value).toISOString().substring(0, 10);
        }
        else if (typeName.match(/^DateTime$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
            }
            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
        }
        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
            }
            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
        }
        else if (typeName.match(/^UnixTime$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +
                    `for it to be serialized in UnixTime/Epoch format.`);
            }
            value = dateToUnixTime(value);
        }
        else if (typeName.match(/^TimeSpan$/i) !== null) {
            if (!isDuration(value)) {
                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
            }
        }
    }
    return value;
}
function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    var _a;
    if (!Array.isArray(object)) {
        throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}.`);
    }
    // Quirk: Composite mappers referenced by `element` might
    // not have *all* properties declared (like uberParent),
    // so let's try to look up the full definition by name.
    if (elementType.type.name === "Composite" && elementType.type.className) {
        elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;
    }
    const tempArray = [];
    for (let i = 0; i < object.length; i++) {
        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
        if (isXml && elementType.xmlNamespace) {
            const xmlnsKey = elementType.xmlNamespacePrefix
                ? `xmlns:${elementType.xmlNamespacePrefix}`
                : "xmlns";
            if (elementType.type.name === "Composite") {
                tempArray[i] = Object.assign({}, serializedValue);
                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
            }
            else {
                tempArray[i] = {};
                tempArray[i][options.xml.xmlCharKey] = serializedValue;
                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
            }
        }
        else {
            tempArray[i] = serializedValue;
        }
    }
    return tempArray;
}
function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object") {
        throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object)) {
        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
        // If the element needs an XML namespace we need to add it within the $ property
        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    // Add the namespace to the root element if needed
    if (isXml && mapper.xmlNamespace) {
        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
        const result = tempDictionary;
        result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
        return result;
    }
    return tempDictionary;
}
/**
 * Resolves the additionalProperties property from a referenced mapper
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */
function resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
}
/**
 * Finds the mapper referenced by className
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */
function resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
        throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    }
    return serializer.modelMappers[className];
}
/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 */
function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        if (!modelMapper) {
            throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
        }
        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
        if (!modelProps) {
            throw new Error(`modelProperties cannot be null or undefined in the ` +
                `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
        }
    }
    return modelProps;
}
function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    }
    if (object !== undefined && object !== null) {
        const payload = {};
        const modelProps = resolveModelProperties(serializer, mapper, objectName);
        for (const key of Object.keys(modelProps)) {
            const propertyMapper = modelProps[key];
            if (propertyMapper.readOnly) {
                continue;
            }
            let propName;
            let parentObject = payload;
            if (serializer.isXML) {
                if (propertyMapper.xmlIsWrapped) {
                    propName = propertyMapper.xmlName;
                }
                else {
                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
                }
            }
            else {
                const paths = splitSerializeName(propertyMapper.serializedName);
                propName = paths.pop();
                for (const pathName of paths) {
                    const childObject = parentObject[pathName];
                    if ((childObject === undefined || childObject === null) &&
                        ((object[key] !== undefined && object[key] !== null) ||
                            propertyMapper.defaultValue !== undefined)) {
                        parentObject[pathName] = {};
                    }
                    parentObject = parentObject[pathName];
                }
            }
            if (parentObject !== undefined && parentObject !== null) {
                if (isXml && mapper.xmlNamespace) {
                    const xmlnsKey = mapper.xmlNamespacePrefix
                        ? `xmlns:${mapper.xmlNamespacePrefix}`
                        : "xmlns";
                    parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
                }
                const propertyObjectName = propertyMapper.serializedName !== ""
                    ? objectName + "." + propertyMapper.serializedName
                    : objectName;
                let toSerialize = object[key];
                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
                if (polymorphicDiscriminator &&
                    polymorphicDiscriminator.clientName === key &&
                    (toSerialize === undefined || toSerialize === null)) {
                    toSerialize = mapper.serializedName;
                }
                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
                if (serializedValue !== undefined && propName !== undefined && propName !== null) {
                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
                    if (isXml && propertyMapper.xmlIsAttribute) {
                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
                        // This keeps things simple while preventing name collision
                        // with names in user documents.
                        parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
                        parentObject[XML_ATTRKEY][propName] = serializedValue;
                    }
                    else if (isXml && propertyMapper.xmlIsWrapped) {
                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };
                    }
                    else {
                        parentObject[propName] = value;
                    }
                }
            }
        }
        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
        if (additionalPropertiesMapper) {
            const propNames = Object.keys(modelProps);
            for (const clientPropName in object) {
                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
                if (isAdditionalProperty) {
                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
                }
            }
        }
        return payload;
    }
    return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace) {
        return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix
        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`
        : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
        if (serializedValue[XML_ATTRKEY]) {
            return serializedValue;
        }
        else {
            const result = Object.assign({}, serializedValue);
            result[XML_ATTRKEY] = xmlNamespace;
            return result;
        }
    }
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = xmlNamespace;
    return result;
}
function isSpecialXmlProperty(propertyName, options) {
    return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        const paths = splitSerializeName(modelProps[key].serializedName);
        handledPropertyNames.push(paths[0]);
        const { serializedName, xmlName, xmlElementName } = propertyMapper;
        let propertyObjectName = objectName;
        if (serializedName !== "" && serializedName !== undefined) {
            propertyObjectName = objectName + "." + serializedName;
        }
        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
            const dictionary = {};
            for (const headerKey of Object.keys(responseBody)) {
                if (headerKey.startsWith(headerCollectionPrefix)) {
                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
                }
                handledPropertyNames.push(headerKey);
            }
            instance[key] = dictionary;
        }
        else if (serializer.isXML) {
            if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {
                instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
            }
            else {
                const propertyName = xmlElementName || xmlName || serializedName;
                if (propertyMapper.xmlIsWrapped) {
                    /* a list of <xmlElementName> wrapped by <xmlName>
                      For the xml example below
                        <Cors>
                          <CorsRule>...</CorsRule>
                          <CorsRule>...</CorsRule>
                        </Cors>
                      the responseBody has
                        {
                          Cors: {
                            CorsRule: [{...}, {...}]
                          }
                        }
                      xmlName is "Cors" and xmlElementName is"CorsRule".
                    */
                    const wrapped = responseBody[xmlName];
                    const elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
                }
                else {
                    const property = responseBody[propertyName];
                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
                }
            }
        }
        else {
            // deserialize the property if it is present in the provided responseBody instance
            let propertyInstance;
            let res = responseBody;
            // traversing the object step by step.
            for (const item of paths) {
                if (!res)
                    break;
                res = res[item];
            }
            propertyInstance = res;
            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
            // checking that the model property name (key)(ex: "fishtype") and the
            // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
            // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
            // is a better approach. The generator is not consistent with escaping '\.' in the
            // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
            // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
            // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
            // the transformation of model property name (ex: "fishtype") is done consistently.
            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
            if (polymorphicDiscriminator &&
                key === polymorphicDiscriminator.clientName &&
                (propertyInstance === undefined || propertyInstance === null)) {
                propertyInstance = mapper.serializedName;
            }
            let serializedValue;
            // paging
            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
                propertyInstance = responseBody[key];
                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                // Copy over any properties that have already been added into the instance, where they do
                // not exist on the newly de-serialized array
                for (const [k, v] of Object.entries(instance)) {
                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
                        arrayInstance[k] = v;
                    }
                }
                instance = arrayInstance;
            }
            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                instance[key] = serializedValue;
            }
        }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
        const isAdditionalProperty = (responsePropName) => {
            for (const clientPropName in modelProps) {
                const paths = splitSerializeName(modelProps[clientPropName].serializedName);
                if (paths[0] === responsePropName) {
                    return false;
                }
            }
            return true;
        };
        for (const responsePropName in responseBody) {
            if (isAdditionalProperty(responsePropName)) {
                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
            }
        }
    }
    else if (responseBody) {
        for (const key of Object.keys(responseBody)) {
            if (instance[key] === undefined &&
                !handledPropertyNames.includes(key) &&
                !isSpecialXmlProperty(key, options)) {
                instance[key] = responseBody[key];
            }
        }
    }
    return instance;
}
function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    /* jshint validthis: true */
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
        const tempDictionary = {};
        for (const key of Object.keys(responseBody)) {
            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
        }
        return tempDictionary;
    }
    return responseBody;
}
function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
        if (!Array.isArray(responseBody)) {
            // xml2js will interpret a single element array as just the element, so force it to be an array
            responseBody = [responseBody];
        }
        // Quirk: Composite mappers referenced by `element` might
        // not have *all* properties declared (like uberParent),
        // so let's try to look up the full definition by name.
        if (element.type.name === "Composite" && element.type.className) {
            element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;
        }
        const tempArray = [];
        for (let i = 0; i < responseBody.length; i++) {
            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
        }
        return tempArray;
    }
    return responseBody;
}
function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
        const currentName = typeNamesToCheck.shift();
        const indexDiscriminator = discriminatorValue === currentName
            ? discriminatorValue
            : currentName + "." + discriminatorValue;
        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
            return discriminators[indexDiscriminator];
        }
        else {
            for (const [name, mapper] of Object.entries(discriminators)) {
                if (name.startsWith(currentName + ".") &&
                    mapper.type.uberParent === currentName &&
                    mapper.type.className) {
                    typeNamesToCheck.push(mapper.type.className);
                }
            }
        }
    }
    return undefined;
}
function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var _a;
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
        if (discriminatorName) {
            // The serializedName might have \\, which we just want to ignore
            if (polymorphicPropertyName === "serializedName") {
                discriminatorName = discriminatorName.replace(/\\/gi, "");
            }
            const discriminatorValue = object[discriminatorName];
            const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;
            if (typeof discriminatorValue === "string" && typeName) {
                const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
                if (polymorphicMapper) {
                    mapper = polymorphicMapper;
                }
            }
        }
    }
    return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return (mapper.type.polymorphicDiscriminator ||
        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||
        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));
}
function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return (typeName &&
        serializer.modelMappers[typeName] &&
        serializer.modelMappers[typeName].type.polymorphicDiscriminator);
}
/**
 * Known types of Mappers
 */
const MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime",
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Retrieves the value to use for a given operation argument
 * @param operationArguments - The arguments passed from the generated client
 * @param parameter - The parameter description
 * @param fallbackObject - If something isn't found in the arguments bag, look here.
 *  Generally used to look at the service client properties.
 */
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
        parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
        if (parameterPath.length > 0) {
            if (parameterMapper.isConstant) {
                value = parameterMapper.defaultValue;
            }
            else {
                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
                if (!propertySearchResult.propertyFound && fallbackObject) {
                    propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
                }
                let useDefaultValue = false;
                if (!propertySearchResult.propertyFound) {
                    useDefaultValue =
                        parameterMapper.required ||
                            (parameterPath[0] === "options" && parameterPath.length === 2);
                }
                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
            }
        }
    }
    else {
        if (parameterMapper.required) {
            value = {};
        }
        for (const propertyName in parameterPath) {
            const propertyMapper = parameterMapper.type.modelProperties[propertyName];
            const propertyPath = parameterPath[propertyName];
            const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
                parameterPath: propertyPath,
                mapper: propertyMapper,
            }, fallbackObject);
            if (propertyValue !== undefined) {
                if (!value) {
                    value = {};
                }
                value[propertyName] = propertyValue;
            }
        }
    }
    return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
    const result = { propertyFound: false };
    let i = 0;
    for (; i < parameterPath.length; ++i) {
        const parameterPathPart = parameterPath[i];
        // Make sure to check inherited properties too, so don't use hasOwnProperty().
        if (parent && parameterPathPart in parent) {
            parent = parent[parameterPathPart];
        }
        else {
            break;
        }
    }
    if (i === parameterPath.length) {
        result.propertyValue = parent;
        result.propertyFound = true;
    }
    return result;
}
const operationRequestMap = new WeakMap();
function getOperationRequestInfo(request) {
    let info = operationRequestMap.get(request);
    if (!info) {
        info = {};
        operationRequestMap.set(request, info);
    }
    return info;
}

// Copyright (c) Microsoft Corporation.
const defaultJsonContentTypes = ["application/json", "text/json"];
const defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
/**
 * The programmatic identifier of the deserializationPolicy.
 */
const deserializationPolicyName = "deserializationPolicy";
/**
 * This policy handles parsing out responses according to OperationSpecs on the request.
 */
function deserializationPolicy(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;
    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;
    const parseXML = options.parseXML;
    const serializerOptions = options.serializerOptions;
    const updatedOptions = {
        xml: {
            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY,
        },
    };
    return {
        name: deserializationPolicyName,
        async sendRequest(request, next) {
            const response = await next(request);
            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
        },
    };
}
function getOperationResponseMap(parsedResponse) {
    let result;
    const request = parsedResponse.request;
    const operationInfo = getOperationRequestInfo(request);
    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
    if (operationSpec) {
        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
            result = operationSpec.responses[parsedResponse.status];
        }
        else {
            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
        }
    }
    return result;
}
function shouldDeserializeResponse(parsedResponse) {
    const request = parsedResponse.request;
    const operationInfo = getOperationRequestInfo(request);
    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
    let result;
    if (shouldDeserialize === undefined) {
        result = true;
    }
    else if (typeof shouldDeserialize === "boolean") {
        result = shouldDeserialize;
    }
    else {
        result = shouldDeserialize(parsedResponse);
    }
    return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!shouldDeserializeResponse(parsedResponse)) {
        return parsedResponse;
    }
    const operationInfo = getOperationRequestInfo(parsedResponse.request);
    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
        return parsedResponse;
    }
    const responseSpec = getOperationResponseMap(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);
    if (error) {
        throw error;
    }
    else if (shouldReturnResponse) {
        return parsedResponse;
    }
    // An operation response spec does exist for current status code, so
    // use it to deserialize the response.
    if (responseSpec) {
        if (responseSpec.bodyMapper) {
            let valueToDeserialize = parsedResponse.parsedBody;
            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
                valueToDeserialize =
                    typeof valueToDeserialize === "object"
                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]
                        : [];
            }
            try {
                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody");
            }
            catch (deserializeError) {
                const restError = new coreRestPipeline.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
                    statusCode: parsedResponse.status,
                    request: parsedResponse.request,
                    response: parsedResponse,
                });
                throw restError;
            }
        }
        else if (operationSpec.httpMethod === "HEAD") {
            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
        }
        if (responseSpec.headersMapper) {
            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
    }
    return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return (expectedStatusCodes.length === 0 ||
        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
    var _a;
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)
        ? isSuccessByStatus
        : !!responseSpec;
    if (isExpectedStatusCode) {
        if (responseSpec) {
            if (!responseSpec.isError) {
                return { error: null, shouldReturnResponse: false };
            }
        }
        else {
            return { error: null, shouldReturnResponse: false };
        }
    }
    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))
        ? `Unexpected status code: ${parsedResponse.status}`
        : parsedResponse.bodyAsText;
    const error = new coreRestPipeline.RestError(initialErrorMessage, {
        statusCode: parsedResponse.status,
        request: parsedResponse.request,
        response: parsedResponse,
    });
    // If the item failed but there's no error spec or default spec to deserialize the error,
    // we should fail so we just throw the parsed response
    if (!errorResponseSpec) {
        throw error;
    }
    const defaultBodyMapper = errorResponseSpec.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec.headersMapper;
    try {
        // If error response has a body, try to deserialize it using default body mapper.
        // Then try to extract error code & message from it
        if (parsedResponse.parsedBody) {
            const parsedBody = parsedResponse.parsedBody;
            let deserializedError;
            if (defaultBodyMapper) {
                let valueToDeserialize = parsedBody;
                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
                    valueToDeserialize = [];
                    const elementName = defaultBodyMapper.xmlElementName;
                    if (typeof parsedBody === "object" && elementName) {
                        valueToDeserialize = parsedBody[elementName];
                    }
                }
                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
            }
            const internalError = parsedBody.error || deserializedError || parsedBody;
            error.code = internalError.code;
            if (internalError.message) {
                error.message = internalError.message;
            }
            if (defaultBodyMapper) {
                error.response.parsedBody = deserializedError;
            }
        }
        // If error response has headers, try to deserialize it using default header mapper
        if (parsedResponse.headers && defaultHeadersMapper) {
            error.response.parsedHeaders =
                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
    }
    catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a;
    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&
        operationResponse.bodyAsText) {
        const text = operationResponse.bodyAsText;
        const contentType = operationResponse.headers.get("Content-Type") || "";
        const contentComponents = !contentType
            ? []
            : contentType.split(";").map((component) => component.toLowerCase());
        try {
            if (contentComponents.length === 0 ||
                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
                operationResponse.parsedBody = JSON.parse(text);
                return operationResponse;
            }
            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
                if (!parseXML) {
                    throw new Error("Parsing XML not supported.");
                }
                const body = await parseXML(text, opts.xml);
                operationResponse.parsedBody = body;
                return operationResponse;
            }
        }
        catch (err) {
            const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
            const errCode = err.code || coreRestPipeline.RestError.PARSE_ERROR;
            const e = new coreRestPipeline.RestError(msg, {
                code: errCode,
                statusCode: operationResponse.status,
                request: operationResponse.request,
                response: operationResponse,
            });
            throw e;
        }
    }
    return operationResponse;
}

// Copyright (c) Microsoft Corporation.
/**
 * Gets the list of status codes for streaming responses.
 * @internal
 */
function getStreamingResponseStatusCodes(operationSpec) {
    const result = new Set();
    for (const statusCode in operationSpec.responses) {
        const operationResponse = operationSpec.responses[statusCode];
        if (operationResponse.bodyMapper &&
            operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
            result.add(Number(statusCode));
        }
    }
    return result;
}
/**
 * Get the path to this parameter's value as a dotted string (a.b.c).
 * @param parameter - The parameter to get the path string for.
 * @returns The path to this parameter's value as a dotted string.
 * @internal
 */
function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result;
    if (typeof parameterPath === "string") {
        result = parameterPath;
    }
    else if (Array.isArray(parameterPath)) {
        result = parameterPath.join(".");
    }
    else {
        result = mapper.serializedName;
    }
    return result;
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the serializationPolicy.
 */
const serializationPolicyName = "serializationPolicy";
/**
 * This policy handles assembling the request body and headers using
 * an OperationSpec and OperationArguments on the request.
 */
function serializationPolicy(options = {}) {
    const stringifyXML = options.stringifyXML;
    return {
        name: serializationPolicyName,
        async sendRequest(request, next) {
            const operationInfo = getOperationRequestInfo(request);
            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
            if (operationSpec && operationArguments) {
                serializeHeaders(request, operationArguments, operationSpec);
                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
            }
            return next(request);
        },
    };
}
/**
 * @internal
 */
function serializeHeaders(request, operationArguments, operationSpec) {
    var _a, _b;
    if (operationSpec.headerParameters) {
        for (const headerParameter of operationSpec.headerParameters) {
            let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {
                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
                const headerCollectionPrefix = headerParameter.mapper
                    .headerCollectionPrefix;
                if (headerCollectionPrefix) {
                    for (const key of Object.keys(headerValue)) {
                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);
                    }
                }
                else {
                    request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
                }
            }
        }
    }
    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
    if (customHeaders) {
        for (const customHeaderName of Object.keys(customHeaders)) {
            request.headers.set(customHeaderName, customHeaders[customHeaderName]);
        }
    }
}
/**
 * @internal
 */
function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {
    throw new Error("XML serialization unsupported!");
}) {
    var _a, _b, _c, _d, _e;
    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
    const updatedOptions = {
        xml: {
            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY,
        },
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
        const bodyMapper = operationSpec.requestBody.mapper;
        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;
        const typeName = bodyMapper.type.name;
        try {
            if ((request.body !== undefined && request.body !== null) ||
                (nullable && request.body === null) ||
                required) {
                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
                const isStream = typeName === MapperTypeNames.Stream;
                if (operationSpec.isXML) {
                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
                    if (typeName === MapperTypeNames.Sequence) {
                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
                    }
                    else if (!isStream) {
                        request.body = stringifyXML(value, {
                            rootName: xmlName || serializedName,
                            xmlCharKey,
                        });
                    }
                }
                else if (typeName === MapperTypeNames.String &&
                    (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
                    // the String serializer has validated that request body is a string
                    // so just send the string.
                    return;
                }
                else if (!isStream) {
                    request.body = JSON.stringify(request.body);
                }
            }
        }
        catch (error) {
            throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
        }
    }
    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        request.formData = {};
        for (const formDataParameter of operationSpec.formDataParameters) {
            const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
            }
        }
    }
}
/**
 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
 */
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    // Composite and Sequence schemas already got their root namespace set during serialization
    // We just need to add xmlns to the other schema types
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
        const result = {};
        result[options.xml.xmlCharKey] = serializedValue;
        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
        return result;
    }
    return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) {
        obj = [obj];
    }
    if (!xmlNamespaceKey || !xmlNamespace) {
        return { [elementName]: obj };
    }
    const result = { [elementName]: obj };
    result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
    return result;
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a new Pipeline for use with a Service Client.
 * Adds in deserializationPolicy by default.
 * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.
 * @param options - Options to customize the created pipeline.
 */
function createClientPipeline(options = {}) {
    const pipeline = coreRestPipeline.createPipelineFromOptions(options !== null && options !== void 0 ? options : {});
    if (options.credentialOptions) {
        pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential: options.credentialOptions.credential,
            scopes: options.credentialOptions.credentialScopes,
        }));
    }
    pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
    pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
        phase: "Deserialize",
    });
    return pipeline;
}

// Copyright (c) Microsoft Corporation.
let cachedHttpClient;
function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) {
        cachedHttpClient = coreRestPipeline.createDefaultHttpClient();
    }
    return cachedHttpClient;
}

// Copyright (c) Microsoft Corporation.
const CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|",
};
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
        let path = replaceAll(operationSpec.path, urlReplacements);
        // QUIRK: sometimes we get a path component like /{nextLink}
        // which may be a fully formed URL with a leading /. In that case, we should
        // remove the leading /
        if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
            path = path.substring(1);
        }
        // QUIRK: sometimes we get a path component like {nextLink}
        // which may be a fully formed URL. In that case, we should
        // ignore the baseUri.
        if (isAbsoluteUrl(path)) {
            requestUrl = path;
            isAbsolutePath = true;
        }
        else {
            requestUrl = appendPath(requestUrl, path);
        }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    /**
     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`
     * is an absolute path. This ensures that existing query parameter values in `requestUrl`
     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it
     * is still being built so there is nothing to overwrite.
     */
    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
}
function replaceAll(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements) {
        result = result.split(searchValue).join(replaceValue);
    }
    return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map();
    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {
        for (const urlParameter of operationSpec.urlParameters) {
            let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
            const parameterPathString = getPathStringFromParameter(urlParameter);
            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
            if (!urlParameter.skipEncoding) {
                urlParameterValue = encodeURIComponent(urlParameterValue);
            }
            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
        }
    }
    return result;
}
function isAbsoluteUrl(url) {
    return url.includes("://");
}
function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
        return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
        newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
        pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
        const path = pathToAppend.substring(0, searchStart);
        const search = pathToAppend.substring(searchStart + 1);
        newPath = newPath + path;
        if (search) {
            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
        }
    }
    else {
        newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map();
    const sequenceParams = new Set();
    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {
        for (const queryParameter of operationSpec.queryParameters) {
            if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
                sequenceParams.add(queryParameter.mapper.serializedName);
            }
            let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||
                queryParameter.mapper.required) {
                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
                const delimiter = queryParameter.collectionFormat
                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]
                    : "";
                if (Array.isArray(queryParameterValue)) {
                    // replace null and undefined
                    queryParameterValue = queryParameterValue.map((item) => {
                        if (item === null || item === undefined) {
                            return "";
                        }
                        return item;
                    });
                }
                if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
                    continue;
                }
                else if (Array.isArray(queryParameterValue) &&
                    (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
                    queryParameterValue = queryParameterValue.join(delimiter);
                }
                if (!queryParameter.skipEncoding) {
                    if (Array.isArray(queryParameterValue)) {
                        queryParameterValue = queryParameterValue.map((item) => {
                            return encodeURIComponent(item);
                        });
                    }
                    else {
                        queryParameterValue = encodeURIComponent(queryParameterValue);
                    }
                }
                // Join pipes and CSV *after* encoding, or the server will be upset.
                if (Array.isArray(queryParameterValue) &&
                    (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
                    queryParameterValue = queryParameterValue.join(delimiter);
                }
                result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
            }
        }
    }
    return {
        queryParams: result,
        sequenceParams,
    };
}
function simpleParseQueryParams(queryString) {
    const result = new Map();
    if (!queryString || queryString[0] !== "?") {
        return result;
    }
    // remove the leading ?
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
        const [name, value] = pair.split("=", 2);
        const existingValue = result.get(name);
        if (existingValue) {
            if (Array.isArray(existingValue)) {
                existingValue.push(value);
            }
            else {
                result.set(name, [existingValue, value]);
            }
        }
        else {
            result.set(name, value);
        }
    }
    return result;
}
/** @internal */
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
        return url;
    }
    const parsedUrl = new URL(url);
    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which
    // can change their meaning to the server, such as in the case of a SAS signature.
    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
        const existingValue = combinedParams.get(name);
        if (Array.isArray(existingValue)) {
            if (Array.isArray(value)) {
                existingValue.push(...value);
                const valueSet = new Set(existingValue);
                combinedParams.set(name, Array.from(valueSet));
            }
            else {
                existingValue.push(value);
            }
        }
        else if (existingValue) {
            if (Array.isArray(value)) {
                value.unshift(existingValue);
            }
            else if (sequenceParams.has(name)) {
                combinedParams.set(name, [existingValue, value]);
            }
            if (!noOverwrite) {
                combinedParams.set(name, value);
            }
        }
        else {
            combinedParams.set(name, value);
        }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
        if (typeof value === "string") {
            searchPieces.push(`${name}=${value}`);
        }
        else if (Array.isArray(value)) {
            // QUIRK: If we get an array of values, include multiple key/value pairs
            for (const subValue of value) {
                searchPieces.push(`${name}=${subValue}`);
            }
        }
        else {
            searchPieces.push(`${name}=${value}`);
        }
    }
    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
}

// Copyright (c) Microsoft Corporation.
const logger = logger$1.createClientLogger("core-client");

// Copyright (c) Microsoft Corporation.
/**
 * Initializes a new instance of the ServiceClient.
 */
class ServiceClient {
    /**
     * The ServiceClient constructor
     * @param credential - The credentials used for authentication with the service.
     * @param options - The service client options that govern the behavior of the client.
     */
    constructor(options = {}) {
        var _a, _b;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;
        if (options.baseUri) {
            logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
            for (const { policy, position } of options.additionalPolicies) {
                // Sign happens after Retry and is commonly needed to occur
                // before policies that intercept post-retry.
                const afterPhase = position === "perRetry" ? "Sign" : undefined;
                this.pipeline.addPolicy(policy, {
                    afterPhase,
                });
            }
        }
    }
    /**
     * Send the provided httpRequest.
     */
    async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
    }
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @typeParam T - The typed result of the request, based on the OperationSpec.
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     */
    async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
            throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        // Templatized URLs sometimes reference properties on the ServiceClient child class,
        // so we have to pass `this` below in order to search these properties if they're
        // not part of OperationArguments
        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);
        const request = coreRestPipeline.createPipelineRequest({
            url,
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = getOperationRequestInfo(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
            request.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
            const requestOptions = options.requestOptions;
            if (requestOptions) {
                if (requestOptions.timeout) {
                    request.timeout = requestOptions.timeout;
                }
                if (requestOptions.onUploadProgress) {
                    request.onUploadProgress = requestOptions.onUploadProgress;
                }
                if (requestOptions.onDownloadProgress) {
                    request.onDownloadProgress = requestOptions.onDownloadProgress;
                }
                if (requestOptions.shouldDeserialize !== undefined) {
                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
                }
                if (requestOptions.allowInsecureConnection) {
                    request.allowInsecureConnection = true;
                }
            }
            if (options.abortSignal) {
                request.abortSignal = options.abortSignal;
            }
            if (options.tracingOptions) {
                request.tracingOptions = options.tracingOptions;
            }
        }
        if (this._allowInsecureConnection) {
            request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === undefined) {
            request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
        }
        try {
            const rawResponse = await this.sendRequest(request);
            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
            return flatResponse;
        }
        catch (error) {
            if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
                const rawResponse = error.response;
                const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
                error.details = flatResponse;
                if (options === null || options === void 0 ? void 0 : options.onResponse) {
                    options.onResponse(rawResponse, flatResponse, error);
                }
            }
            throw error;
        }
    }
}
function createDefaultPipeline(options) {
    const credentialScopes = getCredentialScopes(options);
    const credentialOptions = options.credential && credentialScopes
        ? { credentialScopes, credential: options.credential }
        : undefined;
    return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
    if (options.credentialScopes) {
        const scopes = options.credentialScopes;
        return Array.isArray(scopes)
            ? scopes.map((scope) => new URL(scope).toString())
            : new URL(scopes).toString();
    }
    if (options.endpoint) {
        return `${options.endpoint}/.default`;
    }
    if (options.baseUri) {
        return `${options.baseUri}/.default`;
    }
    if (options.credential && !options.credentialScopes) {
        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return undefined;
}

// Copyright (c) Microsoft Corporation.
/**
 * Converts: `Bearer a="b", c="d", Bearer d="e", f="g"`.
 * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.
 *
 * @internal
 */
function parseCAEChallenge(challenges) {
    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
    return bearerChallenges.map((challenge) => {
        const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
        // Key-value pairs to plain object:
        return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
    });
}
/**
 * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:
 * [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).
 *
 * Call the `bearerTokenAuthenticationPolicy` with the following options:
 *
 * ```ts
 * import { bearerTokenAuthenticationPolicy } from "@azure/core-rest-pipeline";
 * import { authorizeRequestOnClaimChallenge } from "@azure/core-client";
 *
 * const bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy({
 *   authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge
 * });
 * ```
 *
 * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.
 * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.
 *
 * Example challenge with claims:
 *
 * ```
 * Bearer authorization_uri="https://login.windows-ppe.net/", error="invalid_token",
 * error_description="User session has been revoked",
 * claims="eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0="
 * ```
 */
async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
    const { scopes, response } = onChallengeOptions;
    const logger$1 = onChallengeOptions.logger || logger;
    const challenge = response.headers.get("WWW-Authenticate");
    if (!challenge) {
        logger$1.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
        return false;
    }
    const challenges = parseCAEChallenge(challenge) || [];
    const parsedChallenge = challenges.find((x) => x.claims);
    if (!parsedChallenge) {
        logger$1.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
        return false;
    }
    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
        claims: decodeStringToString(parsedChallenge.claims),
    });
    if (!accessToken) {
        return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    return true;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A set of constants used internally when processing requests.
 */
const Constants = {
    DefaultScope: "/.default",
    /**
     * Defines constants for use with HTTP headers.
     */
    HeaderConstants: {
        /**
         * The Authorization header.
         */
        AUTHORIZATION: "authorization",
    },
};
/**
 * Defines a callback to handle auth challenge for Storage APIs.
 * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge
 * Handling has specific features for storage that departs to the general AAD challenge docs.
 **/
const authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
        const challengeInfo = parseChallenge(challenge);
        const challengeScopes = buildScopes(challengeOptions, challengeInfo);
        const tenantId = extractTenantId(challengeInfo);
        const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));
        if (!accessToken) {
            return false;
        }
        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
        return true;
    }
    return false;
};
/**
 * Extracts the tenant id from the challenge information
 * The tenant id is contained in the authorization_uri as the first
 * path part.
 */
function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    return tenantId;
}
/**
 * Builds the authentication scopes based on the information that comes in the
 * challenge information. Scopes url is present in the resource_id, if it is empty
 * we keep using the original scopes.
 */
function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_uri) {
        return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_uri);
    challengeScopes.pathname = Constants.DefaultScope;
    return [challengeScopes.toString()];
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */
function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
        return challenge;
    }
    return;
}
/**
 * Converts: `Bearer a="b" c="d"`.
 * Into: `[ { a: 'b', c: 'd' }]`.
 *
 * @internal
 */
function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    // Key-value pairs to plain object:
    return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
}
/**
 * Extracts the options form a Pipeline Request for later re-use
 */
function requestToOptions(request) {
    return {
        abortSignal: request.abortSignal,
        requestOptions: {
            timeout: request.timeout,
        },
        tracingOptions: request.tracingOptions,
    };
}

exports.MapperTypeNames = MapperTypeNames;
exports.ServiceClient = ServiceClient;
exports.XML_ATTRKEY = XML_ATTRKEY;
exports.XML_CHARKEY = XML_CHARKEY;
exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
exports.createClientPipeline = createClientPipeline;
exports.createSerializer = createSerializer;
exports.deserializationPolicy = deserializationPolicy;
exports.deserializationPolicyName = deserializationPolicyName;
exports.serializationPolicy = serializationPolicy;
exports.serializationPolicyName = serializationPolicyName;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 8584:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var logger$1 = __nccwpck_require__(803);
var abortController = __nccwpck_require__(1925);

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 * @internal
 */
const logger = logger$1.createClientLogger("core-lro");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The default time interval to wait before sending the next polling request.
 */
const POLL_INTERVAL_IN_MS = 2000;
/**
 * The closed set of terminal states.
 */
const terminalStates = ["succeeded", "canceled", "failed"];

// Copyright (c) Microsoft Corporation.
/**
 * Deserializes the state
 */
function deserializeState(serializedState) {
    try {
        return JSON.parse(serializedState).state;
    }
    catch (e) {
        throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
}
function setStateError(inputs) {
    const { state, stateProxy } = inputs;
    return (error) => {
        stateProxy.setError(state, error);
        stateProxy.setFailed(state);
        throw error;
    };
}
function processOperationStatus(result) {
    const { state, stateProxy, status } = result;
    logger.verbose(`LRO: Status:\n\tPolling from: ${state.config.operationLocation}\n\tOperation status: ${status}\n\tPolling status: ${terminalStates.includes(status) ? "Stopped" : "Running"}`);
    switch (status) {
        case "succeeded": {
            stateProxy.setSucceeded(state);
            break;
        }
        case "failed": {
            stateProxy.setError(state, new Error(`The long-running operation has failed`));
            stateProxy.setFailed(state);
            break;
        }
        case "canceled": {
            stateProxy.setCanceled(state);
            break;
        }
    }
}
function buildResult(inputs) {
    const { processResult, response, state } = inputs;
    return processResult ? processResult(response, state) : response;
}
/**
 * Initiates the long-running operation.
 */
async function initOperation(inputs) {
    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation } = inputs;
    const { operationLocation, resourceLocation, metadata, response } = await init();
    if (operationLocation)
        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
    const config = {
        metadata,
        operationLocation,
        resourceLocation,
    };
    logger.verbose(`LRO: Operation description:`, config);
    const state = stateProxy.initState(config);
    const status = getOperationStatus(response, state);
    if (status === "succeeded" || operationLocation === undefined) {
        stateProxy.setSucceeded(state);
        stateProxy.setResult(state, buildResult({
            response,
            state,
            processResult,
        }));
    }
    return state;
}
async function pollOperationHelper(inputs) {
    const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, options, } = inputs;
    const response = await poll(operationLocation, options).catch(setStateError({
        state,
        stateProxy,
    }));
    const status = getOperationStatus(response, state);
    processOperationStatus({
        status,
        state,
        stateProxy,
    });
    if (status === "succeeded") {
        const resourceLocation = getResourceLocation(response, state);
        if (resourceLocation !== undefined) {
            return {
                response: await poll(resourceLocation).catch(setStateError({ state, stateProxy })),
                status,
            };
        }
    }
    return { response, status };
}
/** Polls the long-running operation. */
async function pollOperation(inputs) {
    const { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, withOperationLocation, getPollingInterval, processResult, updateState, setDelay, isDone, } = inputs;
    const { operationLocation } = state.config;
    if (operationLocation !== undefined) {
        const { response, status } = await pollOperationHelper({
            poll,
            getOperationStatus,
            state,
            stateProxy,
            operationLocation,
            getResourceLocation,
            options,
        });
        if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) ||
            (isDone === undefined && ["succeeded", "canceled"].includes(status))) {
            stateProxy.setResult(state, buildResult({
                response,
                state,
                processResult,
            }));
        }
        else {
            const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);
            if (intervalInMs)
                setDelay(intervalInMs);
            const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);
            if (location !== undefined) {
                const isUpdated = operationLocation !== location;
                state.config.operationLocation = location;
                withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);
            }
            else
                withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
        }
        updateState === null || updateState === void 0 ? void 0 : updateState(state, response);
    }
}

// Copyright (c) Microsoft Corporation.
function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
}
function getLocationHeader(rawResponse) {
    return rawResponse.headers["location"];
}
function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
}
function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
}
function findResourceLocation(inputs) {
    const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
        case "PUT": {
            return requestPath;
        }
        case "DELETE": {
            return undefined;
        }
        default: {
            switch (resourceLocationConfig) {
                case "azure-async-operation": {
                    return undefined;
                }
                case "original-uri": {
                    return requestPath;
                }
                case "location":
                default: {
                    return location;
                }
            }
        }
    }
}
function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
    const operationLocation = getOperationLocationHeader(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
    const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
    const location = getLocationHeader(rawResponse);
    const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== undefined) {
        return {
            mode: "OperationLocation",
            operationLocation: pollingUrl,
            resourceLocation: findResourceLocation({
                requestMethod: normalizedRequestMethod,
                location,
                requestPath,
                resourceLocationConfig,
            }),
        };
    }
    else if (location !== undefined) {
        return {
            mode: "ResourceLocation",
            operationLocation: location,
        };
    }
    else if (normalizedRequestMethod === "PUT" && requestPath) {
        return {
            mode: "Body",
            operationLocation: requestPath,
        };
    }
    else {
        return undefined;
    }
}
function transformStatus(status) {
    switch (status === null || status === void 0 ? void 0 : status.toLowerCase()) {
        case undefined:
        case "succeeded":
            return "succeeded";
        case "failed":
            return "failed";
        case "running":
        case "accepted":
        case "canceling":
        case "cancelling":
            return "running";
        case "canceled":
        case "cancelled":
            return "canceled";
        default: {
            logger.warning(`LRO: unrecognized operation status: ${status}`);
            return status;
        }
    }
}
function getStatus(rawResponse) {
    var _a;
    const { status } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    return transformStatus(status);
}
function getProvisioningState(rawResponse) {
    var _a, _b;
    const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    const state = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
    return transformStatus(state);
}
function toOperationStatus(statusCode) {
    if (statusCode === 202) {
        return "running";
    }
    else if (statusCode < 300) {
        return "succeeded";
    }
    else {
        return "failed";
    }
}
function parseRetryAfter({ rawResponse }) {
    const retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== undefined) {
        // Retry-After header value is either in HTTP date format, or in seconds
        const retryAfterInSeconds = parseInt(retryAfter);
        return isNaN(retryAfterInSeconds)
            ? calculatePollingIntervalFromDate(new Date(retryAfter))
            : retryAfterInSeconds * 1000;
    }
    return undefined;
}
function calculatePollingIntervalFromDate(retryAfterDate) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
        return retryAfterTime - timeNow;
    }
    return undefined;
}
/**
 * Initiates the long-running operation.
 */
async function initHttpOperation(inputs) {
    const { stateProxy, resourceLocationConfig, processResult, lro } = inputs;
    return initOperation({
        init: async () => {
            const response = await lro.sendInitialRequest();
            const config = inferLroMode({
                rawResponse: response.rawResponse,
                requestPath: lro.requestPath,
                requestMethod: lro.requestMethod,
                resourceLocationConfig,
            });
            return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, ((config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {}));
        },
        stateProxy,
        processResult: processResult
            ? ({ flatResponse }, state) => processResult(flatResponse, state)
            : ({ flatResponse }) => flatResponse,
        getOperationStatus: (response, state) => {
            var _a;
            const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
            return mode === undefined ||
                (mode === "Body" && getOperationStatus(response, state) === "succeeded")
                ? "succeeded"
                : "running";
        },
    });
}
function getOperationLocation({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
    switch (mode) {
        case "OperationLocation": {
            return getOperationLocationPollingUrl({
                operationLocation: getOperationLocationHeader(rawResponse),
                azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse),
            });
        }
        case "ResourceLocation": {
            return getLocationHeader(rawResponse);
        }
        case "Body":
        default: {
            return undefined;
        }
    }
}
function getOperationStatus({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
    switch (mode) {
        case "OperationLocation": {
            return getStatus(rawResponse);
        }
        case "ResourceLocation": {
            return toOperationStatus(rawResponse.statusCode);
        }
        case "Body": {
            return getProvisioningState(rawResponse);
        }
        default:
            throw new Error(`Unexpected operation mode: ${mode}`);
    }
}
function getResourceLocation({ flatResponse }, state) {
    if (typeof flatResponse === "object") {
        const resourceLocation = flatResponse.resourceLocation;
        if (resourceLocation !== undefined) {
            state.config.resourceLocation = resourceLocation;
        }
    }
    return state.config.resourceLocation;
}
/** Polls the long-running operation. */
async function pollHttpOperation(inputs) {
    const { lro, stateProxy, options, processResult, updateState, setDelay, state } = inputs;
    return pollOperation({
        state,
        stateProxy,
        setDelay,
        processResult: processResult
            ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState)
            : ({ flatResponse }) => flatResponse,
        updateState,
        getPollingInterval: parseRetryAfter,
        getOperationLocation,
        getOperationStatus,
        getResourceLocation,
        options,
        /**
         * The expansion here is intentional because `lro` could be an object that
         * references an inner this, so we need to preserve a reference to it.
         */
        poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
    });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Map an optional value through a function
 * @internal
 */
const maybemap = (value, f) => value === undefined ? undefined : f(value);
const INTERRUPTED = new Error("The poller is already stopped");
/**
 * A promise that delays resolution until a certain amount of time (in milliseconds) has passed, with facilities for
 * robust cancellation.
 *
 * ### Example:
 *
 * ```javascript
 * let toCancel;
 *
 * // Wait 20 seconds, and optionally allow the function to be cancelled.
 * await delayMs(20000, (cancel) => { toCancel = cancel });
 *
 * // ... if `toCancel` is called before the 20 second timer expires, then the delayMs promise will reject.
 * ```
 *
 * @internal
 * @param ms - the number of milliseconds to wait before resolving
 * @param cb - a callback that can provide the caller with a cancellation function
 */
function delayMs(ms) {
    let aborted = false;
    let toReject;
    return Object.assign(new Promise((resolve, reject) => {
        let token;
        toReject = () => {
            maybemap(token, clearTimeout);
            reject(INTERRUPTED);
        };
        // In the rare case that the operation is _already_ aborted, we will reject instantly. This could happen, for
        // example, if the user calls the cancellation function immediately without yielding execution.
        if (aborted) {
            toReject();
        }
        else {
            token = setTimeout(resolve, ms);
        }
    }), {
        cancel: () => {
            aborted = true;
            toReject === null || toReject === void 0 ? void 0 : toReject();
        },
    });
}

// Copyright (c) Microsoft Corporation.
const createStateProxy$1 = () => ({
    /**
     * The state at this point is created to be of type OperationState<TResult>.
     * It will be updated later to be of type TState when the
     * customer-provided callback, `updateState`, is called during polling.
     */
    initState: (config) => ({ status: "running", config }),
    setCanceled: (state) => (state.status = "canceled"),
    setError: (state, error) => (state.error = error),
    setResult: (state, result) => (state.result = result),
    setRunning: (state) => (state.status = "running"),
    setSucceeded: (state) => (state.status = "succeeded"),
    setFailed: (state) => (state.status = "failed"),
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => state.status === "canceled",
    isFailed: (state) => state.status === "failed",
    isRunning: (state) => state.status === "running",
    isSucceeded: (state) => state.status === "succeeded",
});
/**
 * Returns a poller factory.
 */
function buildCreatePoller(inputs) {
    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, getResourceLocation, getPollingInterval, } = inputs;
    return async ({ init, poll }, options) => {
        const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = POLL_INTERVAL_IN_MS, restoreFrom, } = options || {};
        const stateProxy = createStateProxy$1();
        const withOperationLocation = withOperationLocationCallback
            ? (() => {
                let called = false;
                return (operationLocation, isUpdated) => {
                    if (isUpdated)
                        withOperationLocationCallback(operationLocation);
                    else if (!called)
                        withOperationLocationCallback(operationLocation);
                    called = true;
                };
            })()
            : undefined;
        const state = restoreFrom
            ? deserializeState(restoreFrom)
            : await initOperation({
                init,
                stateProxy,
                processResult,
                getOperationStatus: getStatusFromInitialResponse,
                withOperationLocation,
            });
        let resultPromise;
        let cancelJob;
        const abortController$1 = new abortController.AbortController();
        const handlers = new Map();
        const handleProgressEvents = async () => handlers.forEach((h) => h(state));
        let currentPollIntervalInMs = intervalInMs;
        const poller = {
            getOperationState: () => state,
            getResult: () => state.result,
            isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
            isStopped: () => resultPromise === undefined,
            stopPolling: () => {
                abortController$1.abort();
                cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();
            },
            toString: () => JSON.stringify({
                state,
            }),
            onProgress: (callback) => {
                const s = Symbol();
                handlers.set(s, callback);
                return () => handlers.delete(s);
            },
            pollUntilDone: (pollOptions) => (resultPromise !== null && resultPromise !== void 0 ? resultPromise : (resultPromise = (async () => {
                const { abortSignal: inputAbortSignal } = pollOptions || {};
                const { signal: abortSignal } = inputAbortSignal
                    ? new abortController.AbortController([inputAbortSignal, abortController$1.signal])
                    : abortController$1;
                if (!poller.isDone()) {
                    await poller.poll({ abortSignal });
                    while (!poller.isDone()) {
                        const delay = delayMs(currentPollIntervalInMs);
                        cancelJob = delay.cancel;
                        await delay;
                        await poller.poll({ abortSignal });
                    }
                }
                switch (state.status) {
                    case "succeeded": {
                        return poller.getResult();
                    }
                    case "canceled": {
                        throw new Error("Operation was canceled");
                    }
                    case "failed": {
                        throw state.error;
                    }
                    case "notStarted":
                    case "running": {
                        // Unreachable
                        throw new Error(`polling completed without succeeding or failing`);
                    }
                }
            })().finally(() => {
                resultPromise = undefined;
            }))),
            async poll(pollOptions) {
                await pollOperation({
                    poll,
                    state,
                    stateProxy,
                    getOperationLocation,
                    withOperationLocation,
                    getPollingInterval,
                    getOperationStatus: getStatusFromPollResponse,
                    getResourceLocation,
                    processResult,
                    updateState,
                    options: pollOptions,
                    setDelay: (pollIntervalInMs) => {
                        currentPollIntervalInMs = pollIntervalInMs;
                    },
                });
                await handleProgressEvents();
                if (state.status === "canceled") {
                    throw new Error("Operation was canceled");
                }
                if (state.status === "failed") {
                    throw state.error;
                }
            },
        };
        return poller;
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a poller that can be used to poll a long-running operation.
 * @param lro - Description of the long-running operation
 * @param options - options to configure the poller
 * @returns an initialized poller
 */
async function createHttpPoller(lro, options) {
    const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, } = options || {};
    return buildCreatePoller({
        getStatusFromInitialResponse: (response, state) => {
            var _a;
            const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
            return mode === undefined ||
                (mode === "Body" && getOperationStatus(response, state) === "succeeded")
                ? "succeeded"
                : "running";
        },
        getStatusFromPollResponse: getOperationStatus,
        getOperationLocation,
        getResourceLocation,
        getPollingInterval: parseRetryAfter,
    })({
        init: async () => {
            const response = await lro.sendInitialRequest();
            const config = inferLroMode({
                rawResponse: response.rawResponse,
                requestPath: lro.requestPath,
                requestMethod: lro.requestMethod,
                resourceLocationConfig,
            });
            return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, ((config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {}));
        },
        poll: lro.sendPollRequest,
    }, {
        intervalInMs,
        withOperationLocation,
        restoreFrom,
        updateState,
        processResult: processResult
            ? ({ flatResponse }, state) => processResult(flatResponse, state)
            : ({ flatResponse }) => flatResponse,
    });
}

// Copyright (c) Microsoft Corporation.
const createStateProxy = () => ({
    initState: (config) => ({ config, isStarted: true }),
    setCanceled: (state) => (state.isCancelled = true),
    setError: (state, error) => (state.error = error),
    setResult: (state, result) => (state.result = result),
    setRunning: (state) => (state.isStarted = true),
    setSucceeded: (state) => (state.isCompleted = true),
    setFailed: () => {
        /** empty body */
    },
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => !!state.isCancelled,
    isFailed: (state) => !!state.error,
    isRunning: (state) => !!state.isStarted,
    isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error),
});
class GenericPollOperation {
    constructor(state, lro, lroResourceLocationConfig, processResult, updateState, isDone) {
        this.state = state;
        this.lro = lro;
        this.lroResourceLocationConfig = lroResourceLocationConfig;
        this.processResult = processResult;
        this.updateState = updateState;
        this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
        this.pollerConfig = pollerConfig;
    }
    async update(options) {
        var _a;
        const stateProxy = createStateProxy();
        if (!this.state.isStarted) {
            this.state = Object.assign(Object.assign({}, this.state), (await initHttpOperation({
                lro: this.lro,
                stateProxy,
                resourceLocationConfig: this.lroResourceLocationConfig,
                processResult: this.processResult,
            })));
        }
        const updateState = this.updateState;
        const isDone = this.isDone;
        if (!this.state.isCompleted) {
            await pollHttpOperation({
                lro: this.lro,
                state: this.state,
                stateProxy,
                processResult: this.processResult,
                updateState: updateState
                    ? (state, { rawResponse }) => updateState(state, rawResponse)
                    : undefined,
                isDone: isDone
                    ? ({ flatResponse }, state) => isDone(flatResponse, state)
                    : undefined,
                options,
                setDelay: (intervalInMs) => {
                    this.pollerConfig.intervalInMs = intervalInMs;
                },
            });
        }
        (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options, this.state);
        return this;
    }
    async cancel() {
        logger.error("`cancelOperation` is deprecated because it wasn't implemented");
        return this;
    }
    /**
     * Serializes the Poller operation.
     */
    toString() {
        return JSON.stringify({
            state: this.state,
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * When a poller is manually stopped through the `stopPolling` method,
 * the poller will be rejected with an instance of the PollerStoppedError.
 */
class PollerStoppedError extends Error {
    constructor(message) {
        super(message);
        this.name = "PollerStoppedError";
        Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
}
/**
 * When the operation is cancelled, the poller will be rejected with an instance
 * of the PollerCancelledError.
 */
class PollerCancelledError extends Error {
    constructor(message) {
        super(message);
        this.name = "PollerCancelledError";
        Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
}
/**
 * A class that represents the definition of a program that polls through consecutive requests
 * until it reaches a state of completion.
 *
 * A poller can be executed manually, by polling request by request by calling to the `poll()` method repeatedly, until its operation is completed.
 * It also provides a way to wait until the operation completes, by calling `pollUntilDone()` and waiting until the operation finishes.
 * Pollers can also request the cancellation of the ongoing process to whom is providing the underlying long running operation.
 *
 * ```ts
 * const poller = new MyPoller();
 *
 * // Polling just once:
 * await poller.poll();
 *
 * // We can try to cancel the request here, by calling:
 * //
 * //     await poller.cancelOperation();
 * //
 *
 * // Getting the final result:
 * const result = await poller.pollUntilDone();
 * ```
 *
 * The Poller is defined by two types, a type representing the state of the poller, which
 * must include a basic set of properties from `PollOperationState<TResult>`,
 * and a return type defined by `TResult`, which can be anything.
 *
 * The Poller class implements the `PollerLike` interface, which allows poller implementations to avoid having
 * to export the Poller's class directly, and instead only export the already instantiated poller with the PollerLike type.
 *
 * ```ts
 * class Client {
 *   public async makePoller: PollerLike<MyOperationState, MyResult> {
 *     const poller = new MyPoller({});
 *     // It might be preferred to return the poller after the first request is made,
 *     // so that some information can be obtained right away.
 *     await poller.poll();
 *     return poller;
 *   }
 * }
 *
 * const poller: PollerLike<MyOperationState, MyResult> = myClient.makePoller();
 * ```
 *
 * A poller can be created through its constructor, then it can be polled until it's completed.
 * At any point in time, the state of the poller can be obtained without delay through the getOperationState method.
 * At any point in time, the intermediate forms of the result type can be requested without delay.
 * Once the underlying operation is marked as completed, the poller will stop and the final value will be returned.
 *
 * ```ts
 * const poller = myClient.makePoller();
 * const state: MyOperationState = poller.getOperationState();
 *
 * // The intermediate result can be obtained at any time.
 * const result: MyResult | undefined = poller.getResult();
 *
 * // The final result can only be obtained after the poller finishes.
 * const result: MyResult = await poller.pollUntilDone();
 * ```
 *
 */
// eslint-disable-next-line no-use-before-define
class Poller {
    /**
     * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
     *
     * When writing an implementation of a Poller, this implementation needs to deal with the initialization
     * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
     * operation has already been defined, at least its basic properties. The code below shows how to approach
     * the definition of the constructor of a new custom poller.
     *
     * ```ts
     * export class MyPoller extends Poller<MyOperationState, string> {
     *   constructor({
     *     // Anything you might need outside of the basics
     *   }) {
     *     let state: MyOperationState = {
     *       privateProperty: private,
     *       publicProperty: public,
     *     };
     *
     *     const operation = {
     *       state,
     *       update,
     *       cancel,
     *       toString
     *     }
     *
     *     // Sending the operation to the parent's constructor.
     *     super(operation);
     *
     *     // You can assign more local properties here.
     *   }
     * }
     * ```
     *
     * Inside of this constructor, a new promise is created. This will be used to
     * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
     * resolve and reject methods are also used internally to control when to resolve
     * or reject anyone waiting for the poller to finish.
     *
     * The constructor of a custom implementation of a poller is where any serialized version of
     * a previous poller's operation should be deserialized into the operation sent to the
     * base constructor. For example:
     *
     * ```ts
     * export class MyPoller extends Poller<MyOperationState, string> {
     *   constructor(
     *     baseOperation: string | undefined
     *   ) {
     *     let state: MyOperationState = {};
     *     if (baseOperation) {
     *       state = {
     *         ...JSON.parse(baseOperation).state,
     *         ...state
     *       };
     *     }
     *     const operation = {
     *       state,
     *       // ...
     *     }
     *     super(operation);
     *   }
     * }
     * ```
     *
     * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
     */
    constructor(operation) {
        this.stopped = true;
        this.pollProgressCallbacks = [];
        this.operation = operation;
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
        // This prevents the UnhandledPromiseRejectionWarning in node.js from being thrown.
        // The above warning would get thrown if `poller.poll` is called, it returns an error,
        // and pullUntilDone did not have a .catch or await try/catch on it's return value.
        this.promise.catch(() => {
            /* intentionally blank */
        });
    }
    /**
     * Starts a loop that will break only if the poller is done
     * or if the poller is stopped.
     */
    async startPolling(pollOptions = {}) {
        if (this.stopped) {
            this.stopped = false;
        }
        while (!this.isStopped() && !this.isDone()) {
            await this.poll(pollOptions);
            await this.delay();
        }
    }
    /**
     * pollOnce does one polling, by calling to the update method of the underlying
     * poll operation to make any relevant change effective.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    async pollOnce(options = {}) {
        if (!this.isDone()) {
            try {
                this.operation = await this.operation.update({
                    abortSignal: options.abortSignal,
                    fireProgress: this.fireProgress.bind(this),
                });
            }
            catch (e) {
                this.operation.state.error = e;
            }
        }
        this.processUpdatedState();
    }
    /**
     * fireProgress calls the functions passed in via onProgress the method of the poller.
     *
     * It loops over all of the callbacks received from onProgress, and executes them, sending them
     * the current operation state.
     *
     * @param state - The current operation state.
     */
    fireProgress(state) {
        for (const callback of this.pollProgressCallbacks) {
            callback(state);
        }
    }
    /**
     * Invokes the underlying operation's cancel method.
     */
    async cancelOnce(options = {}) {
        this.operation = await this.operation.cancel(options);
    }
    /**
     * Returns a promise that will resolve once a single polling request finishes.
     * It does this by calling the update method of the Poller's operation.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    poll(options = {}) {
        if (!this.pollOncePromise) {
            this.pollOncePromise = this.pollOnce(options);
            const clearPollOncePromise = () => {
                this.pollOncePromise = undefined;
            };
            this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
        }
        return this.pollOncePromise;
    }
    processUpdatedState() {
        if (this.operation.state.error) {
            this.stopped = true;
            this.reject(this.operation.state.error);
            throw this.operation.state.error;
        }
        if (this.operation.state.isCancelled) {
            this.stopped = true;
            const error = new PollerCancelledError("Operation was canceled");
            this.reject(error);
            throw error;
        }
        else if (this.isDone() && this.resolve) {
            // If the poller has finished polling, this means we now have a result.
            // However, it can be the case that TResult is instantiated to void, so
            // we are not expecting a result anyway. To assert that we might not
            // have a result eventually after finishing polling, we cast the result
            // to TResult.
            this.resolve(this.operation.state.result);
        }
    }
    /**
     * Returns a promise that will resolve once the underlying operation is completed.
     */
    async pollUntilDone(pollOptions = {}) {
        if (this.stopped) {
            this.startPolling(pollOptions).catch(this.reject);
        }
        // This is needed because the state could have been updated by
        // `cancelOperation`, e.g. the operation is canceled or an error occurred.
        this.processUpdatedState();
        return this.promise;
    }
    /**
     * Invokes the provided callback after each polling is completed,
     * sending the current state of the poller's operation.
     *
     * It returns a method that can be used to stop receiving updates on the given callback function.
     */
    onProgress(callback) {
        this.pollProgressCallbacks.push(callback);
        return () => {
            this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
        };
    }
    /**
     * Returns true if the poller has finished polling.
     */
    isDone() {
        const state = this.operation.state;
        return Boolean(state.isCompleted || state.isCancelled || state.error);
    }
    /**
     * Stops the poller from continuing to poll.
     */
    stopPolling() {
        if (!this.stopped) {
            this.stopped = true;
            if (this.reject) {
                this.reject(new PollerStoppedError("This poller is already stopped"));
            }
        }
    }
    /**
     * Returns true if the poller is stopped.
     */
    isStopped() {
        return this.stopped;
    }
    /**
     * Attempts to cancel the underlying operation.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * If it's called again before it finishes, it will throw an error.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    cancelOperation(options = {}) {
        if (!this.cancelPromise) {
            this.cancelPromise = this.cancelOnce(options);
        }
        else if (options.abortSignal) {
            throw new Error("A cancel request is currently pending");
        }
        return this.cancelPromise;
    }
    /**
     * Returns the state of the operation.
     *
     * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
     * implementations of the pollers can customize what's shared with the public by writing their own
     * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
     * and a public type representing a safe to share subset of the properties of the internal state.
     * Their definition of getOperationState can then return their public type.
     *
     * Example:
     *
     * ```ts
     * // Let's say we have our poller's operation state defined as:
     * interface MyOperationState extends PollOperationState<ResultType> {
     *   privateProperty?: string;
     *   publicProperty?: string;
     * }
     *
     * // To allow us to have a true separation of public and private state, we have to define another interface:
     * interface PublicState extends PollOperationState<ResultType> {
     *   publicProperty?: string;
     * }
     *
     * // Then, we define our Poller as follows:
     * export class MyPoller extends Poller<MyOperationState, ResultType> {
     *   // ... More content is needed here ...
     *
     *   public getOperationState(): PublicState {
     *     const state: PublicState = this.operation.state;
     *     return {
     *       // Properties from PollOperationState<TResult>
     *       isStarted: state.isStarted,
     *       isCompleted: state.isCompleted,
     *       isCancelled: state.isCancelled,
     *       error: state.error,
     *       result: state.result,
     *
     *       // The only other property needed by PublicState.
     *       publicProperty: state.publicProperty
     *     }
     *   }
     * }
     * ```
     *
     * You can see this in the tests of this repository, go to the file:
     * `../test/utils/testPoller.ts`
     * and look for the getOperationState implementation.
     */
    getOperationState() {
        return this.operation.state;
    }
    /**
     * Returns the result value of the operation,
     * regardless of the state of the poller.
     * It can return undefined or an incomplete form of the final TResult value
     * depending on the implementation.
     */
    getResult() {
        const state = this.operation.state;
        return state.result;
    }
    /**
     * Returns a serialized version of the poller's operation
     * by invoking the operation's toString method.
     */
    toString() {
        return this.operation.toString();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The LRO Engine, a class that performs polling.
 */
class LroEngine extends Poller {
    constructor(lro, options) {
        const { intervalInMs = POLL_INTERVAL_IN_MS, resumeFrom } = options || {};
        const state = resumeFrom
            ? deserializeState(resumeFrom)
            : {};
        const operation = new GenericPollOperation(state, lro, options === null || options === void 0 ? void 0 : options.lroResourceLocationConfig, options === null || options === void 0 ? void 0 : options.processResult, options === null || options === void 0 ? void 0 : options.updateState, options === null || options === void 0 ? void 0 : options.isDone);
        super(operation);
        this.config = { intervalInMs: intervalInMs };
        operation.setPollerConfig(this.config);
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    delay() {
        return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
    }
}

exports.LroEngine = LroEngine;
exports.Poller = Poller;
exports.PollerCancelledError = PollerCancelledError;
exports.PollerStoppedError = PollerStoppedError;
exports.createHttpPoller = createHttpPoller;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 6938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var logger$1 = __nccwpck_require__(803);
var coreUtil = __nccwpck_require__(9113);
var os = __nccwpck_require__(2037);
var abortController = __nccwpck_require__(1925);
var FormData = __nccwpck_require__(489);
var httpsProxyAgent = __nccwpck_require__(5557);
var httpProxyAgent = __nccwpck_require__(9242);
var coreTracing = __nccwpck_require__(7439);
var util = __nccwpck_require__(3837);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var zlib = __nccwpck_require__(9796);
var stream = __nccwpck_require__(2781);
var uuid = __nccwpck_require__(5650);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var os__namespace = /*#__PURE__*/_interopNamespace(os);
var FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData);
var http__namespace = /*#__PURE__*/_interopNamespace(http);
var https__namespace = /*#__PURE__*/_interopNamespace(https);
var zlib__namespace = /*#__PURE__*/_interopNamespace(zlib);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
/**
 * A private implementation of Pipeline.
 * Do not export this class from the package.
 * @internal
 */
class HttpPipeline {
    constructor(policies = []) {
        this._policies = [];
        this._policies = policies;
        this._orderedPolicies = undefined;
    }
    addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
            throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
            throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
            throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
            policy,
            options,
        });
        this._orderedPolicies = undefined;
    }
    removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
            if ((options.name && policyDescriptor.policy.name === options.name) ||
                (options.phase && policyDescriptor.options.phase === options.phase)) {
                removedPolicies.push(policyDescriptor.policy);
                return false;
            }
            else {
                return true;
            }
        });
        this._orderedPolicies = undefined;
        return removedPolicies;
    }
    sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
            return (req) => {
                return policy.sendRequest(req, next);
            };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
    }
    getOrderedPolicies() {
        if (!this._orderedPolicies) {
            this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
    }
    clone() {
        return new HttpPipeline(this._policies);
    }
    static create() {
        return new HttpPipeline();
    }
    orderPolicies() {
        /**
         * The goal of this method is to reliably order pipeline policies
         * based on their declared requirements when they were added.
         *
         * Order is first determined by phase:
         *
         * 1. Serialize Phase
         * 2. Policies not in a phase
         * 3. Deserialize Phase
         * 4. Retry Phase
         * 5. Sign Phase
         *
         * Within each phase, policies are executed in the order
         * they were added unless they were specified to execute
         * before/after other policies or after a particular phase.
         *
         * To determine the final order, we will walk the policy list
         * in phase order multiple times until all dependencies are
         * satisfied.
         *
         * `afterPolicies` are the set of policies that must be
         * executed before a given policy. This requirement is
         * considered satisfied when each of the listed policies
         * have been scheduled.
         *
         * `beforePolicies` are the set of policies that must be
         * executed after a given policy. Since this dependency
         * can be expressed by converting it into a equivalent
         * `afterPolicies` declarations, they are normalized
         * into that form for simplicity.
         *
         * An `afterPhase` dependency is considered satisfied when all
         * policies in that phase have scheduled.
         *
         */
        const result = [];
        // Track all policies we know about.
        const policyMap = new Map();
        function createPhase(name) {
            return {
                name,
                policies: new Set(),
                hasRun: false,
                hasAfterPolicies: false,
            };
        }
        // Track policies for each phase.
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        // a list of phases in order
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        // Small helper function to map phase name to each Phase
        function getPhase(phase) {
            if (phase === "Retry") {
                return retryPhase;
            }
            else if (phase === "Serialize") {
                return serializePhase;
            }
            else if (phase === "Deserialize") {
                return deserializePhase;
            }
            else if (phase === "Sign") {
                return signPhase;
            }
            else {
                return noPhase;
            }
        }
        // First walk each policy and create a node to track metadata.
        for (const descriptor of this._policies) {
            const policy = descriptor.policy;
            const options = descriptor.options;
            const policyName = policy.name;
            if (policyMap.has(policyName)) {
                throw new Error("Duplicate policy names not allowed in pipeline");
            }
            const node = {
                policy,
                dependsOn: new Set(),
                dependants: new Set(),
            };
            if (options.afterPhase) {
                node.afterPhase = getPhase(options.afterPhase);
                node.afterPhase.hasAfterPolicies = true;
            }
            policyMap.set(policyName, node);
            const phase = getPhase(options.phase);
            phase.policies.add(node);
        }
        // Now that each policy has a node, connect dependency references.
        for (const descriptor of this._policies) {
            const { policy, options } = descriptor;
            const policyName = policy.name;
            const node = policyMap.get(policyName);
            if (!node) {
                throw new Error(`Missing node for policy ${policyName}`);
            }
            if (options.afterPolicies) {
                for (const afterPolicyName of options.afterPolicies) {
                    const afterNode = policyMap.get(afterPolicyName);
                    if (afterNode) {
                        // Linking in both directions helps later
                        // when we want to notify dependants.
                        node.dependsOn.add(afterNode);
                        afterNode.dependants.add(node);
                    }
                }
            }
            if (options.beforePolicies) {
                for (const beforePolicyName of options.beforePolicies) {
                    const beforeNode = policyMap.get(beforePolicyName);
                    if (beforeNode) {
                        // To execute before another node, make it
                        // depend on the current node.
                        beforeNode.dependsOn.add(node);
                        node.dependants.add(beforeNode);
                    }
                }
            }
        }
        function walkPhase(phase) {
            phase.hasRun = true;
            // Sets iterate in insertion order
            for (const node of phase.policies) {
                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
                    // If this node is waiting on a phase to complete,
                    // we need to skip it for now.
                    // Even if the phase is empty, we should wait for it
                    // to be walked to avoid re-ordering policies.
                    continue;
                }
                if (node.dependsOn.size === 0) {
                    // If there's nothing else we're waiting for, we can
                    // add this policy to the result list.
                    result.push(node.policy);
                    // Notify anything that depends on this policy that
                    // the policy has been scheduled.
                    for (const dependant of node.dependants) {
                        dependant.dependsOn.delete(node);
                    }
                    policyMap.delete(node.policy.name);
                    phase.policies.delete(node);
                }
            }
        }
        function walkPhases() {
            for (const phase of orderedPhases) {
                walkPhase(phase);
                // if the phase isn't complete
                if (phase.policies.size > 0 && phase !== noPhase) {
                    if (!noPhase.hasRun) {
                        // Try running noPhase to see if that unblocks this phase next tick.
                        // This can happen if a phase that happens before noPhase
                        // is waiting on a noPhase policy to complete.
                        walkPhase(noPhase);
                    }
                    // Don't proceed to the next phase until this phase finishes.
                    return;
                }
                if (phase.hasAfterPolicies) {
                    // Run any policies unblocked by this phase
                    walkPhase(noPhase);
                }
            }
        }
        // Iterate until we've put every node in the result list.
        let iteration = 0;
        while (policyMap.size > 0) {
            iteration++;
            const initialResultLength = result.length;
            // Keep walking each phase in order until we can order every node.
            walkPhases();
            // The result list *should* get at least one larger each time
            // after the first full pass.
            // Otherwise, we're going to loop forever.
            if (result.length <= initialResultLength && iteration > 1) {
                throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
            }
        }
        return result;
    }
}
/**
 * Creates a totally empty pipeline.
 * Useful for testing or creating a custom one.
 */
function createEmptyPipeline() {
    return HttpPipeline.create();
}

// Copyright (c) Microsoft Corporation.
const logger = logger$1.createClientLogger("core-rest-pipeline");

// Copyright (c) Microsoft Corporation.
const RedactedString = "REDACTED";
// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
const defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate",
];
const defaultAllowedQueryParameters = ["api-version"];
/**
 * @internal
 */
class Sanitizer {
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [], } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    sanitize(obj) {
        const seen = new Set();
        return JSON.stringify(obj, (key, value) => {
            // Ensure Errors include their interesting non-enumerable members
            if (value instanceof Error) {
                return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
            }
            if (key === "headers") {
                return this.sanitizeHeaders(value);
            }
            else if (key === "url") {
                return this.sanitizeUrl(value);
            }
            else if (key === "query") {
                return this.sanitizeQuery(value);
            }
            else if (key === "body") {
                // Don't log the request body
                return undefined;
            }
            else if (key === "response") {
                // Don't log response again
                return undefined;
            }
            else if (key === "operationSpec") {
                // When using sendOperationRequest, the request carries a massive
                // field with the autorest spec. No need to log it.
                return undefined;
            }
            else if (Array.isArray(value) || coreUtil.isObject(value)) {
                if (seen.has(value)) {
                    return "[Circular]";
                }
                seen.add(value);
            }
            return value;
        }, 2);
    }
    sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
            if (this.allowedHeaderNames.has(key.toLowerCase())) {
                sanitized[key] = obj[key];
            }
            else {
                sanitized[key] = RedactedString;
            }
        }
        return sanitized;
    }
    sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
            return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
            if (this.allowedQueryParameters.has(k.toLowerCase())) {
                sanitized[k] = value[k];
            }
            else {
                sanitized[k] = RedactedString;
            }
        }
        return sanitized;
    }
    sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
            return value;
        }
        const url = new URL(value);
        if (!url.search) {
            return value;
        }
        for (const [key] of url.searchParams) {
            if (!this.allowedQueryParameters.has(key.toLowerCase())) {
                url.searchParams.set(key, RedactedString);
            }
        }
        return url.toString();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the logPolicy.
 */
const logPolicyName = "logPolicy";
/**
 * A policy that logs all requests and responses.
 * @param options - Options to configure logPolicy.
 */
function logPolicy(options = {}) {
    var _a;
    const logger$1 = (_a = options.logger) !== null && _a !== void 0 ? _a : logger.info;
    const sanitizer = new Sanitizer({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
    });
    return {
        name: logPolicyName,
        async sendRequest(request, next) {
            if (!logger$1.enabled) {
                return next(request);
            }
            logger$1(`Request: ${sanitizer.sanitize(request)}`);
            const response = await next(request);
            logger$1(`Response status code: ${response.status}`);
            logger$1(`Headers: ${sanitizer.sanitize(response.headers)}`);
            return response;
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the redirectPolicy.
 */
const redirectPolicyName = "redirectPolicy";
/**
 * Methods that are allowed to follow redirects 301 and 302
 */
const allowedRedirect = ["GET", "HEAD"];
/**
 * A policy to follow Location headers from the server in order
 * to support server-side redirection.
 * In the browser, this policy is not used.
 * @param options - Options to control policy behavior.
 */
function redirectPolicy(options = {}) {
    const { maxRetries = 20 } = options;
    return {
        name: redirectPolicyName,
        async sendRequest(request, next) {
            const response = await next(request);
            return handleRedirect(next, response, maxRetries);
        },
    };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const { request, status, headers } = response;
    const locationHeader = headers.get("location");
    if (locationHeader &&
        (status === 300 ||
            (status === 301 && allowedRedirect.includes(request.method)) ||
            (status === 302 && allowedRedirect.includes(request.method)) ||
            (status === 303 && request.method === "POST") ||
            status === 307) &&
        currentRetries < maxRetries) {
        const url = new URL(locationHeader, request.url);
        request.url = url.toString();
        // POST request with Status code 303 should be converted into a
        // redirected GET request if the redirect url is present in the location header
        if (status === 303) {
            request.method = "GET";
            request.headers.delete("Content-Length");
            delete request.body;
        }
        request.headers.delete("Authorization");
        const res = await next(request);
        return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function getHeaderName() {
    return "User-Agent";
}
/**
 * @internal
 */
function setPlatformSpecificData(map) {
    map.set("Node", process.version);
    map.set("OS", `(${os__namespace.arch()}-${os__namespace.type()}-${os__namespace.release()})`);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.9.2";
const DEFAULT_RETRY_POLICY_COUNT = 3;

// Copyright (c) Microsoft Corporation.
function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
    }
    return parts.join(" ");
}
/**
 * @internal
 */
function getUserAgentHeaderName() {
    return getHeaderName();
}
/**
 * @internal
 */
function getUserAgentValue(prefix) {
    const runtimeInfo = new Map();
    runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
    setPlatformSpecificData(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
}

// Copyright (c) Microsoft Corporation.
const UserAgentHeaderName = getUserAgentHeaderName();
/**
 * The programmatic identifier of the userAgentPolicy.
 */
const userAgentPolicyName = "userAgentPolicy";
/**
 * A policy that sets the User-Agent header (or equivalent) to reflect
 * the library version.
 * @param options - Options to customize the user agent value.
 */
function userAgentPolicy(options = {}) {
    const userAgentValue = getUserAgentValue(options.userAgentPrefix);
    return {
        name: userAgentPolicyName,
        async sendRequest(request, next) {
            if (!request.headers.has(UserAgentHeaderName)) {
                request.headers.set(UserAgentHeaderName, userAgentValue);
            }
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the decompressResponsePolicy.
 */
const decompressResponsePolicyName = "decompressResponsePolicy";
/**
 * A policy to enable response decompression according to Accept-Encoding header
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
 */
function decompressResponsePolicy() {
    return {
        name: decompressResponsePolicyName,
        async sendRequest(request, next) {
            // HEAD requests have no body
            if (request.method !== "HEAD") {
                request.headers.set("Accept-Encoding", "gzip,deflate");
            }
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
const StandardAbortMessage = "The operation was aborted.";
/**
 * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
 * @param delayInMs - The number of milliseconds to be delayed.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @param options - The options for delay - currently abort options
 *                  - abortSignal - The abortSignal associated with containing operation.
 *                  - abortErrorMsg - The abort error message associated with containing operation.
 * @returns Resolved promise
 */
function delay(delayInMs, value, options) {
    return new Promise((resolve, reject) => {
        let timer = undefined;
        let onAborted = undefined;
        const rejectOnAbort = () => {
            return reject(new abortController.AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
        };
        const removeListeners = () => {
            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
                options.abortSignal.removeEventListener("abort", onAborted);
            }
        };
        onAborted = () => {
            if (timer) {
                clearTimeout(timer);
            }
            removeListeners();
            return rejectOnAbort();
        };
        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
            return rejectOnAbort();
        }
        timer = setTimeout(() => {
            removeListeners();
            resolve(value);
        }, delayInMs);
        if (options === null || options === void 0 ? void 0 : options.abortSignal) {
            options.abortSignal.addEventListener("abort", onAborted);
        }
    });
}
/**
 * @internal
 * @returns the parsed value or undefined if the parsed value is invalid.
 */
function parseHeaderValueAsNumber(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value)
        return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
        return;
    return valueAsNum;
}

// Copyright (c) Microsoft Corporation.
/**
 * The header that comes back from Azure services representing
 * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
 */
const RetryAfterHeader = "Retry-After";
/**
 * The headers that come back from Azure services representing
 * the amount of time (minimum) to wait to retry.
 *
 * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
 * "Retry-After" : seconds or timestamp
 */
const AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
/**
 * A response is a throttling retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 *
 * Returns the `retryAfterInMs` value if the response is a throttling retry response.
 * If not throttling retry response, returns `undefined`.
 *
 * @internal
 */
function getRetryAfterInMs(response) {
    if (!(response && [429, 503].includes(response.status)))
        return undefined;
    try {
        // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
        for (const header of AllRetryAfterHeaders) {
            const retryAfterValue = parseHeaderValueAsNumber(response, header);
            if (retryAfterValue === 0 || retryAfterValue) {
                // "Retry-After" header ==> seconds
                // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
                const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
                return retryAfterValue * multiplyingFactor; // in milli-seconds
            }
        }
        // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
        const retryAfterHeader = response.headers.get(RetryAfterHeader);
        if (!retryAfterHeader)
            return;
        const date = Date.parse(retryAfterHeader);
        const diff = date - Date.now();
        // negative diff would mean a date in the past, so retry asap with 0 milliseconds
        return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    }
    catch (e) {
        return undefined;
    }
}
/**
 * A response is a retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 */
function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
    return {
        name: "throttlingRetryStrategy",
        retry({ response }) {
            const retryAfterInMs = getRetryAfterInMs(response);
            if (!Number.isFinite(retryAfterInMs)) {
                return { skipStrategy: true };
            }
            return {
                retryAfterInMs,
            };
        },
    };
}

// Copyright (c) Microsoft Corporation.
// intervals are in milliseconds
const DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
/**
 * A retry strategy that retries with an exponentially increasing delay in these two cases:
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).
 */
function exponentialRetryStrategy(options = {}) {
    var _a, _b;
    const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    let retryAfterInMs = retryInterval;
    return {
        name: "exponentialRetryStrategy",
        retry({ retryCount, response, responseError }) {
            const matchedSystemError = isSystemError(responseError);
            const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
            const isExponential = isExponentialRetryResponse(response);
            const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
            const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
            if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
                return { skipStrategy: true };
            }
            if (responseError && !matchedSystemError && !isExponential) {
                return { errorToThrow: responseError };
            }
            // Exponentially increase the delay each time
            const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
            // Don't let the delay exceed the maximum
            const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
            // Allow the final value to have some "jitter" (within 50% of the delay size) so
            // that retries across multiple clients don't occur simultaneously.
            retryAfterInMs =
                clampedExponentialDelay / 2 + coreUtil.getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
            return { retryAfterInMs };
        },
    };
}
/**
 * A response is a retry response if it has status codes:
 * - 408, or
 * - Greater or equal than 500, except for 501 and 505.
 */
function isExponentialRetryResponse(response) {
    return Boolean(response &&
        response.status !== undefined &&
        (response.status >= 500 || response.status === 408) &&
        response.status !== 501 &&
        response.status !== 505);
}
/**
 * Determines whether an error from a pipeline response was triggered in the network layer.
 */
function isSystemError(err) {
    if (!err) {
        return false;
    }
    return (err.code === "ETIMEDOUT" ||
        err.code === "ESOCKETTIMEDOUT" ||
        err.code === "ECONNREFUSED" ||
        err.code === "ECONNRESET" ||
        err.code === "ENOENT");
}

// Copyright (c) Microsoft Corporation.
const retryPolicyLogger = logger$1.createClientLogger("core-rest-pipeline retryPolicy");
/**
 * The programmatic identifier of the retryPolicy.
 */
const retryPolicyName = "retryPolicy";
/**
 * retryPolicy is a generic policy to enable retrying requests when certain conditions are met
 */
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
    const logger = options.logger || retryPolicyLogger;
    return {
        name: retryPolicyName,
        async sendRequest(request, next) {
            var _a, _b;
            let response;
            let responseError;
            let retryCount = -1;
            // eslint-disable-next-line no-constant-condition
            retryRequest: while (true) {
                retryCount += 1;
                response = undefined;
                responseError = undefined;
                try {
                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
                    response = await next(request);
                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
                }
                catch (e) {
                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
                    // RestErrors are valid targets for the retry strategies.
                    // If none of the retry strategies can work with them, they will be thrown later in this policy.
                    // If the received error is not a RestError, it is immediately thrown.
                    responseError = e;
                    if (!e || responseError.name !== "RestError") {
                        throw e;
                    }
                    response = responseError.response;
                }
                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    logger.error(`Retry ${retryCount}: Request aborted.`);
                    const abortError = new abortController.AbortError();
                    throw abortError;
                }
                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
                    if (responseError) {
                        throw responseError;
                    }
                    else if (response) {
                        return response;
                    }
                    else {
                        throw new Error("Maximum retries reached with no response or error to throw");
                    }
                }
                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
                strategiesLoop: for (const strategy of strategies) {
                    const strategyLogger = strategy.logger || retryPolicyLogger;
                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                    const modifiers = strategy.retry({
                        retryCount,
                        response,
                        responseError,
                    });
                    if (modifiers.skipStrategy) {
                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                        continue strategiesLoop;
                    }
                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                    if (errorToThrow) {
                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                        throw errorToThrow;
                    }
                    if (retryAfterInMs || retryAfterInMs === 0) {
                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                        await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
                        continue retryRequest;
                    }
                    if (redirectTo) {
                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                        request.url = redirectTo;
                        continue retryRequest;
                    }
                }
                if (responseError) {
                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
                    throw responseError;
                }
                if (response) {
                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);
                    return response;
                }
                // If all the retries skip and there's no response,
                // we're still in the retry loop, so a new request will be sent
                // until `maxRetries` is reached.
            }
        },
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Name of the {@link defaultRetryPolicy}
 */
const defaultRetryPolicyName = "defaultRetryPolicy";
/**
 * A policy that retries according to three strategies:
 * - When the server sends a 429 response with a Retry-After header.
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
 */
function defaultRetryPolicy(options = {}) {
    var _a;
    return {
        name: defaultRetryPolicyName,
        sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,
        }).sendRequest,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the formDataPolicy.
 */
const formDataPolicyName = "formDataPolicy";
/**
 * A policy that encodes FormData on the request into the body.
 */
function formDataPolicy() {
    return {
        name: formDataPolicyName,
        async sendRequest(request, next) {
            if (request.formData) {
                const contentType = request.headers.get("Content-Type");
                if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
                    request.body = wwwFormUrlEncode(request.formData);
                    request.formData = undefined;
                }
                else {
                    prepareFormData(request.formData, request);
                }
            }
            return next(request);
        },
    };
}
function wwwFormUrlEncode(formData) {
    const urlSearchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(formData)) {
        if (Array.isArray(value)) {
            for (const subValue of value) {
                urlSearchParams.append(key, subValue.toString());
            }
        }
        else {
            urlSearchParams.append(key, value.toString());
        }
    }
    return urlSearchParams.toString();
}
async function prepareFormData(formData, request) {
    const requestForm = new FormData__default["default"]();
    for (const formKey of Object.keys(formData)) {
        const formValue = formData[formKey];
        if (Array.isArray(formValue)) {
            for (const subValue of formValue) {
                requestForm.append(formKey, subValue);
            }
        }
        else {
            requestForm.append(formKey, formValue);
        }
    }
    request.body = requestForm;
    request.formData = undefined;
    const contentType = request.headers.get("Content-Type");
    if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
        request.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
    }
    try {
        const contentLength = await new Promise((resolve, reject) => {
            requestForm.getLength((err, length) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(length);
                }
            });
        });
        request.headers.set("Content-Length", contentLength);
    }
    catch (e) {
        // ignore setting the length if this fails
    }
}

// Copyright (c) Microsoft Corporation.
const HTTPS_PROXY = "HTTPS_PROXY";
const HTTP_PROXY = "HTTP_PROXY";
const ALL_PROXY = "ALL_PROXY";
const NO_PROXY = "NO_PROXY";
/**
 * The programmatic identifier of the proxyPolicy.
 */
const proxyPolicyName = "proxyPolicy";
/**
 * Stores the patterns specified in NO_PROXY environment variable.
 * @internal
 */
const globalNoProxyList = [];
let noProxyListLoaded = false;
/** A cache of whether a host should bypass the proxy. */
const globalBypassedMap = new Map();
function getEnvironmentValue(name) {
    if (process.env[name]) {
        return process.env[name];
    }
    else if (process.env[name.toLowerCase()]) {
        return process.env[name.toLowerCase()];
    }
    return undefined;
}
function loadEnvironmentProxyValue() {
    if (!process) {
        return undefined;
    }
    const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
    const allProxy = getEnvironmentValue(ALL_PROXY);
    const httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
}
/**
 * Check whether the host of a given `uri` matches any pattern in the no proxy list.
 * If there's a match, any request sent to the same host shouldn't have the proxy settings set.
 * This implementation is a port of https://github.com/Azure/azure-sdk-for-net/blob/8cca811371159e527159c7eb65602477898683e2/sdk/core/Azure.Core/src/Pipeline/Internal/HttpEnvironmentProxy.cs#L210
 */
function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) {
        return false;
    }
    const host = new URL(uri).hostname;
    if (bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.has(host)) {
        return bypassedMap.get(host);
    }
    let isBypassedFlag = false;
    for (const pattern of noProxyList) {
        if (pattern[0] === ".") {
            // This should match either domain it self or any subdomain or host
            // .foo.com will match foo.com it self or *.foo.com
            if (host.endsWith(pattern)) {
                isBypassedFlag = true;
            }
            else {
                if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
                    isBypassedFlag = true;
                }
            }
        }
        else {
            if (host === pattern) {
                isBypassedFlag = true;
            }
        }
    }
    bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.set(host, isBypassedFlag);
    return isBypassedFlag;
}
function loadNoProxy() {
    const noProxy = getEnvironmentValue(NO_PROXY);
    noProxyListLoaded = true;
    if (noProxy) {
        return noProxy
            .split(",")
            .map((item) => item.trim())
            .filter((item) => item.length);
    }
    return [];
}
/**
 * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.
 * If no argument is given, it attempts to parse a proxy URL from the environment
 * variables `HTTPS_PROXY` or `HTTP_PROXY`.
 * @param proxyUrl - The url of the proxy to use. May contain authentication information.
 */
function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl) {
        proxyUrl = loadEnvironmentProxyValue();
        if (!proxyUrl) {
            return undefined;
        }
    }
    const parsedUrl = new URL(proxyUrl);
    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
    return {
        host: schema + parsedUrl.hostname,
        port: Number.parseInt(parsedUrl.port || "80"),
        username: parsedUrl.username,
        password: parsedUrl.password,
    };
}
/**
 * @internal
 */
function getProxyAgentOptions(proxySettings, { headers, tlsSettings }) {
    let parsedProxyUrl;
    try {
        parsedProxyUrl = new URL(proxySettings.host);
    }
    catch (_error) {
        throw new Error(`Expecting a valid host string in proxy settings, but found "${proxySettings.host}".`);
    }
    if (tlsSettings) {
        logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    }
    const proxyAgentOptions = {
        hostname: parsedProxyUrl.hostname,
        port: proxySettings.port,
        protocol: parsedProxyUrl.protocol,
        headers: headers.toJSON(),
    };
    if (proxySettings.username && proxySettings.password) {
        proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}`;
    }
    else if (proxySettings.username) {
        proxyAgentOptions.auth = `${proxySettings.username}`;
    }
    return proxyAgentOptions;
}
function setProxyAgentOnRequest(request, cachedAgents) {
    // Custom Agent should take precedence so if one is present
    // we should skip to avoid overwriting it.
    if (request.agent) {
        return;
    }
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    const proxySettings = request.proxySettings;
    if (proxySettings) {
        if (isInsecure) {
            if (!cachedAgents.httpProxyAgent) {
                const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
                cachedAgents.httpProxyAgent = new httpProxyAgent.HttpProxyAgent(proxyAgentOptions);
            }
            request.agent = cachedAgents.httpProxyAgent;
        }
        else {
            if (!cachedAgents.httpsProxyAgent) {
                const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
                cachedAgents.httpsProxyAgent = new httpsProxyAgent.HttpsProxyAgent(proxyAgentOptions);
            }
            request.agent = cachedAgents.httpsProxyAgent;
        }
    }
}
/**
 * A policy that allows one to apply proxy settings to all requests.
 * If not passed static settings, they will be retrieved from the HTTPS_PROXY
 * or HTTP_PROXY environment variables.
 * @param proxySettings - ProxySettings to use on each request.
 * @param options - additional settings, for example, custom NO_PROXY patterns
 */
function proxyPolicy(proxySettings = getDefaultProxySettings(), options) {
    if (!noProxyListLoaded) {
        globalNoProxyList.push(...loadNoProxy());
    }
    const cachedAgents = {};
    return {
        name: proxyPolicyName,
        async sendRequest(request, next) {
            var _a;
            if (!request.proxySettings &&
                !isBypassed(request.url, (_a = options === null || options === void 0 ? void 0 : options.customNoProxyList) !== null && _a !== void 0 ? _a : globalNoProxyList, (options === null || options === void 0 ? void 0 : options.customNoProxyList) ? undefined : globalBypassedMap)) {
                request.proxySettings = proxySettings;
            }
            if (request.proxySettings) {
                setProxyAgentOnRequest(request, cachedAgents);
            }
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the setClientRequestIdPolicy.
 */
const setClientRequestIdPolicyName = "setClientRequestIdPolicy";
/**
 * Each PipelineRequest gets a unique id upon creation.
 * This policy passes that unique id along via an HTTP header to enable better
 * telemetry and tracing.
 * @param requestIdHeaderName - The name of the header to pass the request ID to.
 */
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
        name: setClientRequestIdPolicyName,
        async sendRequest(request, next) {
            if (!request.headers.has(requestIdHeaderName)) {
                request.headers.set(requestIdHeaderName, request.requestId);
            }
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Name of the TLS Policy
 */
const tlsPolicyName = "tlsPolicy";
/**
 * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
 */
function tlsPolicy(tlsSettings) {
    return {
        name: tlsPolicyName,
        sendRequest: async (req, next) => {
            // Users may define a request tlsSettings, honor those over the client level one
            if (!req.tlsSettings) {
                req.tlsSettings = tlsSettings;
            }
            return next(req);
        },
    };
}

// Copyright (c) Microsoft Corporation.
const custom = util.inspect.custom;

// Copyright (c) Microsoft Corporation.
const errorSanitizer = new Sanitizer();
/**
 * A custom error type for failed pipeline requests.
 */
class RestError extends Error {
    constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, RestError.prototype);
    }
    /**
     * Logging method for util.inspect in Node
     */
    [custom]() {
        return `RestError: ${this.message} \n ${errorSanitizer.sanitize(this)}`;
    }
}
/**
 * Something went wrong when making the request.
 * This means the actual request failed for some reason,
 * such as a DNS issue or the connection being lost.
 */
RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
/**
 * This means that parsing the response from the server failed.
 * It may have been malformed.
 */
RestError.PARSE_ERROR = "PARSE_ERROR";
/**
 * Typeguard for RestError
 * @param e - Something caught by a catch clause.
 */
function isRestError(e) {
    if (e instanceof RestError) {
        return true;
    }
    return coreUtil.isError(e) && e.name === "RestError";
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the tracingPolicy.
 */
const tracingPolicyName = "tracingPolicy";
/**
 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
 * that has SpanOptions with a parent.
 * Requests made without a parent Span will not be recorded.
 * @param options - Options to configure the telemetry logged by the tracing policy.
 */
function tracingPolicy(options = {}) {
    const userAgent = getUserAgentValue(options.userAgentPrefix);
    const tracingClient = tryCreateTracingClient();
    return {
        name: tracingPolicyName,
        async sendRequest(request, next) {
            var _a, _b;
            if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {
                return next(request);
            }
            const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
            if (!span || !tracingContext) {
                return next(request);
            }
            try {
                const response = await tracingClient.withContext(tracingContext, next, request);
                tryProcessResponse(span, response);
                return response;
            }
            catch (err) {
                tryProcessError(span, err);
                throw err;
            }
        },
    };
}
function tryCreateTracingClient() {
    try {
        return coreTracing.createTracingClient({
            namespace: "",
            packageName: "@azure/core-rest-pipeline",
            packageVersion: SDK_VERSION,
        });
    }
    catch (e) {
        logger.warning(`Error when creating the TracingClient: ${coreUtil.getErrorMessage(e)}`);
        return undefined;
    }
}
function tryCreateSpan(tracingClient, request, userAgent) {
    try {
        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
            spanKind: "client",
            spanAttributes: {
                "http.method": request.method,
                "http.url": request.url,
                requestId: request.requestId,
            },
        });
        // If the span is not recording, don't do any more work.
        if (!span.isRecording()) {
            span.end();
            return undefined;
        }
        if (userAgent) {
            span.setAttribute("http.user_agent", userAgent);
        }
        // set headers
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers)) {
            request.headers.set(key, value);
        }
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    }
    catch (e) {
        logger.warning(`Skipping creating a tracing span due to an error: ${coreUtil.getErrorMessage(e)}`);
        return undefined;
    }
}
function tryProcessError(span, error) {
    try {
        span.setStatus({
            status: "error",
            error: coreUtil.isError(error) ? error : undefined,
        });
        if (isRestError(error) && error.statusCode) {
            span.setAttribute("http.status_code", error.statusCode);
        }
        span.end();
    }
    catch (e) {
        logger.warning(`Skipping tracing span processing due to an error: ${coreUtil.getErrorMessage(e)}`);
    }
}
function tryProcessResponse(span, response) {
    try {
        span.setAttribute("http.status_code", response.status);
        const serviceRequestId = response.headers.get("x-ms-request-id");
        if (serviceRequestId) {
            span.setAttribute("serviceRequestId", serviceRequestId);
        }
        span.setStatus({
            status: "success",
        });
        span.end();
    }
    catch (e) {
        logger.warning(`Skipping tracing span processing due to an error: ${coreUtil.getErrorMessage(e)}`);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Create a new pipeline with a default set of customizable policies.
 * @param options - Options to configure a custom pipeline.
 */
function createPipelineFromOptions(options) {
    const pipeline = createEmptyPipeline();
    if (coreUtil.isNode) {
        if (options.tlsOptions) {
            pipeline.addPolicy(tlsPolicy(options.tlsOptions));
        }
        pipeline.addPolicy(proxyPolicy(options.proxyOptions));
        pipeline.addPolicy(decompressResponsePolicy());
    }
    pipeline.addPolicy(formDataPolicy());
    pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
    pipeline.addPolicy(setClientRequestIdPolicy());
    pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
    pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: "Retry" });
    if (coreUtil.isNode) {
        // Both XHR and Fetch expect to handle redirects automatically,
        // so only include this policy when we're in Node.
        pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function normalizeName(name) {
    return name.toLowerCase();
}
function* headerIterator(map) {
    for (const entry of map.values()) {
        yield [entry.name, entry.value];
    }
}
class HttpHeadersImpl {
    constructor(rawHeaders) {
        this._headersMap = new Map();
        if (rawHeaders) {
            for (const headerName of Object.keys(rawHeaders)) {
                this.set(headerName, rawHeaders[headerName]);
            }
        }
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param name - The name of the header to set. This value is case-insensitive.
     * @param value - The value of the header to set.
     */
    set(name, value) {
        this._headersMap.set(normalizeName(name), { name, value: String(value) });
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param name - The name of the header. This value is case-insensitive.
     */
    get(name) {
        var _a;
        return (_a = this._headersMap.get(normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     * @param name - The name of the header to set. This value is case-insensitive.
     */
    has(name) {
        return this._headersMap.has(normalizeName(name));
    }
    /**
     * Remove the header with the provided headerName.
     * @param name - The name of the header to remove.
     */
    delete(name) {
        this._headersMap.delete(normalizeName(name));
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */
    toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
            for (const entry of this._headersMap.values()) {
                result[entry.name] = entry.value;
            }
        }
        else {
            for (const [normalizedName, entry] of this._headersMap) {
                result[normalizedName] = entry.value;
            }
        }
        return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */
    toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    /**
     * Iterate over tuples of header [name, value] pairs.
     */
    [Symbol.iterator]() {
        return headerIterator(this._headersMap);
    }
}
/**
 * Creates an object that satisfies the `HttpHeaders` interface.
 * @param rawHeaders - A simple object representing initial headers
 */
function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_TLS_SETTINGS = {};
function isReadableStream(body) {
    return body && typeof body.pipe === "function";
}
function isStreamComplete(stream) {
    return new Promise((resolve) => {
        stream.on("close", resolve);
        stream.on("end", resolve);
        stream.on("error", resolve);
    });
}
function isArrayBuffer(body) {
    return body && typeof body.byteLength === "number";
}
class ReportTransform extends stream.Transform {
    constructor(progressCallback) {
        super();
        this.loadedBytes = 0;
        this.progressCallback = progressCallback;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    _transform(chunk, _encoding, callback) {
        this.push(chunk);
        this.loadedBytes += chunk.length;
        try {
            this.progressCallback({ loadedBytes: this.loadedBytes });
            callback();
        }
        catch (e) {
            callback(e);
        }
    }
}
/**
 * A HttpClient implementation that uses Node's "https" module to send HTTPS requests.
 * @internal
 */
class NodeHttpClient {
    constructor() {
        this.cachedHttpsAgents = new WeakMap();
    }
    /**
     * Makes a request over an underlying transport layer and returns the response.
     * @param request - The request to be made.
     */
    async sendRequest(request) {
        var _a, _b, _c;
        const abortController$1 = new abortController.AbortController();
        let abortListener;
        if (request.abortSignal) {
            if (request.abortSignal.aborted) {
                throw new abortController.AbortError("The operation was aborted.");
            }
            abortListener = (event) => {
                if (event.type === "abort") {
                    abortController$1.abort();
                }
            };
            request.abortSignal.addEventListener("abort", abortListener);
        }
        if (request.timeout > 0) {
            setTimeout(() => {
                abortController$1.abort();
            }, request.timeout);
        }
        const acceptEncoding = request.headers.get("Accept-Encoding");
        const shouldDecompress = (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("deflate"));
        let body = typeof request.body === "function" ? request.body() : request.body;
        if (body && !request.headers.has("Content-Length")) {
            const bodyLength = getBodyLength(body);
            if (bodyLength !== null) {
                request.headers.set("Content-Length", bodyLength);
            }
        }
        let responseStream;
        try {
            if (body && request.onUploadProgress) {
                const onUploadProgress = request.onUploadProgress;
                const uploadReportStream = new ReportTransform(onUploadProgress);
                uploadReportStream.on("error", (e) => {
                    logger.error("Error in upload progress", e);
                });
                if (isReadableStream(body)) {
                    body.pipe(uploadReportStream);
                }
                else {
                    uploadReportStream.end(body);
                }
                body = uploadReportStream;
            }
            const res = await this.makeRequest(request, abortController$1, body);
            const headers = getResponseHeaders(res);
            const status = (_a = res.statusCode) !== null && _a !== void 0 ? _a : 0;
            const response = {
                status,
                headers,
                request,
            };
            // Responses to HEAD must not have a body.
            // If they do return a body, that body must be ignored.
            if (request.method === "HEAD") {
                res.destroy();
                return response;
            }
            responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
            const onDownloadProgress = request.onDownloadProgress;
            if (onDownloadProgress) {
                const downloadReportStream = new ReportTransform(onDownloadProgress);
                downloadReportStream.on("error", (e) => {
                    logger.error("Error in download progress", e);
                });
                responseStream.pipe(downloadReportStream);
                responseStream = downloadReportStream;
            }
            if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(Number.POSITIVE_INFINITY)) ||
                ((_c = request.streamResponseStatusCodes) === null || _c === void 0 ? void 0 : _c.has(response.status))) {
                response.readableStreamBody = responseStream;
            }
            else {
                response.bodyAsText = await streamToText(responseStream);
            }
            return response;
        }
        finally {
            // clean up event listener
            if (request.abortSignal && abortListener) {
                let uploadStreamDone = Promise.resolve();
                if (isReadableStream(body)) {
                    uploadStreamDone = isStreamComplete(body);
                }
                let downloadStreamDone = Promise.resolve();
                if (isReadableStream(responseStream)) {
                    downloadStreamDone = isStreamComplete(responseStream);
                }
                Promise.all([uploadStreamDone, downloadStreamDone])
                    .then(() => {
                    var _a;
                    // eslint-disable-next-line promise/always-return
                    if (abortListener) {
                        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", abortListener);
                    }
                })
                    .catch((e) => {
                    logger.warning("Error when cleaning up abortListener on httpRequest", e);
                });
            }
        }
    }
    makeRequest(request, abortController$1, body) {
        var _a;
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        const agent = (_a = request.agent) !== null && _a !== void 0 ? _a : this.getOrCreateAgent(request, isInsecure);
        const options = {
            agent,
            hostname: url.hostname,
            path: `${url.pathname}${url.search}`,
            port: url.port,
            method: request.method,
            headers: request.headers.toJSON({ preserveCase: true }),
        };
        return new Promise((resolve, reject) => {
            const req = isInsecure ? http__namespace.request(options, resolve) : https__namespace.request(options, resolve);
            req.once("error", (err) => {
                var _a;
                reject(new RestError(err.message, { code: (_a = err.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR, request }));
            });
            abortController$1.signal.addEventListener("abort", () => {
                const abortError = new abortController.AbortError("The operation was aborted.");
                req.destroy(abortError);
                reject(abortError);
            });
            if (body && isReadableStream(body)) {
                body.pipe(req);
            }
            else if (body) {
                if (typeof body === "string" || Buffer.isBuffer(body)) {
                    req.end(body);
                }
                else if (isArrayBuffer(body)) {
                    req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
                }
                else {
                    logger.error("Unrecognized body type", body);
                    reject(new RestError("Unrecognized body type"));
                }
            }
            else {
                // streams don't like "undefined" being passed as data
                req.end();
            }
        });
    }
    getOrCreateAgent(request, isInsecure) {
        var _a;
        const disableKeepAlive = request.disableKeepAlive;
        // Handle Insecure requests first
        if (isInsecure) {
            if (disableKeepAlive) {
                // keepAlive:false is the default so we don't need a custom Agent
                return http__namespace.globalAgent;
            }
            if (!this.cachedHttpAgent) {
                // If there is no cached agent create a new one and cache it.
                this.cachedHttpAgent = new http__namespace.Agent({ keepAlive: true });
            }
            return this.cachedHttpAgent;
        }
        else {
            if (disableKeepAlive && !request.tlsSettings) {
                // When there are no tlsSettings and keepAlive is false
                // we don't need a custom agent
                return https__namespace.globalAgent;
            }
            // We use the tlsSettings to index cached clients
            const tlsSettings = (_a = request.tlsSettings) !== null && _a !== void 0 ? _a : DEFAULT_TLS_SETTINGS;
            // Get the cached agent or create a new one with the
            // provided values for keepAlive and tlsSettings
            let agent = this.cachedHttpsAgents.get(tlsSettings);
            if (agent && agent.options.keepAlive === !disableKeepAlive) {
                return agent;
            }
            logger.info("No cached TLS Agent exist, creating a new Agent");
            agent = new https__namespace.Agent(Object.assign({ 
                // keepAlive is true if disableKeepAlive is false.
                keepAlive: !disableKeepAlive }, tlsSettings));
            this.cachedHttpsAgents.set(tlsSettings, agent);
            return agent;
        }
    }
}
function getResponseHeaders(res) {
    const headers = createHttpHeaders();
    for (const header of Object.keys(res.headers)) {
        const value = res.headers[header];
        if (Array.isArray(value)) {
            if (value.length > 0) {
                headers.set(header, value[0]);
            }
        }
        else if (value) {
            headers.set(header, value);
        }
    }
    return headers;
}
function getDecodedResponseStream(stream, headers) {
    const contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
        const unzip = zlib__namespace.createGunzip();
        stream.pipe(unzip);
        return unzip;
    }
    else if (contentEncoding === "deflate") {
        const inflate = zlib__namespace.createInflate();
        stream.pipe(inflate);
        return inflate;
    }
    return stream;
}
function streamToText(stream) {
    return new Promise((resolve, reject) => {
        const buffer = [];
        stream.on("data", (chunk) => {
            if (Buffer.isBuffer(chunk)) {
                buffer.push(chunk);
            }
            else {
                buffer.push(Buffer.from(chunk));
            }
        });
        stream.on("end", () => {
            resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream.on("error", (e) => {
            if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
                reject(e);
            }
            else {
                reject(new RestError(`Error reading response as text: ${e.message}`, {
                    code: RestError.PARSE_ERROR,
                }));
            }
        });
    });
}
/** @internal */
function getBodyLength(body) {
    if (!body) {
        return 0;
    }
    else if (Buffer.isBuffer(body)) {
        return body.length;
    }
    else if (isReadableStream(body)) {
        return null;
    }
    else if (isArrayBuffer(body)) {
        return body.byteLength;
    }
    else if (typeof body === "string") {
        return Buffer.from(body).length;
    }
    else {
        return null;
    }
}
/**
 * Create a new HttpClient instance for the NodeJS environment.
 * @internal
 */
function createNodeHttpClient() {
    return new NodeHttpClient();
}

// Copyright (c) Microsoft Corporation.
/**
 * Create the correct HttpClient for the current environment.
 */
function createDefaultHttpClient() {
    return createNodeHttpClient();
}

// Copyright (c) Microsoft Corporation.
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 * @internal
 */
function generateUuid() {
    return uuid.v4();
}

// Copyright (c) Microsoft Corporation.
class PipelineRequestImpl {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : createHttpHeaders();
        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
        this.formData = options.formData;
        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || generateUuid();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
    }
}
/**
 * Creates a new pipeline request with the given options.
 * This method is to allow for the easy setting of default values and not required.
 * @param options - The options to create the request with.
 */
function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the exponentialRetryPolicy.
 */
const exponentialRetryPolicyName = "exponentialRetryPolicy";
/**
 * A policy that attempts to retry requests while introducing an exponentially increasing delay.
 * @param options - Options that configure retry logic.
 */
function exponentialRetryPolicy(options = {}) {
    var _a;
    return retryPolicy([
        exponentialRetryStrategy(Object.assign(Object.assign({}, options), { ignoreSystemErrors: true })),
    ], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Name of the {@link systemErrorRetryPolicy}
 */
const systemErrorRetryPolicyName = "systemErrorRetryPolicy";
/**
 * A retry policy that specifically seeks to handle errors in the
 * underlying transport layer (e.g. DNS lookup failures) rather than
 * retryable error codes from the server itself.
 * @param options - Options that customize the policy.
 */
function systemErrorRetryPolicy(options = {}) {
    var _a;
    return {
        name: systemErrorRetryPolicyName,
        sendRequest: retryPolicy([
            exponentialRetryStrategy(Object.assign(Object.assign({}, options), { ignoreHttpStatusCodes: true })),
        ], {
            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,
        }).sendRequest,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Name of the {@link throttlingRetryPolicy}
 */
const throttlingRetryPolicyName = "throttlingRetryPolicy";
/**
 * A policy that retries when the server sends a 429 response with a Retry-After header.
 *
 * To learn more, please refer to
 * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
 * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
 *
 * @param options - Options that configure retry logic.
 */
function throttlingRetryPolicy(options = {}) {
    var _a;
    return {
        name: throttlingRetryPolicyName,
        sendRequest: retryPolicy([throttlingRetryStrategy()], {
            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,
        }).sendRequest,
    };
}

// Copyright (c) Microsoft Corporation.
// Default options for the cycler if none are provided
const DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
 * @returns - A promise that, if it resolves, will resolve with an access token.
 */
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    // This wrapper handles exceptions gracefully as long as we haven't exceeded
    // the timeout.
    async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
            try {
                return await getAccessToken();
            }
            catch (_a) {
                return null;
            }
        }
        else {
            const finalToken = await getAccessToken();
            // Timeout is up, so throw if it's still null
            if (finalToken === null) {
                throw new Error("Failed to refresh access token.");
            }
            return finalToken;
        }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
        await delay(retryIntervalInMs);
        token = await tryGetAccessToken();
    }
    return token;
}
/**
 * Creates a token cycler from a credential, scopes, and optional settings.
 *
 * A token cycler represents a way to reliably retrieve a valid access token
 * from a TokenCredential. It will handle initializing the token, refreshing it
 * when it nears expiration, and synchronizes refresh attempts to avoid
 * concurrency hazards.
 *
 * @param credential - the underlying TokenCredential that provides the access
 * token
 * @param tokenCyclerOptions - optionally override default settings for the cycler
 *
 * @returns - a function that reliably produces a valid access token
 */
function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    /**
     * This little holder defines several predicates that we use to construct
     * the rules of refreshing the token.
     */
    const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
            return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
            var _a;
            return (!cycler.isRefreshing &&
                ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now());
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
        },
    };
    /**
     * Starts a refresh job or returns the existing job if one is already
     * running.
     */
    function refresh(scopes, getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
            // We bind `scopes` here to avoid passing it around a lot
            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
            // Take advantage of promise chaining to insert an assignment to `token`
            // before the refresh can be considered done.
            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
            // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())
                .then((_token) => {
                refreshWorker = null;
                token = _token;
                tenantId = getTokenOptions.tenantId;
                return token;
            })
                .catch((reason) => {
                // We also should reset the refresher if we enter a failed state.  All
                // existing awaiters will throw, but subsequent requests will start a
                // new retry chain.
                refreshWorker = null;
                token = null;
                tenantId = undefined;
                throw reason;
            });
        }
        return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
        //
        // Simple rules:
        // - If we MUST refresh, then return the refresh task, blocking
        //   the pipeline until a token is available.
        // - If we SHOULD refresh, then run refresh but don't return it
        //   (we can still use the cached token).
        // - Return the token, since it's fine if we didn't return in
        //   step 1.
        //
        // If the tenantId passed in token options is different to the one we have
        // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
        // refresh the token with the new tenantId or token.
        const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
        if (mustRefresh)
            return refresh(scopes, tokenOptions);
        if (cycler.shouldRefresh) {
            refresh(scopes, tokenOptions);
        }
        return token;
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
 */
const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
/**
 * Default authorize request handler
 */
async function defaultAuthorizeRequest(options) {
    const { scopes, getAccessToken, request } = options;
    const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions,
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) {
        options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    }
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */
function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
        return challenge;
    }
    return;
}
/**
 * A policy that can request a token from a TokenCredential implementation and
 * then apply it to the Authorization header of a request as a Bearer token.
 */
function bearerTokenAuthenticationPolicy(options) {
    var _a;
    const { credential, scopes, challengeCallbacks } = options;
    const logger$1 = options.logger || logger;
    const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
    // This function encapsulates the entire process of reliably retrieving the token
    // The options are left out of the public API until there's demand to configure this.
    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
    // in order to pass through the `options` object.
    const getAccessToken = credential
        ? createTokenCycler(credential /* , options */)
        : () => Promise.resolve(null);
    return {
        name: bearerTokenAuthenticationPolicyName,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */
        async sendRequest(request, next) {
            if (!request.url.toLowerCase().startsWith("https://")) {
                throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
            }
            await callbacks.authorizeRequest({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request,
                getAccessToken,
                logger: logger$1,
            });
            let response;
            let error;
            try {
                response = await next(request);
            }
            catch (err) {
                error = err;
                response = err.response;
            }
            if (callbacks.authorizeRequestOnChallenge &&
                (response === null || response === void 0 ? void 0 : response.status) === 401 &&
                getChallenge(response)) {
                // processes challenge
                const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    request,
                    response,
                    getAccessToken,
                    logger: logger$1,
                });
                if (shouldSendRequest) {
                    return next(request);
                }
            }
            if (error) {
                throw error;
            }
            else {
                return response;
            }
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the ndJsonPolicy.
 */
const ndJsonPolicyName = "ndJsonPolicy";
/**
 * ndJsonPolicy is a policy used to control keep alive settings for every request.
 */
function ndJsonPolicy() {
    return {
        name: ndJsonPolicyName,
        async sendRequest(request, next) {
            // There currently isn't a good way to bypass the serializer
            if (typeof request.body === "string" && request.body.startsWith("[")) {
                const body = JSON.parse(request.body);
                if (Array.isArray(body)) {
                    request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
                }
            }
            return next(request);
        },
    };
}

exports.RestError = RestError;
exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
exports.bearerTokenAuthenticationPolicyName = bearerTokenAuthenticationPolicyName;
exports.createDefaultHttpClient = createDefaultHttpClient;
exports.createEmptyPipeline = createEmptyPipeline;
exports.createHttpHeaders = createHttpHeaders;
exports.createPipelineFromOptions = createPipelineFromOptions;
exports.createPipelineRequest = createPipelineRequest;
exports.decompressResponsePolicy = decompressResponsePolicy;
exports.decompressResponsePolicyName = decompressResponsePolicyName;
exports.defaultRetryPolicy = defaultRetryPolicy;
exports.exponentialRetryPolicy = exponentialRetryPolicy;
exports.exponentialRetryPolicyName = exponentialRetryPolicyName;
exports.formDataPolicy = formDataPolicy;
exports.formDataPolicyName = formDataPolicyName;
exports.getDefaultProxySettings = getDefaultProxySettings;
exports.isRestError = isRestError;
exports.logPolicy = logPolicy;
exports.logPolicyName = logPolicyName;
exports.ndJsonPolicy = ndJsonPolicy;
exports.ndJsonPolicyName = ndJsonPolicyName;
exports.proxyPolicy = proxyPolicy;
exports.proxyPolicyName = proxyPolicyName;
exports.redirectPolicy = redirectPolicy;
exports.redirectPolicyName = redirectPolicyName;
exports.retryPolicy = retryPolicy;
exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
exports.setClientRequestIdPolicyName = setClientRequestIdPolicyName;
exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
exports.systemErrorRetryPolicyName = systemErrorRetryPolicyName;
exports.throttlingRetryPolicy = throttlingRetryPolicy;
exports.throttlingRetryPolicyName = throttlingRetryPolicyName;
exports.tlsPolicy = tlsPolicy;
exports.tlsPolicyName = tlsPolicyName;
exports.tracingPolicy = tracingPolicy;
exports.tracingPolicyName = tracingPolicyName;
exports.userAgentPolicy = userAgentPolicy;
exports.userAgentPolicyName = userAgentPolicyName;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 7439:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @internal */
const knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace"),
};
/**
 * Creates a new {@link TracingContext} with the given options.
 * @param options - A set of known keys that may be set on the context.
 * @returns A new {@link TracingContext} with the given options.
 *
 * @internal
 */
function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    if (options.span) {
        context = context.setValue(knownContextKeys.span, options.span);
    }
    if (options.namespace) {
        context = context.setValue(knownContextKeys.namespace, options.namespace);
    }
    return context;
}
/** @internal */
class TracingContextImpl {
    constructor(initialContext) {
        this._contextMap =
            initialContext instanceof TracingContextImpl
                ? new Map(initialContext._contextMap)
                : new Map();
    }
    setValue(key, value) {
        const newContext = new TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
    }
    getValue(key) {
        return this._contextMap.get(key);
    }
    deleteValue(key) {
        const newContext = new TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
    }
}

// Copyright (c) Microsoft Corporation.
function createDefaultTracingSpan() {
    return {
        end: () => {
            // noop
        },
        isRecording: () => false,
        recordException: () => {
            // noop
        },
        setAttribute: () => {
            // noop
        },
        setStatus: () => {
            // noop
        },
    };
}
function createDefaultInstrumenter() {
    return {
        createRequestHeaders: () => {
            return {};
        },
        parseTraceparentHeader: () => {
            return undefined;
        },
        startSpan: (_name, spanOptions) => {
            return {
                span: createDefaultTracingSpan(),
                tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),
            };
        },
        withContext(_context, callback, ...callbackArgs) {
            return callback(...callbackArgs);
        },
    };
}
/** @internal */
let instrumenterImplementation;
/**
 * Extends the Azure SDK with support for a given instrumenter implementation.
 *
 * @param instrumenter - The instrumenter implementation to use.
 */
function useInstrumenter(instrumenter) {
    instrumenterImplementation = instrumenter;
}
/**
 * Gets the currently set instrumenter, a No-Op instrumenter by default.
 *
 * @returns The currently set instrumenter
 */
function getInstrumenter() {
    if (!instrumenterImplementation) {
        instrumenterImplementation = createDefaultInstrumenter();
    }
    return instrumenterImplementation;
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a new tracing client.
 *
 * @param options - Options used to configure the tracing client.
 * @returns - An instance of {@link TracingClient}.
 */
function createTracingClient(options) {
    const { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
        var _a;
        const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName: packageName, packageVersion: packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        if (!tracingContext.getValue(knownContextKeys.namespace)) {
            tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
        }
        span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
        const updatedOptions = Object.assign({}, operationOptions, {
            tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext }),
        });
        return {
            span,
            updatedOptions,
        };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
        try {
            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
            span.setStatus({ status: "success" });
            return result;
        }
        catch (err) {
            span.setStatus({ status: "error", error: err });
            throw err;
        }
        finally {
            span.end();
        }
    }
    function withContext(context, callback, ...callbackArgs) {
        return getInstrumenter().withContext(context, callback, ...callbackArgs);
    }
    /**
     * Parses a traceparent header value into a span identifier.
     *
     * @param traceparentHeader - The traceparent header to parse.
     * @returns An implementation-specific identifier for the span.
     */
    function parseTraceparentHeader(traceparentHeader) {
        return getInstrumenter().parseTraceparentHeader(traceparentHeader);
    }
    /**
     * Creates a set of request headers to propagate tracing information to a backend.
     *
     * @param tracingContext - The context containing the span to serialize.
     * @returns The set of headers to add to a request.
     */
    function createRequestHeaders(tracingContext) {
        return getInstrumenter().createRequestHeaders(tracingContext);
    }
    return {
        startSpan,
        withSpan,
        withContext,
        parseTraceparentHeader,
        createRequestHeaders,
    };
}

exports.createTracingClient = createTracingClient;
exports.useInstrumenter = useInstrumenter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 9113:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var crypto = __nccwpck_require__(6113);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a;
/**
 * A constant that indicates whether the environment the code is running is Node.JS.
 */
const isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
 * @param timeInMs - The number of milliseconds to be delayed.
 * @returns Promise that is resolved after timeInMs
 */
function delay(timeInMs) {
    return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns a random integer value between a lower and upper bound,
 * inclusive of both bounds.
 * Note that this uses Math.random and isn't secure. If you need to use
 * this for any kind of security purpose, find a better source of random.
 * @param min - The smallest integer value allowed.
 * @param max - The largest integer value allowed.
 */
function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper to determine when an input is a generic JS object.
 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
 */
function isObject(input) {
    return (typeof input === "object" &&
        input !== null &&
        !Array.isArray(input) &&
        !(input instanceof RegExp) &&
        !(input instanceof Date));
}

// Copyright (c) Microsoft Corporation.
/**
 * Typeguard for an error object shape (has name and message)
 * @param e - Something caught by a catch clause.
 */
function isError(e) {
    if (isObject(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
    }
    return false;
}
/**
 * Given what is thought to be an error object, return the message if possible.
 * If the message is missing, returns a stringified version of the input.
 * @param e - Something thrown from a try block
 * @returns The error message or a string of the input
 */
function getErrorMessage(e) {
    if (isError(e)) {
        return e.message;
    }
    else {
        let stringified;
        try {
            if (typeof e === "object" && e) {
                stringified = JSON.stringify(e);
            }
            else {
                stringified = String(e);
            }
        }
        catch (err) {
            stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Generates a SHA-256 HMAC signature.
 * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
 * @param stringToSign - The data to be signed.
 * @param encoding - The textual encoding to use for the returned HMAC digest.
 */
async function computeSha256Hmac(key, stringToSign, encoding) {
    const decodedKey = Buffer.from(key, "base64");
    return crypto.createHmac("sha256", decodedKey).update(stringToSign).digest(encoding);
}
/**
 * Generates a SHA-256 hash.
 * @param content - The data to be included in the hash.
 * @param encoding - The textual encoding to use for the returned hash.
 */
async function computeSha256Hash(content, encoding) {
    return crypto.createHash("sha256").update(content).digest(encoding);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 */
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 */
function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
        return false;
    }
    for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
            return false;
        }
    }
    return true;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 */
function objectHasProperty(thing, property) {
    return (isDefined(thing) && typeof thing === "object" && property in thing);
}

exports.computeSha256Hash = computeSha256Hash;
exports.computeSha256Hmac = computeSha256Hmac;
exports.delay = delay;
exports.getErrorMessage = getErrorMessage;
exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
exports.isDefined = isDefined;
exports.isError = isError;
exports.isNode = isNode;
exports.isObject = isObject;
exports.isObjectWithProperties = isObjectWithProperties;
exports.objectHasProperty = objectHasProperty;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 5671:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var msalNode = __nccwpck_require__(9941);
var coreClient = __nccwpck_require__(9626);
var coreUtil = __nccwpck_require__(9113);
var coreRestPipeline = __nccwpck_require__(6938);
var abortController = __nccwpck_require__(1925);
var coreTracing = __nccwpck_require__(7439);
var logger$m = __nccwpck_require__(803);
var msalCommon = __nccwpck_require__(6849);
var uuid = __nccwpck_require__(5650);
var fs = __nccwpck_require__(7147);
var os = __nccwpck_require__(2037);
var path = __nccwpck_require__(1017);
var child_process = __nccwpck_require__(2081);
var crypto = __nccwpck_require__(6113);
var util = __nccwpck_require__(3837);
var https = __nccwpck_require__(5687);
var http = __nccwpck_require__(3685);
var open = __nccwpck_require__(395);
var stoppable = __nccwpck_require__(1207);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var msalNode__namespace = /*#__PURE__*/_interopNamespace(msalNode);
var msalCommon__namespace = /*#__PURE__*/_interopNamespace(msalCommon);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var child_process__default = /*#__PURE__*/_interopDefaultLegacy(child_process);
var child_process__namespace = /*#__PURE__*/_interopNamespace(child_process);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var open__default = /*#__PURE__*/_interopDefaultLegacy(open);
var stoppable__default = /*#__PURE__*/_interopDefaultLegacy(stoppable);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isErrorResponse(errorResponse) {
    return (errorResponse &&
        typeof errorResponse.error === "string" &&
        typeof errorResponse.error_description === "string");
}
/**
 * The Error.name value of an CredentialUnavailable
 */
const CredentialUnavailableErrorName = "CredentialUnavailableError";
/**
 * This signifies that the credential that was tried in a chained credential
 * was not available to be used as the credential. Rather than treating this as
 * an error that should halt the chain, it's caught and the chain continues
 */
class CredentialUnavailableError extends Error {
    constructor(message) {
        super(message);
        this.name = CredentialUnavailableErrorName;
    }
}
/**
 * The Error.name value of an AuthenticationError
 */
const AuthenticationErrorName = "AuthenticationError";
/**
 * Provides details about a failure to authenticate with Azure Active
 * Directory.  The `errorResponse` field contains more details about
 * the specific failure.
 */
class AuthenticationError extends Error {
    // eslint-disable-next-line @typescript-eslint/ban-types
    constructor(statusCode, errorBody) {
        let errorResponse = {
            error: "unknown",
            errorDescription: "An unknown error occurred and no additional details are available.",
        };
        if (isErrorResponse(errorBody)) {
            errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        }
        else if (typeof errorBody === "string") {
            try {
                // Most error responses will contain JSON-formatted error details
                // in the response body
                const oauthErrorResponse = JSON.parse(errorBody);
                errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
            }
            catch (e) {
                if (statusCode === 400) {
                    errorResponse = {
                        error: "authority_not_found",
                        errorDescription: "The specified authority URL was not found.",
                    };
                }
                else {
                    errorResponse = {
                        error: "unknown_error",
                        errorDescription: `An unknown error has occurred. Response body:\n\n${errorBody}`,
                    };
                }
            }
        }
        else {
            errorResponse = {
                error: "unknown_error",
                errorDescription: "An unknown error occurred and no additional details are available.",
            };
        }
        super(`${errorResponse.error} Status code: ${statusCode}\nMore details:\n${errorResponse.errorDescription}`);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        // Ensure that this type reports the correct name
        this.name = AuthenticationErrorName;
    }
}
/**
 * The Error.name value of an AggregateAuthenticationError
 */
const AggregateAuthenticationErrorName = "AggregateAuthenticationError";
/**
 * Provides an `errors` array containing {@link AuthenticationError} instance
 * for authentication failures from credentials in a {@link ChainedTokenCredential}.
 */
class AggregateAuthenticationError extends Error {
    constructor(errors, errorMessage) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage}\n${errorDetail}`);
        this.errors = errors;
        // Ensure that this type reports the correct name
        this.name = AggregateAuthenticationErrorName;
    }
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
    return {
        error: errorBody.error,
        errorDescription: errorBody.error_description,
        correlationId: errorBody.correlation_id,
        errorCodes: errorBody.error_codes,
        timestamp: errorBody.timestamp,
        traceId: errorBody.trace_id,
    };
}
/**
 * Error used to enforce authentication after trying to retrieve a token silently.
 */
class AuthenticationRequiredError extends Error {
    constructor(
    /**
     * Optional parameters. A message can be specified. The {@link GetTokenOptions} of the request can also be specified to more easily associate the error with the received parameters.
     */
    options) {
        super(options.message);
        this.scopes = options.scopes;
        this.getTokenOptions = options.getTokenOptions;
        this.name = "AuthenticationRequiredError";
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getIdentityTokenEndpointSuffix(tenantId) {
    if (tenantId === "adfs") {
        return "oauth2/token";
    }
    else {
        return "oauth2/v2.0/token";
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Current version of the `@azure/identity` package.
 */
const SDK_VERSION = `2.1.0`;
/**
 * The default client ID for authentication
 * @internal
 */
// TODO: temporary - this is the Azure CLI clientID - we'll replace it when
// Developer Sign On application is available
// https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/Constants.cs#L9
const DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
/**
 * The default tenant for authentication
 * @internal
 */
const DefaultTenantId = "common";
/**
 * A list of known Azure authority hosts
 */
exports.AzureAuthorityHosts = void 0;
(function (AzureAuthorityHosts) {
    /**
     * China-based Azure Authority Host
     */
    AzureAuthorityHosts["AzureChina"] = "https://login.chinacloudapi.cn";
    /**
     * Germany-based Azure Authority Host
     */
    AzureAuthorityHosts["AzureGermany"] = "https://login.microsoftonline.de";
    /**
     * US Government Azure Authority Host
     */
    AzureAuthorityHosts["AzureGovernment"] = "https://login.microsoftonline.us";
    /**
     * Public Cloud Azure Authority Host
     */
    AzureAuthorityHosts["AzurePublicCloud"] = "https://login.microsoftonline.com";
})(exports.AzureAuthorityHosts || (exports.AzureAuthorityHosts = {}));
/**
 * The default authority host.
 */
const DefaultAuthorityHost = exports.AzureAuthorityHosts.AzurePublicCloud;

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.AAD",
    packageName: "@azure/identity",
    packageVersion: SDK_VERSION,
});

// Copyright (c) Microsoft Corporation.
/**
 * The AzureLogger used for all clients within the identity package
 */
const logger$l = logger$m.createClientLogger("identity");
/**
 * Separates a list of environment variable names into a plain object with two arrays: an array of missing environment variables and another array with assigned environment variables.
 * @param supportedEnvVars - List of environment variable names
 */
function processEnvVars(supportedEnvVars) {
    return supportedEnvVars.reduce((acc, envVariable) => {
        if (process.env[envVariable]) {
            acc.assigned.push(envVariable);
        }
        else {
            acc.missing.push(envVariable);
        }
        return acc;
    }, { missing: [], assigned: [] });
}
/**
 * Formatting the success event on the credentials
 */
function formatSuccess(scope) {
    return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
}
/**
 * Formatting the success event on the credentials
 */
function formatError(scope, error) {
    let message = "ERROR.";
    if (scope === null || scope === void 0 ? void 0 : scope.length) {
        message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
    }
    return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
}
/**
 * Generates a CredentialLoggerInstance.
 *
 * It logs with the format:
 *
 *   `[title] => [message]`
 *
 */
function credentialLoggerInstance(title, parent, log = logger$l) {
    const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
    function info(message) {
        log.info(`${fullTitle} =>`, message);
    }
    function warning(message) {
        log.warning(`${fullTitle} =>`, message);
    }
    return {
        title,
        fullTitle,
        info,
        warning,
    };
}
/**
 * Generates a CredentialLogger, which is a logger declared at the credential's constructor, and used at any point in the credential.
 * It has all the properties of a CredentialLoggerInstance, plus other logger instances, one per method.
 *
 * It logs with the format:
 *
 *   `[title] => [message]`
 *   `[title] => getToken() => [message]`
 *
 */
function credentialLogger(title, log = logger$l) {
    const credLogger = credentialLoggerInstance(title, undefined, log);
    return Object.assign(Object.assign({}, credLogger), { parent: log, getToken: credentialLoggerInstance("=> getToken()", credLogger, log) });
}

// Copyright (c) Microsoft Corporation.
const noCorrelationId = "noCorrelationId";
/**
 * @internal
 */
function getIdentityClientAuthorityHost(options) {
    // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.
    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;
    // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.
    if (coreUtil.isNode) {
        authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;
    }
    // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com
    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;
}
/**
 * The network module used by the Identity credentials.
 *
 * It allows for credentials to abort any pending request independently of the MSAL flow,
 * by calling to the `abortRequests()` method.
 *
 */
class IdentityClient extends coreClient.ServiceClient {
    constructor(options) {
        var _a, _b;
        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;
        const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const baseUri = getIdentityClientAuthorityHost(options);
        if (!baseUri.startsWith("https:")) {
            throw new Error("The authorityHost address must use the 'https' protocol.");
        }
        super(Object.assign(Object.assign({ requestContentType: "application/json; charset=utf-8", retryOptions: {
                maxRetries: 3,
            } }, options), { userAgentOptions: {
                userAgentPrefix,
            }, baseUri }));
        this.authorityHost = baseUri;
        this.abortControllers = new Map();
        this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;
    }
    async sendTokenRequest(request, expiresOnParser) {
        logger$l.info(`IdentityClient: sending token request to [${request.url}]`);
        const response = await this.sendRequest(request);
        expiresOnParser =
            expiresOnParser ||
                ((responseBody) => {
                    return Date.now() + responseBody.expires_in * 1000;
                });
        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
            const parsedBody = JSON.parse(response.bodyAsText);
            if (!parsedBody.access_token) {
                return null;
            }
            this.logIdentifiers(response);
            const token = {
                accessToken: {
                    token: parsedBody.access_token,
                    expiresOnTimestamp: expiresOnParser(parsedBody),
                },
                refreshToken: parsedBody.refresh_token,
            };
            logger$l.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
            return token;
        }
        else {
            const error = new AuthenticationError(response.status, response.bodyAsText);
            logger$l.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
            throw error;
        }
    }
    async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options = {}) {
        if (refreshToken === undefined) {
            return null;
        }
        logger$l.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
        const refreshParams = {
            grant_type: "refresh_token",
            client_id: clientId,
            refresh_token: refreshToken,
            scope: scopes,
        };
        if (clientSecret !== undefined) {
            refreshParams.client_secret = clientSecret;
        }
        const query = new URLSearchParams(refreshParams);
        return tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
            try {
                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
                const request = coreRestPipeline.createPipelineRequest({
                    url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
                    method: "POST",
                    body: query.toString(),
                    abortSignal: options.abortSignal,
                    headers: coreRestPipeline.createHttpHeaders({
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded",
                    }),
                    tracingOptions: updatedOptions.tracingOptions,
                });
                const response = await this.sendTokenRequest(request, expiresOnParser);
                logger$l.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
                return response;
            }
            catch (err) {
                if (err.name === AuthenticationErrorName &&
                    err.errorResponse.error === "interaction_required") {
                    // It's likely that the refresh token has expired, so
                    // return null so that the credential implementation will
                    // initiate the authentication flow again.
                    logger$l.info(`IdentityClient: interaction required for client ID: ${clientId}`);
                    return null;
                }
                else {
                    logger$l.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
                    throw err;
                }
            }
        });
    }
    // Here is a custom layer that allows us to abort requests that go through MSAL,
    // since MSAL doesn't allow us to pass options all the way through.
    generateAbortSignal(correlationId) {
        const controller = new abortController.AbortController();
        const controllers = this.abortControllers.get(correlationId) || [];
        controllers.push(controller);
        this.abortControllers.set(correlationId, controllers);
        const existingOnAbort = controller.signal.onabort;
        controller.signal.onabort = (...params) => {
            this.abortControllers.set(correlationId, undefined);
            if (existingOnAbort) {
                existingOnAbort(...params);
            }
        };
        return controller.signal;
    }
    abortRequests(correlationId) {
        const key = correlationId || noCorrelationId;
        const controllers = [
            ...(this.abortControllers.get(key) || []),
            // MSAL passes no correlation ID to the get requests...
            ...(this.abortControllers.get(noCorrelationId) || []),
        ];
        if (!controllers.length) {
            return;
        }
        for (const controller of controllers) {
            controller.abort();
        }
        this.abortControllers.set(key, undefined);
    }
    getCorrelationId(options) {
        var _a;
        const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split("&").map((part) => part.split("=")).find(([key]) => key === "client-request-id");
        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
    }
    // The MSAL network module methods follow
    async sendGetRequestAsync(url, options) {
        const request = coreRestPipeline.createPipelineRequest({
            url,
            method: "GET",
            body: options === null || options === void 0 ? void 0 : options.body,
            headers: coreRestPipeline.createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
            abortSignal: this.generateAbortSignal(noCorrelationId),
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,
            headers: response.headers.toJSON(),
            status: response.status,
        };
    }
    async sendPostRequestAsync(url, options) {
        const request = coreRestPipeline.createPipelineRequest({
            url,
            method: "POST",
            body: options === null || options === void 0 ? void 0 : options.body,
            headers: coreRestPipeline.createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
            // MSAL doesn't send the correlation ID on the get requests.
            abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,
            headers: response.headers.toJSON(),
            status: response.status,
        };
    }
    /**
     * If allowLoggingAccountIdentifiers was set on the constructor options
     * we try to log the account identifiers by parsing the received access token.
     *
     * The account identifiers we try to log are:
     * - `appid`: The application or Client Identifier.
     * - `upn`: User Principal Name.
     *   - It might not be available in some authentication scenarios.
     *   - If it's not available, we put a placeholder: "No User Principal Name available".
     * - `tid`: Tenant Identifier.
     * - `oid`: Object Identifier of the authenticated user.
     */
    logIdentifiers(response) {
        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
            return;
        }
        const unavailableUpn = "No User Principal Name available";
        try {
            const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
            const accessToken = parsed.access_token;
            if (!accessToken) {
                // Without an access token allowLoggingAccountIdentifiers isn't useful.
                return;
            }
            const base64Metadata = accessToken.split(".")[1];
            const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
            logger$l.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
        }
        catch (e) {
            logger$l.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
        }
    }
}

// Copyright (c) Microsoft Corporation.
function checkTenantId(logger, tenantId) {
    if (!tenantId.match(/^[0-9a-zA-Z-.:/]+$/)) {
        const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://docs.microsoft.com/partner-center/find-ids-and-domain-names.");
        logger.info(formatError("", error));
        throw error;
    }
}

// Copyright (c) Microsoft Corporation.
function resolveTenantId(logger, tenantId, clientId) {
    if (tenantId) {
        checkTenantId(logger, tenantId);
        return tenantId;
    }
    if (!clientId) {
        clientId = DeveloperSignOnClientId;
    }
    if (clientId !== DeveloperSignOnClientId) {
        return "common";
    }
    return "organizations";
}

// Copyright (c) Microsoft Corporation.
/**
 * Latest AuthenticationRecord version
 * @internal
 */
const LatestAuthenticationRecordVersion = "1.0";
/**
 * Ensures the validity of the MSAL token
 * @internal
 */
function ensureValidMsalToken(scopes, logger, msalToken, getTokenOptions) {
    const error = (message) => {
        logger.getToken.info(message);
        return new AuthenticationRequiredError({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            getTokenOptions,
            message,
        });
    };
    if (!msalToken) {
        throw error("No response");
    }
    if (!msalToken.expiresOn) {
        throw error(`Response had no "expiresOn" property.`);
    }
    if (!msalToken.accessToken) {
        throw error(`Response had no "accessToken" property.`);
    }
}
/**
 * Generates a valid authority by combining a host with a tenantId.
 * @internal
 */
function getAuthority(tenantId, host) {
    if (!host) {
        host = DefaultAuthorityHost;
    }
    if (new RegExp(`${tenantId}/?$`).test(host)) {
        return host;
    }
    if (host.endsWith("/")) {
        return host + tenantId;
    }
    else {
        return `${host}/${tenantId}`;
    }
}
/**
 * Generates the known authorities.
 * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.
 * For that reason, we have to force MSAL to disable validating the authority
 * by sending it within the known authorities in the MSAL configuration.
 * @internal
 */
function getKnownAuthorities(tenantId, authorityHost) {
    if (tenantId === "adfs" && authorityHost) {
        return [authorityHost];
    }
    return [];
}
/**
 * Generates a logger that can be passed to the MSAL clients.
 * @param logger - The logger of the credential.
 * @internal
 */
const defaultLoggerCallback = (logger, platform = coreUtil.isNode ? "Node" : "Browser") => (level, message, containsPii) => {
    if (containsPii) {
        return;
    }
    switch (level) {
        case msalCommon__namespace.LogLevel.Error:
            logger.info(`MSAL ${platform} V2 error: ${message}`);
            return;
        case msalCommon__namespace.LogLevel.Info:
            logger.info(`MSAL ${platform} V2 info message: ${message}`);
            return;
        case msalCommon__namespace.LogLevel.Verbose:
            logger.info(`MSAL ${platform} V2 verbose message: ${message}`);
            return;
        case msalCommon__namespace.LogLevel.Warning:
            logger.info(`MSAL ${platform} V2 warning: ${message}`);
            return;
    }
};
/**
 * The common utility functions for the MSAL clients.
 * Defined as a class so that the classes extending this one can have access to its methods and protected properties.
 *
 * It keeps track of a logger and an in-memory copy of the AuthenticationRecord.
 *
 * @internal
 */
class MsalBaseUtilities {
    constructor(options) {
        this.logger = options.logger;
        this.account = options.authenticationRecord;
    }
    /**
     * Generates a UUID
     */
    generateUuid() {
        return uuid.v4();
    }
    /**
     * Handles the MSAL authentication result.
     * If the result has an account, we update the local account reference.
     * If the token received is invalid, an error will be thrown depending on what's missing.
     */
    handleResult(scopes, clientId, result, getTokenOptions) {
        if (result === null || result === void 0 ? void 0 : result.account) {
            this.account = msalToPublic(clientId, result.account);
        }
        ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);
        this.logger.getToken.info(formatSuccess(scopes));
        return {
            token: result.accessToken,
            expiresOnTimestamp: result.expiresOn.getTime(),
        };
    }
    /**
     * Handles MSAL errors.
     */
    handleError(scopes, error, getTokenOptions) {
        if (error.name === "AuthError" ||
            error.name === "ClientAuthError" ||
            error.name === "BrowserAuthError") {
            const msalError = error;
            switch (msalError.errorCode) {
                case "endpoints_resolution_error":
                    this.logger.info(formatError(scopes, error.message));
                    return new CredentialUnavailableError(error.message);
                case "device_code_polling_cancelled":
                    return new abortController.AbortError("The authentication has been aborted by the caller.");
                case "consent_required":
                case "interaction_required":
                case "login_required":
                    this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
                    break;
                default:
                    this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));
                    break;
            }
        }
        if (error.name === "ClientConfigurationError" ||
            error.name === "BrowserConfigurationAuthError" ||
            error.name === "AbortError") {
            return error;
        }
        return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
    }
}
// transformations.ts
function publicToMsal(account) {
    const [environment] = account.authority.match(/([a-z]*\.[a-z]*\.[a-z]*)/) || [];
    return Object.assign(Object.assign({}, account), { localAccountId: account.homeAccountId, environment });
}
function msalToPublic(clientId, account) {
    const record = {
        authority: getAuthority(account.tenantId, account.environment),
        homeAccountId: account.homeAccountId,
        tenantId: account.tenantId || DefaultTenantId,
        username: account.username,
        clientId,
        version: LatestAuthenticationRecordVersion,
    };
    return record;
}
/**
 * Serializes an `AuthenticationRecord` into a string.
 *
 * The output of a serialized authentication record will contain the following properties:
 *
 * - "authority"
 * - "homeAccountId"
 * - "clientId"
 * - "tenantId"
 * - "username"
 * - "version"
 *
 * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.
 */
function serializeAuthenticationRecord(record) {
    return JSON.stringify(record);
}
/**
 * Deserializes a previously serialized authentication record from a string into an object.
 *
 * The input string must contain the following properties:
 *
 * - "authority"
 * - "homeAccountId"
 * - "clientId"
 * - "tenantId"
 * - "username"
 * - "version"
 *
 * If the version we receive is unsupported, an error will be thrown.
 *
 * At the moment, the only available version is: "1.0", which is always set when the authentication record is serialized.
 *
 * @param serializedRecord - Authentication record previously serialized into string.
 * @returns AuthenticationRecord.
 */
function deserializeAuthenticationRecord(serializedRecord) {
    const parsed = JSON.parse(serializedRecord);
    if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
        throw Error("Unsupported AuthenticationRecord version");
    }
    return parsed;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const multiTenantDisabledErrorMessage = "A getToken request was attempted with a tenant different than the tenant configured at the initialization of the credential, but multi-tenant authentication has been disabled by the environment variable AZURE_IDENTITY_DISABLE_MULTITENANTAUTH.";
/**
 * @internal
 */
const multiTenantADFSErrorMessage = "A new tenant Id can't be assigned through the GetTokenOptions when a credential has been originally configured to use the tenant `adfs`.";
/**
 * Of getToken contains a tenantId, this functions allows picking this tenantId as the appropriate for authentication,
 * unless multitenant authentication has been disabled through the AZURE_IDENTITY_DISABLE_MULTITENANTAUTH (on Node.js),
 * or unless the original tenant Id is `adfs`.
 * @internal
 */
function processMultiTenantRequest(tenantId, getTokenOptions) {
    if (!(getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId)) {
        return tenantId;
    }
    if (process.env.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH) {
        throw new Error(multiTenantDisabledErrorMessage);
    }
    if (tenantId === "adfs") {
        throw new Error(multiTenantADFSErrorMessage);
    }
    return getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helps specify a regional authority, or "AutoDiscoverRegion" to auto-detect the region.
 */
var RegionalAuthority;
(function (RegionalAuthority) {
    /** Instructs MSAL to attempt to discover the region */
    RegionalAuthority["AutoDiscoverRegion"] = "AutoDiscoverRegion";
    /** Uses the {@link RegionalAuthority} for the Azure 'westus' region. */
    RegionalAuthority["USWest"] = "westus";
    /** Uses the {@link RegionalAuthority} for the Azure 'westus2' region. */
    RegionalAuthority["USWest2"] = "westus2";
    /** Uses the {@link RegionalAuthority} for the Azure 'centralus' region. */
    RegionalAuthority["USCentral"] = "centralus";
    /** Uses the {@link RegionalAuthority} for the Azure 'eastus' region. */
    RegionalAuthority["USEast"] = "eastus";
    /** Uses the {@link RegionalAuthority} for the Azure 'eastus2' region. */
    RegionalAuthority["USEast2"] = "eastus2";
    /** Uses the {@link RegionalAuthority} for the Azure 'northcentralus' region. */
    RegionalAuthority["USNorthCentral"] = "northcentralus";
    /** Uses the {@link RegionalAuthority} for the Azure 'southcentralus' region. */
    RegionalAuthority["USSouthCentral"] = "southcentralus";
    /** Uses the {@link RegionalAuthority} for the Azure 'westcentralus' region. */
    RegionalAuthority["USWestCentral"] = "westcentralus";
    /** Uses the {@link RegionalAuthority} for the Azure 'canadacentral' region. */
    RegionalAuthority["CanadaCentral"] = "canadacentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'canadaeast' region. */
    RegionalAuthority["CanadaEast"] = "canadaeast";
    /** Uses the {@link RegionalAuthority} for the Azure 'brazilsouth' region. */
    RegionalAuthority["BrazilSouth"] = "brazilsouth";
    /** Uses the {@link RegionalAuthority} for the Azure 'northeurope' region. */
    RegionalAuthority["EuropeNorth"] = "northeurope";
    /** Uses the {@link RegionalAuthority} for the Azure 'westeurope' region. */
    RegionalAuthority["EuropeWest"] = "westeurope";
    /** Uses the {@link RegionalAuthority} for the Azure 'uksouth' region. */
    RegionalAuthority["UKSouth"] = "uksouth";
    /** Uses the {@link RegionalAuthority} for the Azure 'ukwest' region. */
    RegionalAuthority["UKWest"] = "ukwest";
    /** Uses the {@link RegionalAuthority} for the Azure 'francecentral' region. */
    RegionalAuthority["FranceCentral"] = "francecentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'francesouth' region. */
    RegionalAuthority["FranceSouth"] = "francesouth";
    /** Uses the {@link RegionalAuthority} for the Azure 'switzerlandnorth' region. */
    RegionalAuthority["SwitzerlandNorth"] = "switzerlandnorth";
    /** Uses the {@link RegionalAuthority} for the Azure 'switzerlandwest' region. */
    RegionalAuthority["SwitzerlandWest"] = "switzerlandwest";
    /** Uses the {@link RegionalAuthority} for the Azure 'germanynorth' region. */
    RegionalAuthority["GermanyNorth"] = "germanynorth";
    /** Uses the {@link RegionalAuthority} for the Azure 'germanywestcentral' region. */
    RegionalAuthority["GermanyWestCentral"] = "germanywestcentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'norwaywest' region. */
    RegionalAuthority["NorwayWest"] = "norwaywest";
    /** Uses the {@link RegionalAuthority} for the Azure 'norwayeast' region. */
    RegionalAuthority["NorwayEast"] = "norwayeast";
    /** Uses the {@link RegionalAuthority} for the Azure 'eastasia' region. */
    RegionalAuthority["AsiaEast"] = "eastasia";
    /** Uses the {@link RegionalAuthority} for the Azure 'southeastasia' region. */
    RegionalAuthority["AsiaSouthEast"] = "southeastasia";
    /** Uses the {@link RegionalAuthority} for the Azure 'japaneast' region. */
    RegionalAuthority["JapanEast"] = "japaneast";
    /** Uses the {@link RegionalAuthority} for the Azure 'japanwest' region. */
    RegionalAuthority["JapanWest"] = "japanwest";
    /** Uses the {@link RegionalAuthority} for the Azure 'australiaeast' region. */
    RegionalAuthority["AustraliaEast"] = "australiaeast";
    /** Uses the {@link RegionalAuthority} for the Azure 'australiasoutheast' region. */
    RegionalAuthority["AustraliaSouthEast"] = "australiasoutheast";
    /** Uses the {@link RegionalAuthority} for the Azure 'australiacentral' region. */
    RegionalAuthority["AustraliaCentral"] = "australiacentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'australiacentral2' region. */
    RegionalAuthority["AustraliaCentral2"] = "australiacentral2";
    /** Uses the {@link RegionalAuthority} for the Azure 'centralindia' region. */
    RegionalAuthority["IndiaCentral"] = "centralindia";
    /** Uses the {@link RegionalAuthority} for the Azure 'southindia' region. */
    RegionalAuthority["IndiaSouth"] = "southindia";
    /** Uses the {@link RegionalAuthority} for the Azure 'westindia' region. */
    RegionalAuthority["IndiaWest"] = "westindia";
    /** Uses the {@link RegionalAuthority} for the Azure 'koreasouth' region. */
    RegionalAuthority["KoreaSouth"] = "koreasouth";
    /** Uses the {@link RegionalAuthority} for the Azure 'koreacentral' region. */
    RegionalAuthority["KoreaCentral"] = "koreacentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'uaecentral' region. */
    RegionalAuthority["UAECentral"] = "uaecentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'uaenorth' region. */
    RegionalAuthority["UAENorth"] = "uaenorth";
    /** Uses the {@link RegionalAuthority} for the Azure 'southafricanorth' region. */
    RegionalAuthority["SouthAfricaNorth"] = "southafricanorth";
    /** Uses the {@link RegionalAuthority} for the Azure 'southafricawest' region. */
    RegionalAuthority["SouthAfricaWest"] = "southafricawest";
    /** Uses the {@link RegionalAuthority} for the Azure 'chinanorth' region. */
    RegionalAuthority["ChinaNorth"] = "chinanorth";
    /** Uses the {@link RegionalAuthority} for the Azure 'chinaeast' region. */
    RegionalAuthority["ChinaEast"] = "chinaeast";
    /** Uses the {@link RegionalAuthority} for the Azure 'chinanorth2' region. */
    RegionalAuthority["ChinaNorth2"] = "chinanorth2";
    /** Uses the {@link RegionalAuthority} for the Azure 'chinaeast2' region. */
    RegionalAuthority["ChinaEast2"] = "chinaeast2";
    /** Uses the {@link RegionalAuthority} for the Azure 'germanycentral' region. */
    RegionalAuthority["GermanyCentral"] = "germanycentral";
    /** Uses the {@link RegionalAuthority} for the Azure 'germanynortheast' region. */
    RegionalAuthority["GermanyNorthEast"] = "germanynortheast";
    /** Uses the {@link RegionalAuthority} for the Azure 'usgovvirginia' region. */
    RegionalAuthority["GovernmentUSVirginia"] = "usgovvirginia";
    /** Uses the {@link RegionalAuthority} for the Azure 'usgoviowa' region. */
    RegionalAuthority["GovernmentUSIowa"] = "usgoviowa";
    /** Uses the {@link RegionalAuthority} for the Azure 'usgovarizona' region. */
    RegionalAuthority["GovernmentUSArizona"] = "usgovarizona";
    /** Uses the {@link RegionalAuthority} for the Azure 'usgovtexas' region. */
    RegionalAuthority["GovernmentUSTexas"] = "usgovtexas";
    /** Uses the {@link RegionalAuthority} for the Azure 'usdodeast' region. */
    RegionalAuthority["GovernmentUSDodEast"] = "usdodeast";
    /** Uses the {@link RegionalAuthority} for the Azure 'usdodcentral' region. */
    RegionalAuthority["GovernmentUSDodCentral"] = "usdodcentral";
})(RegionalAuthority || (RegionalAuthority = {}));

// Copyright (c) Microsoft Corporation.
/**
 * The current persistence provider, undefined by default.
 * @internal
 */
let persistenceProvider = undefined;
/**
 * An object that allows setting the persistence provider.
 * @internal
 */
const msalNodeFlowCacheControl = {
    setPersistence(pluginProvider) {
        persistenceProvider = pluginProvider;
    },
};
/**
 * MSAL partial base client for Node.js.
 *
 * It completes the input configuration with some default values.
 * It also provides with utility protected methods that can be used from any of the clients,
 * which includes handlers for successful responses and errors.
 *
 * @internal
 */
class MsalNode extends MsalBaseUtilities {
    constructor(options) {
        var _a, _b, _c;
        super(options);
        this.requiresConfidential = false;
        this.msalConfig = this.defaultNodeMsalConfig(options);
        this.tenantId = resolveTenantId(options.logger, options.tenantId, options.clientId);
        this.clientId = this.msalConfig.auth.clientId;
        if (options === null || options === void 0 ? void 0 : options.getAssertion) {
            this.getAssertion = options.getAssertion;
        }
        // If persistence has been configured
        if (persistenceProvider !== undefined && ((_a = options.tokenCachePersistenceOptions) === null || _a === void 0 ? void 0 : _a.enabled)) {
            this.createCachePlugin = () => persistenceProvider(options.tokenCachePersistenceOptions);
        }
        else if ((_b = options.tokenCachePersistenceOptions) === null || _b === void 0 ? void 0 : _b.enabled) {
            throw new Error([
                "Persistent token caching was requested, but no persistence provider was configured.",
                "You must install the identity-cache-persistence plugin package (`npm install --save @azure/identity-cache-persistence`)",
                "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
                "`useIdentityPlugin(cachePersistencePlugin)` before using `tokenCachePersistenceOptions`.",
            ].join(" "));
        }
        this.azureRegion = (_c = options.regionalAuthority) !== null && _c !== void 0 ? _c : process.env.AZURE_REGIONAL_AUTHORITY_NAME;
        if (this.azureRegion === RegionalAuthority.AutoDiscoverRegion) {
            this.azureRegion = "AUTO_DISCOVER";
        }
    }
    /**
     * Generates a MSAL configuration that generally works for Node.js
     */
    defaultNodeMsalConfig(options) {
        const clientId = options.clientId || DeveloperSignOnClientId;
        const tenantId = resolveTenantId(options.logger, options.tenantId, options.clientId);
        this.authorityHost = options.authorityHost || process.env.AZURE_AUTHORITY_HOST;
        const authority = getAuthority(tenantId, this.authorityHost);
        this.identityClient = new IdentityClient(Object.assign(Object.assign({}, options.tokenCredentialOptions), { authorityHost: authority, loggingOptions: options.loggingOptions }));
        let clientCapabilities = ["cp1"];
        if (process.env.AZURE_IDENTITY_DISABLE_CP1) {
            clientCapabilities = [];
        }
        return {
            auth: {
                clientId,
                authority,
                knownAuthorities: getKnownAuthorities(tenantId, authority),
                clientCapabilities,
            },
            // Cache is defined in this.prepare();
            system: {
                networkClient: this.identityClient,
                loggerOptions: {
                    loggerCallback: defaultLoggerCallback(options.logger),
                },
            },
        };
    }
    /**
     * Prepares the MSAL applications.
     */
    async init(options) {
        if (options === null || options === void 0 ? void 0 : options.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
                // This will abort any pending request in the IdentityClient,
                // based on the received or generated correlationId
                this.identityClient.abortRequests(options.correlationId);
            });
        }
        if (this.publicApp || this.confidentialApp) {
            return;
        }
        if (this.createCachePlugin !== undefined) {
            this.msalConfig.cache = {
                cachePlugin: await this.createCachePlugin(),
            };
        }
        this.publicApp = new msalNode__namespace.PublicClientApplication(this.msalConfig);
        if (this.getAssertion) {
            this.msalConfig.auth.clientAssertion = await this.getAssertion();
        }
        // The confidential client requires either a secret, assertion or certificate.
        if (this.msalConfig.auth.clientSecret ||
            this.msalConfig.auth.clientAssertion ||
            this.msalConfig.auth.clientCertificate) {
            this.confidentialApp = new msalNode__namespace.ConfidentialClientApplication(this.msalConfig);
        }
        else {
            if (this.requiresConfidential) {
                throw new Error("Unable to generate the MSAL confidential client. Missing either the client's secret, certificate or assertion.");
            }
        }
    }
    /**
     * Allows the cancellation of a MSAL request.
     */
    withCancellation(promise, abortSignal, onCancel) {
        return new Promise((resolve, reject) => {
            promise
                .then((msalToken) => {
                return resolve(msalToken);
            })
                .catch(reject);
            if (abortSignal) {
                abortSignal.addEventListener("abort", () => {
                    onCancel === null || onCancel === void 0 ? void 0 : onCancel();
                });
            }
        });
    }
    /**
     * Returns the existing account, attempts to load the account from MSAL.
     */
    async getActiveAccount() {
        var _a, _b, _c;
        if (this.account) {
            return this.account;
        }
        const cache = (_b = (_a = this.confidentialApp) === null || _a === void 0 ? void 0 : _a.getTokenCache()) !== null && _b !== void 0 ? _b : (_c = this.publicApp) === null || _c === void 0 ? void 0 : _c.getTokenCache();
        const accountsByTenant = await (cache === null || cache === void 0 ? void 0 : cache.getAllAccounts());
        if (!accountsByTenant) {
            return;
        }
        if (accountsByTenant.length === 1) {
            this.account = msalToPublic(this.clientId, accountsByTenant[0]);
        }
        else {
            this.logger
                .info(`More than one account was found authenticated for this Client ID and Tenant ID.
However, no "authenticationRecord" has been provided for this credential,
therefore we're unable to pick between these accounts.
A new login attempt will be requested, to ensure the correct account is picked.
To work with multiple accounts for the same Client ID and Tenant ID, please provide an "authenticationRecord" when initializing a credential to prevent this from happening.`);
            return;
        }
        return this.account;
    }
    /**
     * Attempts to retrieve a token from cache.
     */
    async getTokenSilent(scopes, options) {
        var _a, _b;
        await this.getActiveAccount();
        if (!this.account) {
            throw new AuthenticationRequiredError({
                scopes,
                getTokenOptions: options,
                message: "Silent authentication failed. We couldn't retrieve an active account from the cache.",
            });
        }
        const silentRequest = {
            // To be able to re-use the account, the Token Cache must also have been provided.
            account: publicToMsal(this.account),
            correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
            scopes,
            authority: options === null || options === void 0 ? void 0 : options.authority,
            claims: options === null || options === void 0 ? void 0 : options.claims,
        };
        try {
            this.logger.info("Attempting to acquire token silently");
            const response = (_b = (await ((_a = this.confidentialApp) === null || _a === void 0 ? void 0 : _a.acquireTokenSilent(silentRequest)))) !== null && _b !== void 0 ? _b : (await this.publicApp.acquireTokenSilent(silentRequest));
            return this.handleResult(scopes, this.clientId, response || undefined);
        }
        catch (err) {
            throw this.handleError(scopes, err, options);
        }
    }
    /**
     * Wrapper around each MSAL flow get token operation: doGetToken.
     * If disableAutomaticAuthentication is sent through the constructor, it will prevent MSAL from requesting the user input.
     */
    async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options) || this.tenantId;
        options.authority = getAuthority(tenantId, this.authorityHost);
        options.correlationId = (options === null || options === void 0 ? void 0 : options.correlationId) || this.generateUuid();
        await this.init(options);
        try {
            // MSAL now caches tokens based on their claims,
            // so now one has to keep track fo claims in order to retrieve the newer tokens from acquireTokenSilent
            // This update happened on PR: https://github.com/AzureAD/microsoft-authentication-library-for-js/pull/4533
            const optionsClaims = options.claims;
            if (optionsClaims) {
                this.cachedClaims = optionsClaims;
            }
            if (this.cachedClaims && !optionsClaims) {
                options.claims = this.cachedClaims;
            }
            // We don't return the promise since we want to catch errors right here.
            return await this.getTokenSilent(scopes, options);
        }
        catch (err) {
            if (err.name !== "AuthenticationRequiredError") {
                throw err;
            }
            if (options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication) {
                throw new AuthenticationRequiredError({
                    scopes,
                    getTokenOptions: options,
                    message: "Automatic authentication has been disabled. You may call the authentication() method.",
                });
            }
            this.logger.info(`Silent authentication failed, falling back to interactive method.`);
            return this.doGetToken(scopes, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const CommonTenantId = "common";
const AzureAccountClientId = "aebc6443-996d-45c2-90f0-388ff96faa56"; // VSC: 'aebc6443-996d-45c2-90f0-388ff96faa56'
const logger$k = credentialLogger("VisualStudioCodeCredential");
let findCredentials = undefined;
const vsCodeCredentialControl = {
    setVsCodeCredentialFinder(finder) {
        findCredentials = finder;
    },
};
// Map of unsupported Tenant IDs and the errors we will be throwing.
const unsupportedTenantIds = {
    adfs: "The VisualStudioCodeCredential does not support authentication with ADFS tenants.",
};
function checkUnsupportedTenant(tenantId) {
    // If the Tenant ID isn't supported, we throw.
    const unsupportedTenantError = unsupportedTenantIds[tenantId];
    if (unsupportedTenantError) {
        throw new CredentialUnavailableError(unsupportedTenantError);
    }
}
const mapVSCodeAuthorityHosts = {
    AzureCloud: exports.AzureAuthorityHosts.AzurePublicCloud,
    AzureChina: exports.AzureAuthorityHosts.AzureChina,
    AzureGermanCloud: exports.AzureAuthorityHosts.AzureGermany,
    AzureUSGovernment: exports.AzureAuthorityHosts.AzureGovernment,
};
/**
 * Attempts to load a specific property from the VSCode configurations of the current OS.
 * If it fails at any point, returns undefined.
 */
function getPropertyFromVSCode(property) {
    const settingsPath = ["User", "settings.json"];
    // Eventually we can add more folders for more versions of VSCode.
    const vsCodeFolder = "Code";
    const homedir = os__default["default"].homedir();
    function loadProperty(...pathSegments) {
        const fullPath = path__default["default"].join(...pathSegments, vsCodeFolder, ...settingsPath);
        const settings = JSON.parse(fs__default["default"].readFileSync(fullPath, { encoding: "utf8" }));
        return settings[property];
    }
    try {
        let appData;
        switch (process.platform) {
            case "win32":
                appData = process.env.APPDATA;
                return appData ? loadProperty(appData) : undefined;
            case "darwin":
                return loadProperty(homedir, "Library", "Application Support");
            case "linux":
                return loadProperty(homedir, ".config");
            default:
                return;
        }
    }
    catch (e) {
        logger$k.info(`Failed to load the Visual Studio Code configuration file. Error: ${e.message}`);
        return;
    }
}
/**
 * Connects to Azure using the credential provided by the VSCode extension 'Azure Account'.
 * Once the user has logged in via the extension, this credential can share the same refresh token
 * that is cached by the extension.
 */
class VisualStudioCodeCredential {
    /**
     * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
     *
     * **Note**: `VisualStudioCodeCredential` is provided by a plugin package:
     * `@azure/identity-vscode`. If this package is not installed and registered
     * using the plugin API (`useIdentityPlugin`), then authentication using
     * `VisualStudioCodeCredential` will not be available.
     *
     * @param options - Options for configuring the client which makes the authentication request.
     */
    constructor(options) {
        // We want to make sure we use the one assigned by the user on the VSCode settings.
        // Or just `AzureCloud` by default.
        this.cloudName = (getPropertyFromVSCode("azure.cloud") || "AzureCloud");
        // Picking an authority host based on the cloud name.
        const authorityHost = mapVSCodeAuthorityHosts[this.cloudName];
        this.identityClient = new IdentityClient(Object.assign({ authorityHost }, options));
        if (options && options.tenantId) {
            checkTenantId(logger$k, options.tenantId);
            this.tenantId = options.tenantId;
        }
        else {
            this.tenantId = CommonTenantId;
        }
        checkUnsupportedTenant(this.tenantId);
    }
    /**
     * Runs preparations for any further getToken request.
     */
    async prepare() {
        // Attempts to load the tenant from the VSCode configuration file.
        const settingsTenant = getPropertyFromVSCode("azure.tenant");
        if (settingsTenant) {
            this.tenantId = settingsTenant;
        }
        checkUnsupportedTenant(this.tenantId);
    }
    /**
     * Runs preparations for any further getToken, but only once.
     */
    prepareOnce() {
        if (!this.preparePromise) {
            this.preparePromise = this.prepare();
        }
        return this.preparePromise;
    }
    /**
     * Returns the token found by searching VSCode's authentication cache or
     * returns null if no token could be found.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                `TokenCredential` implementation might make.
     */
    async getToken(scopes, options) {
        var _a, _b;
        await this.prepareOnce();
        const tenantId = processMultiTenantRequest(this.tenantId, options) || this.tenantId;
        if (findCredentials === undefined) {
            throw new CredentialUnavailableError([
                "No implementation of `VisualStudioCodeCredential` is available.",
                "You must install the identity-vscode plugin package (`npm install --save-dev @azure/identity-vscode`)",
                "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
                "`useIdentityPlugin(vsCodePlugin)` before creating a `VisualStudioCodeCredential`.",
            ].join(" "));
        }
        let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
        // Check to make sure the scope we get back is a valid scope
        if (!scopeString.match(/^[0-9a-zA-Z-.:/]+$/)) {
            const error = new Error("Invalid scope was specified by the user or calling client");
            logger$k.getToken.info(formatError(scopes, error));
            throw error;
        }
        if (scopeString.indexOf("offline_access") < 0) {
            scopeString += " offline_access";
        }
        // findCredentials returns an array similar to:
        // [
        //   {
        //     account: "",
        //     password: "",
        //   },
        //   /* ... */
        // ]
        const credentials = await findCredentials();
        // If we can't find the credential based on the name, we'll pick the first one available.
        const { password: refreshToken } = (_b = (_a = credentials.find(({ account }) => account === this.cloudName)) !== null && _a !== void 0 ? _a : credentials[0]) !== null && _b !== void 0 ? _b : {};
        if (refreshToken) {
            const tokenResponse = await this.identityClient.refreshAccessToken(tenantId, AzureAccountClientId, scopeString, refreshToken, undefined);
            if (tokenResponse) {
                logger$k.getToken.info(formatSuccess(scopes));
                return tokenResponse.accessToken;
            }
            else {
                const error = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Have you connected using the 'Azure Account' extension recently? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
                logger$k.getToken.info(formatError(scopes, error));
                throw error;
            }
        }
        else {
            const error = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Did you connect using the 'Azure Account' extension? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
            logger$k.getToken.info(formatError(scopes, error));
            throw error;
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The context passed to an Identity plugin. This contains objects that
 * plugins can use to set backend implementations.
 * @internal
 */
const pluginContext = {
    cachePluginControl: msalNodeFlowCacheControl,
    vsCodeCredentialControl: vsCodeCredentialControl,
};
/**
 * Extend Azure Identity with additional functionality. Pass a plugin from
 * a plugin package, such as:
 *
 * - `@azure/identity-cache-persistence`: provides persistent token caching
 * - `@azure/identity-vscode`: provides the dependencies of
 *   `VisualStudioCodeCredential` and enables it
 *
 * Example:
 *
 * ```javascript
 * import { cachePersistencePlugin } from "@azure/identity-cache-persistence";
 *
 * import { useIdentityPlugin, DefaultAzureCredential } from "@azure/identity";
 * useIdentityPlugin(cachePersistencePlugin);
 *
 * // The plugin has the capability to extend `DefaultAzureCredential` and to
 * // add middleware to the underlying credentials, such as persistence.
 * const credential = new DefaultAzureCredential({
 *   tokenCachePersistenceOptions: {
 *     enabled: true
 *   }
 * });
 * ```
 *
 * @param plugin - the plugin to register
 */
function useIdentityPlugin(plugin) {
    plugin(pluginContext);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
const logger$j = credentialLogger("ChainedTokenCredential");
/**
 * Enables multiple `TokenCredential` implementations to be tried in order
 * until one of the getToken methods returns an access token.
 */
class ChainedTokenCredential {
    /**
     * Creates an instance of ChainedTokenCredential using the given credentials.
     *
     * @param sources - `TokenCredential` implementations to be tried in order.
     *
     * Example usage:
     * ```javascript
     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
     * ```
     */
    constructor(...sources) {
        /**
         * The message to use when the chained token fails to get a token
         */
        this.UnavailableMessage = "ChainedTokenCredential => failed to retrieve a token from the included credentials";
        this._sources = [];
        this._sources = sources;
    }
    /**
     * Returns the first access token returned by one of the chained
     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
     * when one or more credentials throws an {@link AuthenticationError} and
     * no credentials have returned an access token.
     *
     * This method is called automatically by Azure SDK client libraries. You may call this method
     * directly, but you must also handle token caching and token refreshing.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                `TokenCredential` implementation might make.
     */
    async getToken(scopes, options = {}) {
        let token = null;
        let successfulCredentialName = "";
        const errors = [];
        return tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
            for (let i = 0; i < this._sources.length && token === null; i++) {
                try {
                    token = await this._sources[i].getToken(scopes, updatedOptions);
                    successfulCredentialName = this._sources[i].constructor.name;
                }
                catch (err) {
                    if (err.name === "CredentialUnavailableError" ||
                        err.name === "AuthenticationRequiredError") {
                        errors.push(err);
                    }
                    else {
                        logger$j.getToken.info(formatError(scopes, err));
                        throw err;
                    }
                }
            }
            if (!token && errors.length > 0) {
                const err = new AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
                logger$j.getToken.info(formatError(scopes, err));
                throw err;
            }
            logger$j.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);
            if (token === null) {
                throw new CredentialUnavailableError("Failed to retrieve a valid token");
            }
            return token;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Throws if the received scope is not valid.
 * @internal
 */
function ensureValidScope(scope, logger) {
    if (!scope.match(/^[0-9a-zA-Z-.:/]+$/)) {
        const error = new Error("Invalid scope was specified by the user or calling client");
        logger.getToken.info(formatError(scope, error));
        throw error;
    }
}
/**
 * Returns the resource out of a scope.
 * @internal
 */
function getScopeResource(scope) {
    return scope.replace(/\/.default$/, "");
}

// Copyright (c) Microsoft Corporation.
/**
 * Mockable reference to the CLI credential cliCredentialFunctions
 * @internal
 */
const cliCredentialInternals = {
    /**
     * @internal
     */
    getSafeWorkingDir() {
        if (process.platform === "win32") {
            if (!process.env.SystemRoot) {
                throw new Error("Azure CLI credential expects a 'SystemRoot' environment variable");
            }
            return process.env.SystemRoot;
        }
        else {
            return "/bin";
        }
    },
    /**
     * Gets the access token from Azure CLI
     * @param resource - The resource to use when getting the token
     * @internal
     */
    async getAzureCliAccessToken(resource, tenantId) {
        let tenantSection = [];
        if (tenantId) {
            tenantSection = ["--tenant", tenantId];
        }
        return new Promise((resolve, reject) => {
            try {
                child_process__default["default"].execFile("az", [
                    "account",
                    "get-access-token",
                    "--output",
                    "json",
                    "--resource",
                    resource,
                    ...tenantSection,
                ], { cwd: cliCredentialInternals.getSafeWorkingDir(), shell: true }, (error, stdout, stderr) => {
                    resolve({ stdout: stdout, stderr: stderr, error });
                });
            }
            catch (err) {
                reject(err);
            }
        });
    },
};
const logger$i = credentialLogger("AzureCliCredential");
/**
 * This credential will use the currently logged-in user login information
 * via the Azure CLI ('az') commandline tool.
 * To do so, it will read the user access token and expire time
 * with Azure CLI command "az account get-access-token".
 */
class AzureCliCredential {
    /**
     * Creates an instance of the {@link AzureCliCredential}.
     *
     * To use this credential, ensure that you have already logged
     * in via the 'az' tool using the command "az login" from the commandline.
     *
     * @param options - Options, to optionally allow multi-tenant requests.
     */
    constructor(options) {
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options);
        if (tenantId) {
            checkTenantId(logger$i, tenantId);
        }
        const scope = typeof scopes === "string" ? scopes : scopes[0];
        logger$i.getToken.info(`Using the scope ${scope}`);
        ensureValidScope(scope, logger$i);
        const resource = getScopeResource(scope);
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
            var _a, _b, _c, _d;
            try {
                const obj = await cliCredentialInternals.getAzureCliAccessToken(resource, tenantId);
                const specificScope = (_a = obj.stderr) === null || _a === void 0 ? void 0 : _a.match("(.*)az login --scope(.*)");
                const isLoginError = ((_b = obj.stderr) === null || _b === void 0 ? void 0 : _b.match("(.*)az login(.*)")) && !specificScope;
                const isNotInstallError = ((_c = obj.stderr) === null || _c === void 0 ? void 0 : _c.match("az:(.*)not found")) || ((_d = obj.stderr) === null || _d === void 0 ? void 0 : _d.startsWith("'az' is not recognized"));
                if (isNotInstallError) {
                    const error = new CredentialUnavailableError("Azure CLI could not be found. Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.");
                    logger$i.getToken.info(formatError(scopes, error));
                    throw error;
                }
                if (isLoginError) {
                    const error = new CredentialUnavailableError("Please run 'az login' from a command prompt to authenticate before using this credential.");
                    logger$i.getToken.info(formatError(scopes, error));
                    throw error;
                }
                try {
                    const responseData = obj.stdout;
                    const response = JSON.parse(responseData);
                    logger$i.getToken.info(formatSuccess(scopes));
                    const returnValue = {
                        token: response.accessToken,
                        expiresOnTimestamp: new Date(response.expiresOn).getTime(),
                    };
                    return returnValue;
                }
                catch (e) {
                    if (obj.stderr) {
                        throw new CredentialUnavailableError(obj.stderr);
                    }
                    throw e;
                }
            }
            catch (err) {
                const error = err.name === "CredentialUnavailableError"
                    ? err
                    : new CredentialUnavailableError(err.message || "Unknown error while trying to retrieve the access token");
                logger$i.getToken.info(formatError(scopes, error));
                throw error;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Easy to mock childProcess utils.
 * @internal
 */
const processUtils = {
    /**
     * Promisifying childProcess.execFile
     * @internal
     */
    execFile(file, params, options) {
        return new Promise((resolve, reject) => {
            child_process__namespace.execFile(file, params, options, (error, stdout, stderr) => {
                if (Buffer.isBuffer(stdout)) {
                    stdout = stdout.toString("utf8");
                }
                if (Buffer.isBuffer(stderr)) {
                    stderr = stderr.toString("utf8");
                }
                if (stderr || error) {
                    reject(stderr ? new Error(stderr) : error);
                }
                else {
                    resolve(stdout);
                }
            });
        });
    },
};

// Copyright (c) Microsoft Corporation.
const logger$h = credentialLogger("AzurePowerShellCredential");
const isWindows = process.platform === "win32";
/**
 * Returns a platform-appropriate command name by appending ".exe" on Windows.
 *
 * @internal
 */
function formatCommand(commandName) {
    if (isWindows) {
        return `${commandName}.exe`;
    }
    else {
        return commandName;
    }
}
/**
 * Receives a list of commands to run, executes them, then returns the outputs.
 * If anything fails, an error is thrown.
 * @internal
 */
async function runCommands(commands) {
    const results = [];
    for (const command of commands) {
        const [file, ...parameters] = command;
        const result = (await processUtils.execFile(file, parameters, { encoding: "utf8" }));
        results.push(result);
    }
    return results;
}
/**
 * Known PowerShell errors
 * @internal
 */
const powerShellErrors = {
    login: "Run Connect-AzAccount to login",
    installed: "The specified module 'Az.Accounts' with version '2.2.0' was not loaded because no valid module file was found in any module directory",
};
/**
 * Messages to use when throwing in this credential.
 * @internal
 */
const powerShellPublicErrorMessages = {
    login: "Please run 'Connect-AzAccount' from PowerShell to authenticate before using this credential.",
    installed: `The 'Az.Account' module >= 2.2.0 is not installed. Install the Azure Az PowerShell module with: "Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force".`,
    troubleshoot: `To troubleshoot, visit https://aka.ms/azsdk/js/identity/powershellcredential/troubleshoot.`,
};
// PowerShell Azure User not logged in error check.
const isLoginError = (err) => err.message.match(`(.*)${powerShellErrors.login}(.*)`);
// Az Module not Installed in Azure PowerShell check.
const isNotInstalledError = (err) => err.message.match(powerShellErrors.installed);
/**
 * The PowerShell commands to be tried, in order.
 *
 * @internal
 */
const commandStack = [formatCommand("pwsh")];
if (isWindows) {
    commandStack.push(formatCommand("powershell"));
}
/**
 * This credential will use the currently logged-in user information from the
 * Azure PowerShell module. To do so, it will read the user access token and
 * expire time with Azure PowerShell command `Get-AzAccessToken -ResourceUrl {ResourceScope}`
 */
class AzurePowerShellCredential {
    /**
     * Creates an instance of the {@link AzurePowerShellCredential}.
     *
     * To use this credential:
     * - Install the Azure Az PowerShell module with:
     *   `Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force`.
     * - You have already logged in to Azure PowerShell using the command
     * `Connect-AzAccount` from the command line.
     *
     * @param options - Options, to optionally allow multi-tenant requests.
     */
    constructor(options) {
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
    }
    /**
     * Gets the access token from Azure PowerShell
     * @param resource - The resource to use when getting the token
     */
    async getAzurePowerShellAccessToken(resource, tenantId) {
        // Clone the stack to avoid mutating it while iterating
        for (const powerShellCommand of [...commandStack]) {
            try {
                await runCommands([[powerShellCommand, "/?"]]);
            }
            catch (e) {
                // Remove this credential from the original stack so that we don't try it again.
                commandStack.shift();
                continue;
            }
            let tenantSection = "";
            if (tenantId) {
                tenantSection = `-TenantId "${tenantId}"`;
            }
            const results = await runCommands([
                [
                    powerShellCommand,
                    "-Command",
                    "Import-Module Az.Accounts -MinimumVersion 2.2.0 -PassThru",
                ],
                [
                    powerShellCommand,
                    "-Command",
                    `Get-AzAccessToken ${tenantSection} -ResourceUrl "${resource}" | ConvertTo-Json`,
                ],
            ]);
            const result = results[1];
            try {
                return JSON.parse(result);
            }
            catch (e) {
                throw new Error(`Unable to parse the output of PowerShell. Received output: ${result}`);
            }
        }
        throw new Error(`Unable to execute PowerShell. Ensure that it is installed in your system`);
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If the authentication cannot be performed through PowerShell, a {@link CredentialUnavailableError} will be thrown.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
            const tenantId = processMultiTenantRequest(this.tenantId, options);
            if (tenantId) {
                checkTenantId(logger$h, tenantId);
            }
            const scope = typeof scopes === "string" ? scopes : scopes[0];
            ensureValidScope(scope, logger$h);
            logger$h.getToken.info(`Using the scope ${scope}`);
            const resource = getScopeResource(scope);
            try {
                const response = await this.getAzurePowerShellAccessToken(resource, tenantId);
                logger$h.getToken.info(formatSuccess(scopes));
                return {
                    token: response.Token,
                    expiresOnTimestamp: new Date(response.ExpiresOn).getTime(),
                };
            }
            catch (err) {
                if (isNotInstalledError(err)) {
                    const error = new CredentialUnavailableError(powerShellPublicErrorMessages.installed);
                    logger$h.getToken.info(formatError(scope, error));
                    throw error;
                }
                else if (isLoginError(err)) {
                    const error = new CredentialUnavailableError(powerShellPublicErrorMessages.login);
                    logger$h.getToken.info(formatError(scope, error));
                    throw error;
                }
                const error = new CredentialUnavailableError(`${err}. ${powerShellPublicErrorMessages.troubleshoot}`);
                logger$h.getToken.info(formatError(scope, error));
                throw error;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * MSAL client secret client. Calls to MSAL's confidential application's `acquireTokenByClientCredential` during `doGetToken`.
 * @internal
 */
class MsalClientSecret extends MsalNode {
    constructor(options) {
        super(options);
        this.requiresConfidential = true;
        this.msalConfig.auth.clientSecret = options.clientSecret;
    }
    async doGetToken(scopes, options = {}) {
        try {
            const result = await this.confidentialApp.acquireTokenByClientCredential({
                scopes,
                correlationId: options.correlationId,
                azureRegion: this.azureRegion,
                authority: options.authority,
                claims: options.claims,
            });
            // The Client Credential flow does not return an account,
            // so each time getToken gets called, we will have to acquire a new token through the service.
            return this.handleResult(scopes, this.clientId, result || undefined);
        }
        catch (err) {
            throw this.handleError(scopes, err, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const logger$g = credentialLogger("ClientSecretCredential");
/**
 * Enables authentication to Azure Active Directory using a client secret
 * that was generated for an App Registration. More information on how
 * to configure a client secret can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application
 *
 */
class ClientSecretCredential {
    /**
     * Creates an instance of the ClientSecretCredential with the details
     * needed to authenticate against Azure Active Directory with a client
     * secret.
     *
     * @param tenantId - The Azure Active Directory tenant (directory) ID.
     * @param clientId - The client (application) ID of an App Registration in the tenant.
     * @param clientSecret - A client secret that was generated for the App Registration.
     * @param options - Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, clientSecret, options = {}) {
        if (!tenantId || !clientId || !clientSecret) {
            throw new Error("ClientSecretCredential: tenantId, clientId, and clientSecret are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
        }
        this.msalFlow = new MsalClientSecret(Object.assign(Object.assign({}, options), { logger: logger$g,
            clientId,
            tenantId,
            clientSecret, tokenCredentialOptions: options }));
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, newOptions);
        });
    }
}

// Copyright (c) Microsoft Corporation.
const readFileAsync$2 = util.promisify(fs.readFile);
/**
 * Tries to asynchronously load a certificate from the given path.
 *
 * @param configuration - Either the PEM value or the path to the certificate.
 * @param sendCertificateChain - Option to include x5c header for SubjectName and Issuer name authorization.
 * @returns - The certificate parts, or `undefined` if the certificate could not be loaded.
 * @internal
 */
async function parseCertificate(configuration, sendCertificateChain) {
    const certificateParts = {};
    const certificate = configuration
        .certificate;
    const certificatePath = configuration
        .certificatePath;
    certificateParts.certificateContents =
        certificate || (await readFileAsync$2(certificatePath, "utf8"));
    if (sendCertificateChain) {
        certificateParts.x5c = certificateParts.certificateContents;
    }
    const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
    const publicKeys = [];
    // Match all possible certificates, in the order they are in the file. These will form the chain that is used for x5c
    let match;
    do {
        match = certificatePattern.exec(certificateParts.certificateContents);
        if (match) {
            publicKeys.push(match[3]);
        }
    } while (match);
    if (publicKeys.length === 0) {
        throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
    }
    certificateParts.thumbprint = crypto.createHash("sha1")
        .update(Buffer.from(publicKeys[0], "base64"))
        .digest("hex")
        .toUpperCase();
    return certificateParts;
}
/**
 * MSAL client certificate client. Calls to MSAL's confidential application's `acquireTokenByClientCredential` during `doGetToken`.
 * @internal
 */
class MsalClientCertificate extends MsalNode {
    constructor(options) {
        super(options);
        this.requiresConfidential = true;
        this.configuration = options.configuration;
        this.sendCertificateChain = options.sendCertificateChain;
    }
    // Changing the MSAL configuration asynchronously
    async init(options) {
        try {
            const parts = await parseCertificate(this.configuration, this.sendCertificateChain);
            this.msalConfig.auth.clientCertificate = {
                thumbprint: parts.thumbprint,
                privateKey: parts.certificateContents,
                x5c: parts.x5c,
            };
        }
        catch (error) {
            this.logger.info(formatError("", error));
            throw error;
        }
        return super.init(options);
    }
    async doGetToken(scopes, options = {}) {
        try {
            const clientCredReq = {
                scopes,
                correlationId: options.correlationId,
                azureRegion: this.azureRegion,
                authority: options.authority,
                claims: options.claims,
            };
            const result = await this.confidentialApp.acquireTokenByClientCredential(clientCredReq);
            // Even though we're providing the same default in memory persistence cache that we use for DeviceCodeCredential,
            // The Client Credential flow does not return the account information from the authentication service,
            // so each time getToken gets called, we will have to acquire a new token through the service.
            return this.handleResult(scopes, this.clientId, result || undefined);
        }
        catch (err) {
            throw this.handleError(scopes, err, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const credentialName$2 = "ClientCertificateCredential";
const logger$f = credentialLogger(credentialName$2);
/**
 * Enables authentication to Azure Active Directory using a PEM-encoded
 * certificate that is assigned to an App Registration. More information
 * on how to configure certificate authentication can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-certificate-credentials#register-your-certificate-with-azure-ad
 *
 */
class ClientCertificateCredential {
    constructor(tenantId, clientId, certificatePathOrConfiguration, options = {}) {
        if (!tenantId || !clientId) {
            throw new Error(`${credentialName$2}: tenantId and clientId are required parameters.`);
        }
        const configuration = Object.assign({}, (typeof certificatePathOrConfiguration === "string"
            ? {
                certificatePath: certificatePathOrConfiguration,
            }
            : certificatePathOrConfiguration));
        const certificate = configuration
            .certificate;
        const certificatePath = configuration.certificatePath;
        if (!configuration || !(certificate || certificatePath)) {
            throw new Error(`${credentialName$2}: Provide either a PEM certificate in string form, or the path to that certificate in the filesystem. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (certificate && certificatePath) {
            throw new Error(`${credentialName$2}: To avoid unexpected behaviors, providing both the contents of a PEM certificate and the path to a PEM certificate is forbidden. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        this.msalFlow = new MsalClientCertificate(Object.assign(Object.assign({}, options), { configuration,
            logger: logger$f,
            clientId,
            tenantId, sendCertificateChain: options.sendCertificateChain, tokenCredentialOptions: options }));
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName$2}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, newOptions);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * MSAL username and password client. Calls to the MSAL's public application's `acquireTokenByUsernamePassword` during `doGetToken`.
 * @internal
 */
class MsalUsernamePassword extends MsalNode {
    constructor(options) {
        super(options);
        this.username = options.username;
        this.password = options.password;
    }
    async doGetToken(scopes, options) {
        try {
            const requestOptions = {
                scopes,
                username: this.username,
                password: this.password,
                correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
                authority: options === null || options === void 0 ? void 0 : options.authority,
                claims: options === null || options === void 0 ? void 0 : options.claims,
            };
            const result = await this.publicApp.acquireTokenByUsernamePassword(requestOptions);
            return this.handleResult(scopes, this.clientId, result || undefined);
        }
        catch (error) {
            throw this.handleError(scopes, error, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const logger$e = credentialLogger("UsernamePasswordCredential");
/**
 * Enables authentication to Azure Active Directory with a user's
 * username and password. This credential requires a high degree of
 * trust so you should only use it when other, more secure credential
 * types can't be used.
 */
class UsernamePasswordCredential {
    /**
     * Creates an instance of the UsernamePasswordCredential with the details
     * needed to authenticate against Azure Active Directory with a username
     * and password.
     *
     * @param tenantId - The Azure Active Directory tenant (directory).
     * @param clientId - The client (application) ID of an App Registration in the tenant.
     * @param username - The user account's e-mail address (user name).
     * @param password - The user account's account password
     * @param options - Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, username, password, options = {}) {
        if (!tenantId || !clientId || !username || !password) {
            throw new Error("UsernamePasswordCredential: tenantId, clientId, username and password are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        this.msalFlow = new MsalUsernamePassword(Object.assign(Object.assign({}, options), { logger: logger$e,
            clientId,
            tenantId,
            username,
            password, tokenCredentialOptions: options || {} }));
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * If the user provided the option `disableAutomaticAuthentication`,
     * once the token can't be retrieved silently,
     * this method won't attempt to request user interaction to retrieve the token.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, newOptions);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Contains the list of all supported environment variable names so that an
 * appropriate error message can be generated when no credentials can be
 * configured.
 *
 * @internal
 */
const AllSupportedEnvironmentVariables = [
    "AZURE_TENANT_ID",
    "AZURE_CLIENT_ID",
    "AZURE_CLIENT_SECRET",
    "AZURE_CLIENT_CERTIFICATE_PATH",
    "AZURE_USERNAME",
    "AZURE_PASSWORD",
];
const credentialName$1 = "EnvironmentCredential";
const logger$d = credentialLogger(credentialName$1);
/**
 * Enables authentication to Azure Active Directory using client secret
 * details configured in environment variables
 */
class EnvironmentCredential {
    /**
     * Creates an instance of the EnvironmentCredential class and decides what credential to use depending on the available environment variables.
     *
     * Required environment variables:
     * - `AZURE_TENANT_ID`: The Azure Active Directory tenant (directory) ID.
     * - `AZURE_CLIENT_ID`: The client (application) ID of an App Registration in the tenant.
     *
     * Environment variables used for client credential authentication:
     * - `AZURE_CLIENT_SECRET`: A client secret that was generated for the App Registration.
     * - `AZURE_CLIENT_CERTIFICATE_PATH`: The path to a PEM certificate to use during the authentication, instead of the client secret.
     *
     * Alternatively, users can provide environment variables for username and password authentication:
     * - `AZURE_USERNAME`: Username to authenticate with.
     * - `AZURE_PASSWORD`: Password to authenticate with.
     *
     * If the environment variables required to perform the authentication are missing, a {@link CredentialUnavailableError} will be thrown.
     * If the authentication fails, or if there's an unknown error, an {@link AuthenticationError} will be thrown.
     *
     * @param options - Options for configuring the client which makes the authentication request.
     */
    constructor(options) {
        // Keep track of any missing environment variables for error details
        this._credential = undefined;
        const assigned = processEnvVars(AllSupportedEnvironmentVariables).assigned.join(", ");
        logger$d.info(`Found the following environment variables: ${assigned}`);
        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
        if (tenantId) {
            checkTenantId(logger$d, tenantId);
        }
        if (tenantId && clientId && clientSecret) {
            logger$d.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
            this._credential = new ClientSecretCredential(tenantId, clientId, clientSecret, options);
            return;
        }
        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
        if (tenantId && clientId && certificatePath) {
            logger$d.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
            this._credential = new ClientCertificateCredential(tenantId, clientId, { certificatePath }, options);
            return;
        }
        const username = process.env.AZURE_USERNAME;
        const password = process.env.AZURE_PASSWORD;
        if (tenantId && clientId && username && password) {
            logger$d.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
            this._credential = new UsernamePasswordCredential(tenantId, clientId, username, password, options);
        }
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - Optional parameters. See {@link GetTokenOptions}.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName$1}.getToken`, options, async (newOptions) => {
            if (this._credential) {
                try {
                    const result = await this._credential.getToken(scopes, newOptions);
                    logger$d.getToken.info(formatSuccess(scopes));
                    return result;
                }
                catch (err) {
                    const authenticationError = new AuthenticationError(400, {
                        error: `${credentialName$1} authentication failed. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`,
                        error_description: err.message.toString().split("More details:").join(""),
                    });
                    logger$d.getToken.info(formatError(scopes, authenticationError));
                    throw authenticationError;
                }
            }
            throw new CredentialUnavailableError(`${credentialName$1} is unavailable. No underlying credential could be used. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const DefaultScopeSuffix = "/.default";
const imdsHost = "http://169.254.169.254";
const imdsEndpointPath = "/metadata/identity/oauth2/token";
const imdsApiVersion = "2018-02-01";
const azureArcAPIVersion = "2019-11-01";
const azureFabricVersion = "2019-07-01-preview";

// Copyright (c) Microsoft Corporation.
/**
 * Most MSIs send requests to the IMDS endpoint, or a similar endpoint.
 * These are GET requests that require sending a `resource` parameter on the query.
 * This resource can be derived from the scopes received through the getToken call, as long as only one scope is received.
 * Multiple scopes assume that the resulting token will have access to multiple resources, which won't be the case.
 *
 * For that reason, when we encounter multiple scopes, we return undefined.
 * It's up to the individual MSI implementations to throw the errors (which helps us provide less generic errors).
 */
function mapScopesToResource(scopes) {
    let scope = "";
    if (Array.isArray(scopes)) {
        if (scopes.length !== 1) {
            return;
        }
        scope = scopes[0];
    }
    else if (typeof scopes === "string") {
        scope = scopes;
    }
    if (!scope.endsWith(DefaultScopeSuffix)) {
        return scope;
    }
    return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
}

// Copyright (c) Microsoft Corporation.
const msiName$6 = "ManagedIdentityCredential - AppServiceMSI 2017";
const logger$c = credentialLogger(msiName$6);
/**
 * Formats the expiration date of the received token into the number of milliseconds between that date and midnight, January 1, 1970.
 */
function expiresOnParser$3(requestBody) {
    // App Service always returns string expires_on values.
    return Date.parse(requestBody.expires_on);
}
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions$6(scopes, clientId) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
        throw new Error(`${msiName$6}: Multiple scopes are not supported.`);
    }
    const queryParameters = {
        resource,
        "api-version": "2017-09-01",
    };
    if (clientId) {
        queryParameters.clientid = clientId;
    }
    const query = new URLSearchParams(queryParameters);
    // This error should not bubble up, since we verify that this environment variable is defined in the isAvailable() method defined below.
    if (!process.env.MSI_ENDPOINT) {
        throw new Error(`${msiName$6}: Missing environment variable: MSI_ENDPOINT`);
    }
    if (!process.env.MSI_SECRET) {
        throw new Error(`${msiName$6}: Missing environment variable: MSI_SECRET`);
    }
    return {
        url: `${process.env.MSI_ENDPOINT}?${query.toString()}`,
        method: "GET",
        headers: coreRestPipeline.createHttpHeaders({
            Accept: "application/json",
            secret: process.env.MSI_SECRET,
        }),
    };
}
/**
 * Defines how to determine whether the Azure App Service MSI is available, and also how to retrieve a token from the Azure App Service MSI.
 */
const appServiceMsi2017 = {
    async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
            logger$c.info(`${msiName$6}: Unavailable. Multiple scopes are not supported.`);
            return false;
        }
        const env = process.env;
        const result = Boolean(env.MSI_ENDPOINT && env.MSI_SECRET);
        if (!result) {
            logger$c.info(`${msiName$6}: Unavailable. The environment variables needed are: MSI_ENDPOINT and MSI_SECRET.`);
        }
        return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (resourceId) {
            logger$c.warning(`${msiName$6}: managed Identity by resource Id is not supported. Argument resourceId might be ignored by the service.`);
        }
        logger$c.info(`${msiName$6}: Using the endpoint and the secret coming form the environment variables: MSI_ENDPOINT=${process.env.MSI_ENDPOINT} and MSI_SECRET=[REDACTED].`);
        const request = coreRestPipeline.createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$6(scopes, clientId)), { 
            // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
            allowInsecureConnection: true }));
        const tokenResponse = await identityClient.sendTokenRequest(request, expiresOnParser$3);
        return (tokenResponse && tokenResponse.accessToken) || null;
    },
};

// Copyright (c) Microsoft Corporation.
const msiName$5 = "ManagedIdentityCredential - CloudShellMSI";
const logger$b = credentialLogger(msiName$5);
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions$5(scopes, clientId, resourceId) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
        throw new Error(`${msiName$5}: Multiple scopes are not supported.`);
    }
    const body = {
        resource,
    };
    if (clientId) {
        body.client_id = clientId;
    }
    if (resourceId) {
        body.msi_res_id = resourceId;
    }
    // This error should not bubble up, since we verify that this environment variable is defined in the isAvailable() method defined below.
    if (!process.env.MSI_ENDPOINT) {
        throw new Error(`${msiName$5}: Missing environment variable: MSI_ENDPOINT`);
    }
    const params = new URLSearchParams(body);
    return {
        url: process.env.MSI_ENDPOINT,
        method: "POST",
        body: params.toString(),
        headers: coreRestPipeline.createHttpHeaders({
            Accept: "application/json",
            Metadata: "true",
            "Content-Type": "application/x-www-form-urlencoded",
        }),
    };
}
/**
 * Defines how to determine whether the Azure Cloud Shell MSI is available, and also how to retrieve a token from the Azure Cloud Shell MSI.
 * Since Azure Managed Identities aren't available in the Azure Cloud Shell, we log a warning for users that try to access cloud shell using user assigned identity.
 */
const cloudShellMsi = {
    async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
            logger$b.info(`${msiName$5}: Unavailable. Multiple scopes are not supported.`);
            return false;
        }
        const result = Boolean(process.env.MSI_ENDPOINT);
        if (!result) {
            logger$b.info(`${msiName$5}: Unavailable. The environment variable MSI_ENDPOINT is needed.`);
        }
        return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (clientId) {
            logger$b.warning(`${msiName$5}: user-assigned identities not supported. The argument clientId might be ignored by the service.`);
        }
        if (resourceId) {
            logger$b.warning(`${msiName$5}: user defined managed Identity by resource Id not supported. The argument resourceId might be ignored by the service.`);
        }
        logger$b.info(`${msiName$5}: Using the endpoint coming form the environment variable MSI_ENDPOINT = ${process.env.MSI_ENDPOINT}.`);
        const request = coreRestPipeline.createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$5(scopes, clientId, resourceId)), { 
            // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
            allowInsecureConnection: true }));
        const tokenResponse = await identityClient.sendTokenRequest(request);
        return (tokenResponse && tokenResponse.accessToken) || null;
    },
};

// Copyright (c) Microsoft Corporation.
const msiName$4 = "ManagedIdentityCredential - IMDS";
const logger$a = credentialLogger(msiName$4);
/**
 * Formats the expiration date of the received token into the number of milliseconds between that date and midnight, January 1, 1970.
 */
function expiresOnParser$2(requestBody) {
    if (requestBody.expires_on) {
        // Use the expires_on timestamp if it's available
        const expires = +requestBody.expires_on * 1000;
        logger$a.info(`${msiName$4}: Using expires_on: ${expires} (original value: ${requestBody.expires_on})`);
        return expires;
    }
    else {
        // If these aren't possible, use expires_in and calculate a timestamp
        const expires = Date.now() + requestBody.expires_in * 1000;
        logger$a.info(`${msiName$4}: IMDS using expires_in: ${expires} (original value: ${requestBody.expires_in})`);
        return expires;
    }
}
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions$4(scopes, clientId, resourceId, options) {
    var _a;
    const resource = mapScopesToResource(scopes);
    if (!resource) {
        throw new Error(`${msiName$4}: Multiple scopes are not supported.`);
    }
    const { skipQuery, skipMetadataHeader } = options || {};
    let query = "";
    // Pod Identity will try to process this request even if the Metadata header is missing.
    // We can exclude the request query to ensure no IMDS endpoint tries to process the ping request.
    if (!skipQuery) {
        const queryParameters = {
            resource,
            "api-version": imdsApiVersion,
        };
        if (clientId) {
            queryParameters.client_id = clientId;
        }
        if (resourceId) {
            queryParameters.msi_res_id = resourceId;
        }
        const params = new URLSearchParams(queryParameters);
        query = `?${params.toString()}`;
    }
    const url = new URL(imdsEndpointPath, (_a = process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) !== null && _a !== void 0 ? _a : imdsHost);
    const rawHeaders = {
        Accept: "application/json",
        Metadata: "true",
    };
    // Remove the Metadata header to invoke a request error from some IMDS endpoints.
    if (skipMetadataHeader) {
        delete rawHeaders.Metadata;
    }
    return {
        // In this case, the `?` should be added in the "query" variable `skipQuery` is not set.
        url: `${url}${query}`,
        method: "GET",
        headers: coreRestPipeline.createHttpHeaders(rawHeaders),
    };
}
// 800ms -> 1600ms -> 3200ms
const imdsMsiRetryConfig = {
    maxRetries: 3,
    startDelayInMs: 800,
    intervalIncrement: 2,
};
/**
 * Defines how to determine whether the Azure IMDS MSI is available, and also how to retrieve a token from the Azure IMDS MSI.
 */
const imdsMsi = {
    async isAvailable({ scopes, identityClient, clientId, resourceId, getTokenOptions = {}, }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
            logger$a.info(`${msiName$4}: Unavailable. Multiple scopes are not supported.`);
            return false;
        }
        // if the PodIdentityEndpoint environment variable was set no need to probe the endpoint, it can be assumed to exist
        if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
            return true;
        }
        if (!identityClient) {
            throw new Error("Missing IdentityClient");
        }
        const requestOptions = prepareRequestOptions$4(resource, clientId, resourceId, {
            skipMetadataHeader: true,
            skipQuery: true,
        });
        return tracingClient.withSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions, async (options) => {
            var _a, _b;
            requestOptions.tracingOptions = options.tracingOptions;
            try {
                // Create a request with a timeout since we expect that
                // not having a "Metadata" header should cause an error to be
                // returned quickly from the endpoint, proving its availability.
                const request = coreRestPipeline.createPipelineRequest(requestOptions);
                request.timeout = (_b = (_a = options.requestOptions) === null || _a === void 0 ? void 0 : _a.timeout) !== null && _b !== void 0 ? _b : 300;
                // This MSI uses the imdsEndpoint to get the token, which only uses http://
                request.allowInsecureConnection = true;
                try {
                    logger$a.info(`${msiName$4}: Pinging the Azure IMDS endpoint`);
                    await identityClient.sendRequest(request);
                }
                catch (err) {
                    if ((err.name === "RestError" && err.code === coreRestPipeline.RestError.REQUEST_SEND_ERROR) ||
                        err.name === "AbortError" ||
                        err.code === "ENETUNREACH" || // Network unreachable
                        err.code === "ECONNREFUSED" || // connection refused
                        err.code === "EHOSTDOWN" // host is down
                    ) {
                        // If the request failed, or Node.js was unable to establish a connection,
                        // or the host was down, we'll assume the IMDS endpoint isn't available.
                        logger$a.info(`${msiName$4}: The Azure IMDS endpoint is unavailable`);
                        return false;
                    }
                }
                // If we received any response, the endpoint is available
                logger$a.info(`${msiName$4}: The Azure IMDS endpoint is available`);
                return true;
            }
            catch (err) {
                // createWebResource failed.
                // This error should bubble up to the user.
                logger$a.info(`${msiName$4}: Error when creating the WebResource for the Azure IMDS endpoint: ${err.message}`);
                throw err;
            }
        });
    },
    async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        logger$a.info(`${msiName$4}: Using the Azure IMDS endpoint coming from the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`);
        let nextDelayInMs = imdsMsiRetryConfig.startDelayInMs;
        for (let retries = 0; retries < imdsMsiRetryConfig.maxRetries; retries++) {
            try {
                const request = coreRestPipeline.createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$4(scopes, clientId, resourceId)), { allowInsecureConnection: true }));
                const tokenResponse = await identityClient.sendTokenRequest(request, expiresOnParser$2);
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (error) {
                if (error.statusCode === 404) {
                    await coreUtil.delay(nextDelayInMs);
                    nextDelayInMs *= imdsMsiRetryConfig.intervalIncrement;
                    continue;
                }
                throw error;
            }
        }
        throw new AuthenticationError(404, `${msiName$4}: Failed to retrieve IMDS token after ${imdsMsiRetryConfig.maxRetries} retries.`);
    },
};

// Copyright (c) Microsoft Corporation.
const msiName$3 = "ManagedIdentityCredential - Azure Arc MSI";
const logger$9 = credentialLogger(msiName$3);
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions$3(scopes, clientId, resourceId) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
        throw new Error(`${msiName$3}: Multiple scopes are not supported.`);
    }
    const queryParameters = {
        resource,
        "api-version": azureArcAPIVersion,
    };
    if (clientId) {
        queryParameters.client_id = clientId;
    }
    if (resourceId) {
        queryParameters.msi_res_id = resourceId;
    }
    // This error should not bubble up, since we verify that this environment variable is defined in the isAvailable() method defined below.
    if (!process.env.IDENTITY_ENDPOINT) {
        throw new Error(`${msiName$3}: Missing environment variable: IDENTITY_ENDPOINT`);
    }
    const query = new URLSearchParams(queryParameters);
    return coreRestPipeline.createPipelineRequest({
        // Should be similar to: http://localhost:40342/metadata/identity/oauth2/token
        url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
        method: "GET",
        headers: coreRestPipeline.createHttpHeaders({
            Accept: "application/json",
            Metadata: "true",
        }),
    });
}
/**
 * Retrieves the file contents at the given path using promises.
 * Useful since `fs`'s readFileSync locks the thread, and to avoid extra dependencies.
 */
function readFileAsync$1(path, options) {
    return new Promise((resolve, reject) => fs.readFile(path, options, (err, data) => {
        if (err) {
            reject(err);
        }
        resolve(data);
    }));
}
/**
 * Does a request to the authentication provider that results in a file path.
 */
async function filePathRequest(identityClient, requestPrepareOptions) {
    const response = await identityClient.sendRequest(coreRestPipeline.createPipelineRequest(requestPrepareOptions));
    if (response.status !== 401) {
        let message = "";
        if (response.bodyAsText) {
            message = ` Response: ${response.bodyAsText}`;
        }
        throw new AuthenticationError(response.status, `${msiName$3}: To authenticate with Azure Arc MSI, status code 401 is expected on the first request. ${message}`);
    }
    const authHeader = response.headers.get("www-authenticate") || "";
    try {
        return authHeader.split("=").slice(1)[0];
    }
    catch (e) {
        throw Error(`Invalid www-authenticate header format: ${authHeader}`);
    }
}
/**
 * Defines how to determine whether the Azure Arc MSI is available, and also how to retrieve a token from the Azure Arc MSI.
 */
const arcMsi = {
    async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
            logger$9.info(`${msiName$3}: Unavailable. Multiple scopes are not supported.`);
            return false;
        }
        const result = Boolean(process.env.IMDS_ENDPOINT && process.env.IDENTITY_ENDPOINT);
        if (!result) {
            logger$9.info(`${msiName$3}: The environment variables needed are: IMDS_ENDPOINT and IDENTITY_ENDPOINT`);
        }
        return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
        var _a;
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (clientId) {
            logger$9.warning(`${msiName$3}: user-assigned identities not supported. The argument clientId might be ignored by the service.`);
        }
        if (resourceId) {
            logger$9.warning(`${msiName$3}: user defined managed Identity by resource Id is not supported. Argument resourceId will be ignored.`);
        }
        logger$9.info(`${msiName$3}: Authenticating.`);
        const requestOptions = Object.assign(Object.assign({ disableJsonStringifyOnBody: true, deserializationMapper: undefined, abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$3(scopes, clientId, resourceId)), { allowInsecureConnection: true });
        const filePath = await filePathRequest(identityClient, requestOptions);
        if (!filePath) {
            throw new Error(`${msiName$3}: Failed to find the token file.`);
        }
        const key = await readFileAsync$1(filePath, { encoding: "utf-8" });
        (_a = requestOptions.headers) === null || _a === void 0 ? void 0 : _a.set("Authorization", `Basic ${key}`);
        const request = coreRestPipeline.createPipelineRequest(Object.assign(Object.assign({}, requestOptions), { 
            // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
            allowInsecureConnection: true }));
        const tokenResponse = await identityClient.sendTokenRequest(request);
        return (tokenResponse && tokenResponse.accessToken) || null;
    },
};

// Copyright (c) Microsoft Corporation.
const msiName$2 = "ManagedIdentityCredential - Token Exchange";
const logger$8 = credentialLogger(msiName$2);
const readFileAsync = util.promisify(fs__default["default"].readFile);
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions$2(scopes, clientAssertion, clientId) {
    var _a;
    const bodyParams = {
        scope: Array.isArray(scopes) ? scopes.join(" ") : scopes,
        client_assertion: clientAssertion,
        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
        client_id: clientId,
        grant_type: "client_credentials",
    };
    const urlParams = new URLSearchParams(bodyParams);
    const url = new URL(`${process.env.AZURE_TENANT_ID}/oauth2/v2.0/token`, (_a = process.env.AZURE_AUTHORITY_HOST) !== null && _a !== void 0 ? _a : DefaultAuthorityHost);
    return {
        url: url.toString(),
        method: "POST",
        body: urlParams.toString(),
        headers: coreRestPipeline.createHttpHeaders({
            Accept: "application/json",
        }),
    };
}
/**
 * Defines how to determine whether the token exchange MSI is available, and also how to retrieve a token from the token exchange MSI.
 */
function tokenExchangeMsi() {
    const azureFederatedTokenFilePath = process.env.AZURE_FEDERATED_TOKEN_FILE;
    let azureFederatedTokenFileContent = undefined;
    let cacheDate = undefined;
    // Only reads from the assertion file once every 5 minutes
    async function readAssertion() {
        // Cached assertions expire after 5 minutes
        if (cacheDate !== undefined && Date.now() - cacheDate >= 1000 * 60 * 5) {
            azureFederatedTokenFileContent = undefined;
        }
        if (!azureFederatedTokenFileContent) {
            const file = await readFileAsync(azureFederatedTokenFilePath, "utf8");
            const value = file.trim();
            if (!value) {
                throw new Error(`No content on the file ${azureFederatedTokenFilePath}, indicated by the environment variable AZURE_FEDERATED_TOKEN_FILE`);
            }
            else {
                azureFederatedTokenFileContent = value;
                cacheDate = Date.now();
            }
        }
        return azureFederatedTokenFileContent;
    }
    return {
        async isAvailable({ clientId }) {
            const env = process.env;
            const result = Boolean((clientId || env.AZURE_CLIENT_ID) && env.AZURE_TENANT_ID && azureFederatedTokenFilePath);
            if (!result) {
                logger$8.info(`${msiName$2}: Unavailable. The environment variables needed are: AZURE_CLIENT_ID (or the client ID sent through the parameters), AZURE_TENANT_ID and AZURE_FEDERATED_TOKEN_FILE`);
            }
            return result;
        },
        async getToken(configuration, getTokenOptions = {}) {
            const { identityClient, scopes, clientId } = configuration;
            logger$8.info(`${msiName$2}: Using the client assertion coming from environment variables.`);
            let assertion;
            try {
                assertion = await readAssertion();
            }
            catch (err) {
                throw new Error(`${msiName$2}: Failed to read ${azureFederatedTokenFilePath}, indicated by the environment variable AZURE_FEDERATED_TOKEN_FILE`);
            }
            const request = coreRestPipeline.createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$2(scopes, assertion, clientId || process.env.AZURE_CLIENT_ID)), { 
                // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
                allowInsecureConnection: true }));
            const tokenResponse = await identityClient.sendTokenRequest(request);
            return (tokenResponse && tokenResponse.accessToken) || null;
        },
    };
}

// Copyright (c) Microsoft Corporation.
// This MSI can be easily tested by deploying a container to Azure Service Fabric with the Dockerfile:
//
//   FROM node:12
//   RUN wget https://host.any/path/bash.sh
//   CMD ["bash", "bash.sh"]
//
// Where the bash script contains:
//
//   curl --insecure $IDENTITY_ENDPOINT'?api-version=2019-07-01-preview&resource=https://vault.azure.net/' -H "Secret: $IDENTITY_HEADER"
//
const msiName$1 = "ManagedIdentityCredential - Fabric MSI";
const logger$7 = credentialLogger(msiName$1);
/**
 * Formats the expiration date of the received token into the number of milliseconds between that date and midnight, January 1, 1970.
 */
function expiresOnParser$1(requestBody) {
    // Parses a string representation of the milliseconds since epoch into a number value
    return Number(requestBody.expires_on);
}
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions$1(scopes, clientId, resourceId) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
        throw new Error(`${msiName$1}: Multiple scopes are not supported.`);
    }
    const queryParameters = {
        resource,
        "api-version": azureFabricVersion,
    };
    if (clientId) {
        queryParameters.client_id = clientId;
    }
    if (resourceId) {
        queryParameters.msi_res_id = resourceId;
    }
    const query = new URLSearchParams(queryParameters);
    // This error should not bubble up, since we verify that this environment variable is defined in the isAvailable() method defined below.
    if (!process.env.IDENTITY_ENDPOINT) {
        throw new Error("Missing environment variable: IDENTITY_ENDPOINT");
    }
    if (!process.env.IDENTITY_HEADER) {
        throw new Error("Missing environment variable: IDENTITY_HEADER");
    }
    return {
        url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
        method: "GET",
        headers: coreRestPipeline.createHttpHeaders({
            Accept: "application/json",
            secret: process.env.IDENTITY_HEADER,
        }),
    };
}
/**
 * Defines how to determine whether the Azure Service Fabric MSI is available, and also how to retrieve a token from the Azure Service Fabric MSI.
 */
const fabricMsi = {
    async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
            logger$7.info(`${msiName$1}: Unavailable. Multiple scopes are not supported.`);
            return false;
        }
        const env = process.env;
        const result = Boolean(env.IDENTITY_ENDPOINT && env.IDENTITY_HEADER && env.IDENTITY_SERVER_THUMBPRINT);
        if (!result) {
            logger$7.info(`${msiName$1}: Unavailable. The environment variables needed are: IDENTITY_ENDPOINT, IDENTITY_HEADER and IDENTITY_SERVER_THUMBPRINT`);
        }
        return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
        const { scopes, identityClient, clientId, resourceId } = configuration;
        if (resourceId) {
            logger$7.warning(`${msiName$1}: user defined managed Identity by resource Id is not supported. Argument resourceId might be ignored by the service.`);
        }
        logger$7.info([
            `${msiName$1}:`,
            "Using the endpoint and the secret coming from the environment variables:",
            `IDENTITY_ENDPOINT=${process.env.IDENTITY_ENDPOINT},`,
            "IDENTITY_HEADER=[REDACTED] and",
            "IDENTITY_SERVER_THUMBPRINT=[REDACTED].",
        ].join(" "));
        const request = coreRestPipeline.createPipelineRequest(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$1(scopes, clientId, resourceId)));
        request.agent = new https__default["default"].Agent({
            // This is necessary because Service Fabric provides a self-signed certificate.
            // The alternative path is to verify the certificate using the IDENTITY_SERVER_THUMBPRINT env variable.
            rejectUnauthorized: false,
        });
        const tokenResponse = await identityClient.sendTokenRequest(request, expiresOnParser$1);
        return (tokenResponse && tokenResponse.accessToken) || null;
    },
};

// Copyright (c) Microsoft Corporation.
const msiName = "ManagedIdentityCredential - AppServiceMSI 2019";
const logger$6 = credentialLogger(msiName);
/**
 * Formats the expiration date of the received token into the number of milliseconds between that date and midnight, January 1, 1970.
 */
function expiresOnParser(requestBody) {
    // App Service always returns string expires_on values.
    return Date.parse(requestBody.expires_on);
}
/**
 * Generates the options used on the request for an access token.
 */
function prepareRequestOptions(scopes, clientId, resourceId) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
        throw new Error(`${msiName}: Multiple scopes are not supported.`);
    }
    const queryParameters = {
        resource,
        "api-version": "2019-08-01",
    };
    if (clientId) {
        queryParameters.client_id = clientId;
    }
    if (resourceId) {
        queryParameters.mi_res_id = resourceId;
    }
    const query = new URLSearchParams(queryParameters);
    // This error should not bubble up, since we verify that this environment variable is defined in the isAvailable() method defined below.
    if (!process.env.IDENTITY_ENDPOINT) {
        throw new Error(`${msiName}: Missing environment variable: IDENTITY_ENDPOINT`);
    }
    if (!process.env.IDENTITY_HEADER) {
        throw new Error(`${msiName}: Missing environment variable: IDENTITY_HEADER`);
    }
    return {
        url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
        method: "GET",
        headers: coreRestPipeline.createHttpHeaders({
            Accept: "application/json",
            "X-IDENTITY-HEADER": process.env.IDENTITY_HEADER,
        }),
    };
}
/**
 * Defines how to determine whether the Azure App Service MSI is available, and also how to retrieve a token from the Azure App Service MSI.
 */
const appServiceMsi2019 = {
    async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
            logger$6.info(`${msiName}: Unavailable. Multiple scopes are not supported.`);
            return false;
        }
        const env = process.env;
        const result = Boolean(env.IDENTITY_ENDPOINT && env.IDENTITY_HEADER);
        if (!result) {
            logger$6.info(`${msiName}: Unavailable. The environment variables needed are: IDENTITY_ENDPOINT and IDENTITY_HEADER.`);
        }
        return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        logger$6.info(`${msiName}: Using the endpoint and the secret coming form the environment variables: IDENTITY_ENDPOINT=${process.env.IDENTITY_ENDPOINT} and IDENTITY_HEADER=[REDACTED].`);
        const request = coreRestPipeline.createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions(scopes, clientId, resourceId)), { 
            // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
            allowInsecureConnection: true }));
        const tokenResponse = await identityClient.sendTokenRequest(request, expiresOnParser);
        return (tokenResponse && tokenResponse.accessToken) || null;
    },
};

// Copyright (c) Microsoft Corporation.
const logger$5 = credentialLogger("ManagedIdentityCredential");
/**
 * Attempts authentication using a managed identity available at the deployment environment.
 * This authentication type works in Azure VMs, App Service instances, Azure Functions applications,
 * Azure Kubernetes Services, Azure Service Fabric instances and inside of the Azure Cloud Shell.
 *
 * More information about configuring managed identities can be found here:
 * https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
 */
class ManagedIdentityCredential {
    /**
     * @internal
     * @hidden
     */
    constructor(clientIdOrOptions, options) {
        this.isEndpointUnavailable = null;
        let _options;
        if (typeof clientIdOrOptions === "string") {
            this.clientId = clientIdOrOptions;
            _options = options;
        }
        else {
            this.clientId = clientIdOrOptions === null || clientIdOrOptions === void 0 ? void 0 : clientIdOrOptions.clientId;
            _options = clientIdOrOptions;
        }
        this.resourceId = _options === null || _options === void 0 ? void 0 : _options.resourceId;
        // For JavaScript users.
        if (this.clientId && this.resourceId) {
            throw new Error(`${ManagedIdentityCredential.name} - Client Id and Resource Id can't be provided at the same time.`);
        }
        this.identityClient = new IdentityClient(_options);
        this.isAvailableIdentityClient = new IdentityClient(Object.assign(Object.assign({}, _options), { retryOptions: {
                maxRetries: 0,
            } }));
    }
    async cachedAvailableMSI(scopes, getTokenOptions) {
        if (this.cachedMSI) {
            return this.cachedMSI;
        }
        const MSIs = [
            arcMsi,
            fabricMsi,
            appServiceMsi2019,
            appServiceMsi2017,
            cloudShellMsi,
            tokenExchangeMsi(),
            imdsMsi,
        ];
        for (const msi of MSIs) {
            if (await msi.isAvailable({
                scopes,
                identityClient: this.isAvailableIdentityClient,
                clientId: this.clientId,
                resourceId: this.resourceId,
                getTokenOptions,
            })) {
                this.cachedMSI = msi;
                return msi;
            }
        }
        throw new CredentialUnavailableError(`${ManagedIdentityCredential.name} - No MSI credential available`);
    }
    async authenticateManagedIdentity(scopes, getTokenOptions) {
        const { span, updatedOptions } = tracingClient.startSpan(`${ManagedIdentityCredential.name}.authenticateManagedIdentity`, getTokenOptions);
        try {
            // Determining the available MSI, and avoiding checking for other MSIs while the program is running.
            const availableMSI = await this.cachedAvailableMSI(scopes, updatedOptions);
            return availableMSI.getToken({
                identityClient: this.identityClient,
                scopes,
                clientId: this.clientId,
                resourceId: this.resourceId,
            }, updatedOptions);
        }
        catch (err) {
            span.setStatus({
                status: "error",
                error: err,
            });
            throw err;
        }
        finally {
            span.end();
        }
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options) {
        let result = null;
        const { span, updatedOptions } = tracingClient.startSpan(`${ManagedIdentityCredential.name}.getToken`, options);
        try {
            // isEndpointAvailable can be true, false, or null,
            // If it's null, it means we don't yet know whether
            // the endpoint is available and need to check for it.
            if (this.isEndpointUnavailable !== true) {
                result = await this.authenticateManagedIdentity(scopes, updatedOptions);
                if (result === null) {
                    // If authenticateManagedIdentity returns null,
                    // it means no MSI endpoints are available.
                    // If so, we avoid trying to reach to them in future requests.
                    this.isEndpointUnavailable = true;
                    // It also means that the endpoint answered with either 200 or 201 (see the sendTokenRequest method),
                    // yet we had no access token. For this reason, we'll throw once with a specific message:
                    const error = new CredentialUnavailableError("The managed identity endpoint was reached, yet no tokens were received.");
                    logger$5.getToken.info(formatError(scopes, error));
                    throw error;
                }
                // Since `authenticateManagedIdentity` didn't throw, and the result was not null,
                // We will assume that this endpoint is reachable from this point forward,
                // and avoid pinging again to it.
                this.isEndpointUnavailable = false;
            }
            else {
                // We've previously determined that the endpoint was unavailable,
                // either because it was unreachable or permanently unable to authenticate.
                const error = new CredentialUnavailableError("The managed identity endpoint is not currently available");
                logger$5.getToken.info(formatError(scopes, error));
                throw error;
            }
            logger$5.getToken.info(formatSuccess(scopes));
            return result;
        }
        catch (err) {
            // CredentialUnavailable errors are expected to reach here.
            // We intend them to bubble up, so that DefaultAzureCredential can catch them.
            if (err.name === "AuthenticationRequiredError") {
                throw err;
            }
            // Expected errors to reach this point:
            // - Errors coming from a method unexpectedly breaking.
            // - When identityClient.sendTokenRequest throws, in which case
            //   if the status code was 400, it means that the endpoint is working,
            //   but no identity is available.
            span.setStatus({
                status: "error",
                error: err,
            });
            // If either the network is unreachable,
            // we can safely assume the credential is unavailable.
            if (err.code === "ENETUNREACH") {
                const error = new CredentialUnavailableError(`${ManagedIdentityCredential.name}: Unavailable. Network unreachable. Message: ${err.message}`);
                logger$5.getToken.info(formatError(scopes, error));
                throw error;
            }
            // If either the host was unreachable,
            // we can safely assume the credential is unavailable.
            if (err.code === "EHOSTUNREACH") {
                const error = new CredentialUnavailableError(`${ManagedIdentityCredential.name}: Unavailable. No managed identity endpoint found. Message: ${err.message}`);
                logger$5.getToken.info(formatError(scopes, error));
                throw error;
            }
            // If err.statusCode has a value of 400, it comes from sendTokenRequest,
            // and it means that the endpoint is working, but that no identity is available.
            if (err.statusCode === 400) {
                throw new CredentialUnavailableError(`${ManagedIdentityCredential.name}: The managed identity endpoint is indicating there's no available identity. Message: ${err.message}`);
            }
            // If the error has no status code, we can assume there was no available identity.
            // This will throw silently during any ChainedTokenCredential.
            if (err.statusCode === undefined) {
                throw new CredentialUnavailableError(`${ManagedIdentityCredential.name}: Authentication failed. Message ${err.message}`);
            }
            // Any other error should break the chain.
            throw new AuthenticationError(err.statusCode, {
                error: `${ManagedIdentityCredential.name} authentication failed.`,
                error_description: err.message,
            });
        }
        finally {
            // Finally is always called, both if we return and if we throw in the above try/catch.
            span.end();
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A shim around ManagedIdentityCredential that adapts it to accept
 * `DefaultAzureCredentialOptions`.
 *
 * @internal
 */
class DefaultManagedIdentityCredential extends ManagedIdentityCredential {
    // Constructor overload with just the other default options
    // Last constructor overload with Union of all options not required since the above two constructor overloads have optional properties
    constructor(options) {
        var _a;
        const managedIdentityClientId = (_a = options === null || options === void 0 ? void 0 : options.managedIdentityClientId) !== null && _a !== void 0 ? _a : process.env.AZURE_CLIENT_ID;
        const managedResourceId = options === null || options === void 0 ? void 0 : options.managedIdentityResourceId;
        // ManagedIdentityCredential throws if both the resourceId and the clientId are provided.
        if (managedResourceId) {
            const managedIdentityResourceIdOptions = Object.assign(Object.assign({}, options), { resourceId: managedResourceId });
            super(managedIdentityResourceIdOptions);
        }
        else if (managedIdentityClientId) {
            const managedIdentityClientOptions = Object.assign(Object.assign({}, options), { clientId: managedIdentityClientId });
            super(managedIdentityClientOptions);
        }
        else {
            super(options);
        }
    }
}
const defaultCredentials = [
    EnvironmentCredential,
    DefaultManagedIdentityCredential,
    VisualStudioCodeCredential,
    AzureCliCredential,
    AzurePowerShellCredential,
];
/**
 * Provides a default {@link ChainedTokenCredential} configuration that should
 * work for most applications that use the Azure SDK.
 */
class DefaultAzureCredential extends ChainedTokenCredential {
    constructor(options) {
        super(...defaultCredentials.map((ctor) => new ctor(options)));
        this.UnavailableMessage =
            "DefaultAzureCredential => failed to retrieve a token from the included credentials. To troubleshoot, visit https://aka.ms/azsdk/js/identity/defaultazurecredential/troubleshoot.";
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * MSAL client assertion client. Calls to MSAL's confidential application's `acquireTokenByClientCredential` during `doGetToken`.
 * @internal
 */
class MsalClientAssertion extends MsalNode {
    constructor(options) {
        super(options);
        this.requiresConfidential = true;
        this.getAssertion = options.getAssertion;
    }
    async doGetToken(scopes, options = {}) {
        try {
            const assertion = await this.getAssertion();
            const result = await this.confidentialApp.acquireTokenByClientCredential({
                scopes,
                correlationId: options.correlationId,
                azureRegion: this.azureRegion,
                authority: options.authority,
                claims: options.claims,
                clientAssertion: assertion,
            });
            // The Client Credential flow does not return an account,
            // so each time getToken gets called, we will have to acquire a new token through the service.
            return this.handleResult(scopes, this.clientId, result || undefined);
        }
        catch (err) {
            let err2 = err;
            if (err === null || err === undefined) {
                err2 = new Error(JSON.stringify(err));
            }
            else {
                err2 = coreUtil.isError(err) ? err : new Error(String(err));
            }
            throw this.handleError(scopes, err2, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const logger$4 = credentialLogger("ClientAssertionCredential");
/**
 * Authenticates a service principal with a JWT assertion.
 */
class ClientAssertionCredential {
    /**
     * Creates an instance of the ClientAssertionCredential with the details
     * needed to authenticate against Azure Active Directory with a client
     * assertion provided by the developer through the `getAssertion` function parameter.
     *
     * @param tenantId - The Azure Active Directory tenant (directory) ID.
     * @param clientId - The client (application) ID of an App Registration in the tenant.
     * @param getAssertion - A function that retrieves the assertion for the credential to use.
     * @param options - Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, getAssertion, options = {}) {
        if (!tenantId || !clientId || !getAssertion) {
            throw new Error("ClientAssertionCredential: tenantId, clientId, and clientAssertion are required parameters.");
        }
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.options = options;
        this.msalFlow = new MsalClientAssertion(Object.assign(Object.assign({}, options), { logger: logger$4, clientId: this.clientId, tenantId: this.tenantId, tokenCredentialOptions: this.options, getAssertion }));
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, newOptions);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A call to open(), but mockable
 * @internal
 */
const interactiveBrowserMockable = {
    open: open__default["default"],
};
/**
 * This MSAL client sets up a web server to listen for redirect callbacks, then calls to the MSAL's public application's `acquireTokenByDeviceCode` during `doGetToken`
 * to trigger the authentication flow, and then respond based on the values obtained from the redirect callback
 * @internal
 */
class MsalOpenBrowser extends MsalNode {
    constructor(options) {
        super(options);
        this.logger = credentialLogger("Node.js MSAL Open Browser");
        this.redirectUri = options.redirectUri;
        this.loginHint = options.loginHint;
        const url = new URL(this.redirectUri);
        this.port = parseInt(url.port);
        if (isNaN(this.port)) {
            this.port = 80;
        }
        this.hostname = url.hostname;
    }
    async acquireTokenByCode(request) {
        return this.publicApp.acquireTokenByCode(request);
    }
    doGetToken(scopes, options) {
        return new Promise((resolve, reject) => {
            const socketToDestroy = [];
            const requestListener = (req, res) => {
                var _a;
                if (!req.url) {
                    reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
                    return;
                }
                let url;
                try {
                    url = new URL(req.url, this.redirectUri);
                }
                catch (e) {
                    reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
                    return;
                }
                const tokenRequest = {
                    code: url.searchParams.get("code"),
                    redirectUri: this.redirectUri,
                    scopes: scopes,
                    authority: options === null || options === void 0 ? void 0 : options.authority,
                    codeVerifier: (_a = this.pkceCodes) === null || _a === void 0 ? void 0 : _a.verifier,
                };
                this.acquireTokenByCode(tokenRequest)
                    .then((authResponse) => {
                    if (authResponse === null || authResponse === void 0 ? void 0 : authResponse.account) {
                        this.account = msalToPublic(this.clientId, authResponse.account);
                    }
                    const successMessage = `Authentication Complete. You can close the browser and return to the application.`;
                    if (authResponse && authResponse.expiresOn) {
                        const expiresOnTimestamp = authResponse === null || authResponse === void 0 ? void 0 : authResponse.expiresOn.valueOf();
                        res.writeHead(200);
                        res.end(successMessage);
                        this.logger.getToken.info(formatSuccess(scopes));
                        resolve({
                            expiresOnTimestamp,
                            token: authResponse.accessToken,
                        });
                    }
                    else {
                        const errorMessage = formatError(scopes, `${url.searchParams.get("error")}. ${url.searchParams.get("error_description")}`);
                        res.writeHead(500);
                        res.end(errorMessage);
                        this.logger.getToken.info(errorMessage);
                        reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
                    }
                    cleanup();
                    return;
                })
                    .catch(() => {
                    const errorMessage = formatError(scopes, `${url.searchParams.get("error")}. ${url.searchParams.get("error_description")}`);
                    res.writeHead(500);
                    res.end(errorMessage);
                    this.logger.getToken.info(errorMessage);
                    reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
                    cleanup();
                });
            };
            const app = http__default["default"].createServer(requestListener);
            const server = stoppable__default["default"](app);
            const listen = app.listen(this.port, this.hostname, () => this.logger.info(`InteractiveBrowserCredential listening on port ${this.port}!`));
            function cleanup() {
                if (listen) {
                    listen.close();
                }
                for (const socket of socketToDestroy) {
                    socket.destroy();
                }
                if (server) {
                    server.close();
                    server.stop();
                }
            }
            app.on("connection", (socket) => socketToDestroy.push(socket));
            app.on("error", (err) => {
                cleanup();
                const code = err.code;
                if (code === "EACCES" || code === "EADDRINUSE") {
                    reject(new CredentialUnavailableError([
                        `InteractiveBrowserCredential: Access denied to port ${this.port}.`,
                        `Try sending a redirect URI with a different port, as follows:`,
                        '`new InteractiveBrowserCredential({ redirectUri: "http://localhost:1337" })`',
                    ].join(" ")));
                }
                else {
                    reject(new CredentialUnavailableError(`InteractiveBrowserCredential: Failed to start the necessary web server. Error: ${err.message}`));
                }
            });
            app.on("listening", () => {
                const openPromise = this.openAuthCodeUrl(scopes, options);
                const abortSignal = options === null || options === void 0 ? void 0 : options.abortSignal;
                if (abortSignal) {
                    abortSignal.addEventListener("abort", () => {
                        cleanup();
                        reject(new Error("Aborted"));
                    });
                }
                openPromise.then().catch((e) => {
                    cleanup();
                    reject(e);
                });
            });
        });
    }
    async openAuthCodeUrl(scopeArray, options) {
        // Initialize CryptoProvider instance
        const cryptoProvider = new msalNode__namespace.CryptoProvider();
        // Generate PKCE Codes before starting the authorization flow
        this.pkceCodes = await cryptoProvider.generatePkceCodes();
        const authCodeUrlParameters = {
            scopes: scopeArray,
            correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
            redirectUri: this.redirectUri,
            authority: options === null || options === void 0 ? void 0 : options.authority,
            claims: options === null || options === void 0 ? void 0 : options.claims,
            loginHint: this.loginHint,
            codeChallenge: this.pkceCodes.challenge,
            codeChallengeMethod: "S256", // Use SHA256 Algorithm
        };
        const response = await this.publicApp.getAuthCodeUrl(authCodeUrlParameters);
        try {
            // A new instance on macOS only which allows it to not hang, does not fix the issue on linux
            await interactiveBrowserMockable.open(response, { wait: true, newInstance: true });
        }
        catch (e) {
            throw new CredentialUnavailableError(`InteractiveBrowserCredential: Could not open a browser window. Error: ${e.message}`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const logger$3 = credentialLogger("InteractiveBrowserCredential");
/**
 * Enables authentication to Azure Active Directory inside of the web browser
 * using the interactive login flow.
 */
class InteractiveBrowserCredential {
    /**
     * Creates an instance of InteractiveBrowserCredential with the details needed.
     *
     * This credential uses the [Authorization Code Flow](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow).
     * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
     * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
     *
     * For Node.js, if a `clientId` is provided, the Azure Active Directory application will need to be configured to have a "Mobile and desktop applications" redirect endpoint.
     * Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://docs.microsoft.com/azure/active-directory/develop/scenario-desktop-app-registration#redirect-uris).
     *
     * @param options - Options for configuring the client which makes the authentication requests.
     */
    constructor(options = {}) {
        const redirectUri = typeof options.redirectUri === "function"
            ? options.redirectUri()
            : options.redirectUri || "http://localhost";
        this.msalFlow = new MsalOpenBrowser(Object.assign(Object.assign({}, options), { tokenCredentialOptions: options, logger: logger$3,
            redirectUri }));
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * If the user provided the option `disableAutomaticAuthentication`,
     * once the token can't be retrieved silently,
     * this method won't attempt to request user interaction to retrieve the token.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
     *
     * On Node.js, this credential has [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) enabled by default.
     * PKCE is a security feature that mitigates authentication code interception attacks.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                  TokenCredential implementation might make.
     */
    async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            await this.msalFlow.getToken(arrayScopes, newOptions);
            return this.msalFlow.getActiveAccount();
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * MSAL device code client. Calls to the MSAL's public application's `acquireTokenByDeviceCode` during `doGetToken`.
 * @internal
 */
class MsalDeviceCode extends MsalNode {
    constructor(options) {
        super(options);
        this.userPromptCallback = options.userPromptCallback;
    }
    async doGetToken(scopes, options) {
        try {
            const requestOptions = {
                deviceCodeCallback: this.userPromptCallback,
                scopes,
                cancel: false,
                correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
                authority: options === null || options === void 0 ? void 0 : options.authority,
                claims: options === null || options === void 0 ? void 0 : options.claims,
            };
            const promise = this.publicApp.acquireTokenByDeviceCode(requestOptions);
            const deviceResponse = await this.withCancellation(promise, options === null || options === void 0 ? void 0 : options.abortSignal, () => {
                requestOptions.cancel = true;
            });
            return this.handleResult(scopes, this.clientId, deviceResponse || undefined);
        }
        catch (error) {
            throw this.handleError(scopes, error, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const logger$2 = credentialLogger("DeviceCodeCredential");
/**
 * Method that logs the user code from the DeviceCodeCredential.
 * @param deviceCodeInfo - The device code.
 */
function defaultDeviceCodePromptCallback(deviceCodeInfo) {
    console.log(deviceCodeInfo.message);
}
/**
 * Enables authentication to Azure Active Directory using a device code
 * that the user can enter into https://microsoft.com/devicelogin.
 */
class DeviceCodeCredential {
    /**
     * Creates an instance of DeviceCodeCredential with the details needed
     * to initiate the device code authorization flow with Azure Active Directory.
     *
     * A message will be logged, giving users a code that they can use to authenticate once they go to https://microsoft.com/devicelogin
     *
     * Developers can configure how this message is shown by passing a custom `userPromptCallback`:
     *
     * ```js
     * const credential = new DeviceCodeCredential({
     *   tenantId: env.AZURE_TENANT_ID,
     *   clientId: env.AZURE_CLIENT_ID,
     *   userPromptCallback: (info) => {
     *     console.log("CUSTOMIZED PROMPT CALLBACK", info.message);
     *   }
     * });
     * ```
     *
     * @param options - Options for configuring the client which makes the authentication requests.
     */
    constructor(options) {
        this.msalFlow = new MsalDeviceCode(Object.assign(Object.assign({}, options), { logger: logger$2, userPromptCallback: (options === null || options === void 0 ? void 0 : options.userPromptCallback) || defaultDeviceCodePromptCallback, tokenCredentialOptions: options || {} }));
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * If the user provided the option `disableAutomaticAuthentication`,
     * once the token can't be retrieved silently,
     * this method won't attempt to request user interaction to retrieve the token.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                  TokenCredential implementation might make.
     */
    async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            await this.msalFlow.getToken(arrayScopes, newOptions);
            return this.msalFlow.getActiveAccount();
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * This MSAL client sets up a web server to listen for redirect callbacks, then calls to the MSAL's public application's `acquireTokenByDeviceCode` during `doGetToken`
 * to trigger the authentication flow, and then respond based on the values obtained from the redirect callback
 * @internal
 */
class MsalAuthorizationCode extends MsalNode {
    constructor(options) {
        super(options);
        this.logger = credentialLogger("Node.js MSAL Authorization Code");
        this.redirectUri = options.redirectUri;
        this.authorizationCode = options.authorizationCode;
        if (options.clientSecret) {
            this.msalConfig.auth.clientSecret = options.clientSecret;
        }
    }
    async getAuthCodeUrl(options) {
        await this.init();
        return (this.confidentialApp || this.publicApp).getAuthCodeUrl(options);
    }
    async doGetToken(scopes, options) {
        var _a;
        try {
            const result = await ((_a = (this.confidentialApp || this.publicApp)) === null || _a === void 0 ? void 0 : _a.acquireTokenByCode({
                scopes,
                redirectUri: this.redirectUri,
                code: this.authorizationCode,
                correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
                authority: options === null || options === void 0 ? void 0 : options.authority,
                claims: options === null || options === void 0 ? void 0 : options.claims,
            }));
            // The Client Credential flow does not return an account,
            // so each time getToken gets called, we will have to acquire a new token through the service.
            return this.handleResult(scopes, this.clientId, result || undefined);
        }
        catch (err) {
            throw this.handleError(scopes, err, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const logger$1 = credentialLogger("AuthorizationCodeCredential");
/**
 * Enables authentication to Azure Active Directory using an authorization code
 * that was obtained through the authorization code flow, described in more detail
 * in the Azure Active Directory documentation:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow
 */
class AuthorizationCodeCredential {
    /**
     * @hidden
     * @internal
     */
    constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
        checkTenantId(logger$1, tenantId);
        let clientSecret = clientSecretOrAuthorizationCode;
        if (typeof redirectUriOrOptions === "string") {
            // the clientId+clientSecret constructor
            this.authorizationCode = authorizationCodeOrRedirectUri;
            this.redirectUri = redirectUriOrOptions;
            // in this case, options are good as they come
        }
        else {
            // clientId only
            this.authorizationCode = clientSecretOrAuthorizationCode;
            this.redirectUri = authorizationCodeOrRedirectUri;
            clientSecret = undefined;
            options = redirectUriOrOptions;
        }
        this.msalFlow = new MsalAuthorizationCode(Object.assign(Object.assign({}, options), { clientSecret,
            clientId,
            tenantId, tokenCredentialOptions: options || {}, logger: logger$1, redirectUri: this.redirectUri, authorizationCode: this.authorizationCode }));
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * MSAL on behalf of flow. Calls to MSAL's confidential application's `acquireTokenOnBehalfOf` during `doGetToken`.
 * @internal
 */
class MsalOnBehalfOf extends MsalNode {
    constructor(options) {
        super(options);
        this.logger.info("Initialized MSAL's On-Behalf-Of flow");
        this.requiresConfidential = true;
        this.userAssertionToken = options.userAssertionToken;
        this.certificatePath = options.certificatePath;
        this.sendCertificateChain = options.sendCertificateChain;
        this.clientSecret = options.clientSecret;
    }
    // Changing the MSAL configuration asynchronously
    async init(options) {
        if (this.certificatePath) {
            try {
                const parts = await parseCertificate({ certificatePath: this.certificatePath }, this.sendCertificateChain);
                this.msalConfig.auth.clientCertificate = {
                    thumbprint: parts.thumbprint,
                    privateKey: parts.certificateContents,
                    x5c: parts.x5c,
                };
            }
            catch (error) {
                this.logger.info(formatError("", error));
                throw error;
            }
        }
        else {
            this.msalConfig.auth.clientSecret = this.clientSecret;
        }
        return super.init(options);
    }
    async doGetToken(scopes, options = {}) {
        try {
            const result = await this.confidentialApp.acquireTokenOnBehalfOf({
                scopes,
                correlationId: options.correlationId,
                authority: options.authority,
                claims: options.claims,
                oboAssertion: this.userAssertionToken,
            });
            return this.handleResult(scopes, this.clientId, result || undefined);
        }
        catch (err) {
            throw this.handleError(scopes, err, options);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const credentialName = "OnBehalfOfCredential";
const logger = credentialLogger(credentialName);
/**
 * Enables authentication to Azure Active Directory using the [On Behalf Of flow](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow).
 */
class OnBehalfOfCredential {
    constructor(options) {
        this.options = options;
        const { clientSecret } = options;
        const { certificatePath } = options;
        const { tenantId, clientId, userAssertionToken } = options;
        if (!tenantId || !clientId || !(clientSecret || certificatePath) || !userAssertionToken) {
            throw new Error(`${credentialName}: tenantId, clientId, clientSecret (or certificatePath) and userAssertionToken are required parameters.`);
        }
        this.msalFlow = new MsalOnBehalfOf(Object.assign(Object.assign({}, this.options), { logger, tokenCredentialOptions: this.options }));
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if successful.
     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure the underlying network requests.
     */
    async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
            return this.msalFlow.getToken(arrayScopes, newOptions);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Returns a new instance of the {@link DefaultAzureCredential}.
 */
function getDefaultAzureCredential() {
    return new DefaultAzureCredential();
}

exports.AggregateAuthenticationError = AggregateAuthenticationError;
exports.AggregateAuthenticationErrorName = AggregateAuthenticationErrorName;
exports.AuthenticationError = AuthenticationError;
exports.AuthenticationErrorName = AuthenticationErrorName;
exports.AuthenticationRequiredError = AuthenticationRequiredError;
exports.AuthorizationCodeCredential = AuthorizationCodeCredential;
exports.AzureCliCredential = AzureCliCredential;
exports.AzurePowerShellCredential = AzurePowerShellCredential;
exports.ChainedTokenCredential = ChainedTokenCredential;
exports.ClientAssertionCredential = ClientAssertionCredential;
exports.ClientCertificateCredential = ClientCertificateCredential;
exports.ClientSecretCredential = ClientSecretCredential;
exports.CredentialUnavailableError = CredentialUnavailableError;
exports.CredentialUnavailableErrorName = CredentialUnavailableErrorName;
exports.DefaultAzureCredential = DefaultAzureCredential;
exports.DeviceCodeCredential = DeviceCodeCredential;
exports.EnvironmentCredential = EnvironmentCredential;
exports.InteractiveBrowserCredential = InteractiveBrowserCredential;
exports.ManagedIdentityCredential = ManagedIdentityCredential;
exports.OnBehalfOfCredential = OnBehalfOfCredential;
exports.UsernamePasswordCredential = UsernamePasswordCredential;
exports.VisualStudioCodeCredential = VisualStudioCodeCredential;
exports.deserializeAuthenticationRecord = deserializeAuthenticationRecord;
exports.getDefaultAzureCredential = getDefaultAzureCredential;
exports.logger = logger$l;
exports.serializeAuthenticationRecord = serializeAuthenticationRecord;
exports.useIdentityPlugin = useIdentityPlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 803:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var util = _interopDefault(__nccwpck_require__(3837));
var os = __nccwpck_require__(2037);

// Copyright (c) Microsoft Corporation.
function log(message, ...args) {
    process.stderr.write(`${util.format(message, ...args)}${os.EOL}`);
}

// Copyright (c) Microsoft Corporation.
const debugEnvVariable = (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
let enabledString;
let enabledNamespaces = [];
let skippedNamespaces = [];
const debuggers = [];
if (debugEnvVariable) {
    enable(debugEnvVariable);
}
const debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
}, {
    enable,
    enabled,
    disable,
    log
});
function enable(namespaces) {
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    const wildcard = /\*/g;
    const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
    for (const ns of namespaceList) {
        if (ns.startsWith("-")) {
            skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
        }
        else {
            enabledNamespaces.push(new RegExp(`^${ns}$`));
        }
    }
    for (const instance of debuggers) {
        instance.enabled = enabled(instance.namespace);
    }
}
function enabled(namespace) {
    if (namespace.endsWith("*")) {
        return true;
    }
    for (const skipped of skippedNamespaces) {
        if (skipped.test(namespace)) {
            return false;
        }
    }
    for (const enabledNamespace of enabledNamespaces) {
        if (enabledNamespace.test(namespace)) {
            return true;
        }
    }
    return false;
}
function disable() {
    const result = enabledString || "";
    enable("");
    return result;
}
function createDebugger(namespace) {
    const newDebugger = Object.assign(debug, {
        enabled: enabled(namespace),
        destroy,
        log: debugObj.log,
        namespace,
        extend
    });
    function debug(...args) {
        if (!newDebugger.enabled) {
            return;
        }
        if (args.length > 0) {
            args[0] = `${namespace} ${args[0]}`;
        }
        newDebugger.log(...args);
    }
    debuggers.push(newDebugger);
    return newDebugger;
}
function destroy() {
    const index = debuggers.indexOf(this);
    if (index >= 0) {
        debuggers.splice(index, 1);
        return true;
    }
    return false;
}
function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
}

// Copyright (c) Microsoft Corporation.
const registeredLoggers = new Set();
const logLevelFromEnv = (typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;
let azureLogLevel;
/**
 * The AzureLogger provides a mechanism for overriding where logs are output to.
 * By default, logs are sent to stderr.
 * Override the `log` method to redirect logs to another location.
 */
const AzureLogger = debugObj("azure");
AzureLogger.log = (...args) => {
    debugObj.log(...args);
};
const AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
if (logLevelFromEnv) {
    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
    if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
    }
    else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
    }
}
/**
 * Immediately enables logging at the specified log level.
 * @param level - The log level to enable for logging.
 * Options from most verbose to least verbose are:
 * - verbose
 * - info
 * - warning
 * - error
 */
function setLogLevel(level) {
    if (level && !isAzureLogLevel(level)) {
        throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    }
    azureLogLevel = level;
    const enabledNamespaces = [];
    for (const logger of registeredLoggers) {
        if (shouldEnable(logger)) {
            enabledNamespaces.push(logger.namespace);
        }
    }
    debugObj.enable(enabledNamespaces.join(","));
}
/**
 * Retrieves the currently specified log level.
 */
function getLogLevel() {
    return azureLogLevel;
}
const levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
};
/**
 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
 * @param namespace - The name of the SDK package.
 * @hidden
 */
function createClientLogger(namespace) {
    const clientRootLogger = AzureLogger.extend(namespace);
    patchLogMethod(AzureLogger, clientRootLogger);
    return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
    };
}
function patchLogMethod(parent, child) {
    child.log = (...args) => {
        parent.log(...args);
    };
}
function createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
        level
    });
    patchLogMethod(parent, logger);
    if (shouldEnable(logger)) {
        const enabledNamespaces = debugObj.disable();
        debugObj.enable(enabledNamespaces + "," + logger.namespace);
    }
    registeredLoggers.add(logger);
    return logger;
}
function shouldEnable(logger) {
    if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {
        return true;
    }
    else {
        return false;
    }
}
function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
}

exports.AzureLogger = AzureLogger;
exports.createClientLogger = createClientLogger;
exports.getLogLevel = getLogLevel;
exports.setLogLevel = setLogLevel;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 6849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*! @azure/msal-common v7.4.0 2022-09-06 */

'use strict';

Object.defineProperty(exports, "__esModule", ({ value: true }));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Constants = {
    LIBRARY_NAME: "MSAL.JS",
    SKU: "msal.js.common",
    // Prefix for all library cache entries
    CACHE_PREFIX: "msal",
    // default authority
    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
    DEFAULT_COMMON_TENANT: "common",
    // ADFS String
    ADFS: "adfs",
    // Default AAD Instance Discovery Endpoint
    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
    // Resource delimiter - used for certain cache entries
    RESOURCE_DELIM: "|",
    // Placeholder for non-existent account ids/objects
    NO_ACCOUNT: "NO_ACCOUNT",
    // Claims
    CLAIMS: "claims",
    // Consumer UTID
    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
    // Default scopes
    OPENID_SCOPE: "openid",
    PROFILE_SCOPE: "profile",
    OFFLINE_ACCESS_SCOPE: "offline_access",
    EMAIL_SCOPE: "email",
    // Default response type for authorization code flow
    CODE_RESPONSE_TYPE: "code",
    CODE_GRANT_TYPE: "authorization_code",
    RT_GRANT_TYPE: "refresh_token",
    FRAGMENT_RESPONSE_MODE: "fragment",
    S256_CODE_CHALLENGE_METHOD: "S256",
    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
    AUTHORIZATION_PENDING: "authorization_pending",
    NOT_DEFINED: "not_defined",
    EMPTY_STRING: "",
    FORWARD_SLASH: "/",
    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
    IMDS_VERSION: "2020-06-01",
    IMDS_TIMEOUT: 2000,
    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
    KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
    TOKEN_RESPONSE_TYPE: "token",
    ID_TOKEN_RESPONSE_TYPE: "id_token",
    SHR_NONCE_VALIDITY: 240
};
var OIDC_DEFAULT_SCOPES = [
    Constants.OPENID_SCOPE,
    Constants.PROFILE_SCOPE,
    Constants.OFFLINE_ACCESS_SCOPE
];
var OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [
    Constants.EMAIL_SCOPE
]);
/**
 * Request header names
 */
var HeaderNames;
(function (HeaderNames) {
    HeaderNames["CONTENT_TYPE"] = "Content-Type";
    HeaderNames["RETRY_AFTER"] = "Retry-After";
    HeaderNames["CCS_HEADER"] = "X-AnchorMailbox";
    HeaderNames["WWWAuthenticate"] = "WWW-Authenticate";
    HeaderNames["AuthenticationInfo"] = "Authentication-Info";
})(HeaderNames || (HeaderNames = {}));
/**
 * Persistent cache keys MSAL which stay while user is logged in.
 */
exports.PersistentCacheKeys = void 0;
(function (PersistentCacheKeys) {
    PersistentCacheKeys["ID_TOKEN"] = "idtoken";
    PersistentCacheKeys["CLIENT_INFO"] = "client.info";
    PersistentCacheKeys["ADAL_ID_TOKEN"] = "adal.idtoken";
    PersistentCacheKeys["ERROR"] = "error";
    PersistentCacheKeys["ERROR_DESC"] = "error.description";
    PersistentCacheKeys["ACTIVE_ACCOUNT"] = "active-account";
    PersistentCacheKeys["ACTIVE_ACCOUNT_FILTERS"] = "active-account-filters"; // new cache entry for active_account for a more robust version for browser
})(exports.PersistentCacheKeys || (exports.PersistentCacheKeys = {}));
/**
 * String constants related to AAD Authority
 */
var AADAuthorityConstants;
(function (AADAuthorityConstants) {
    AADAuthorityConstants["COMMON"] = "common";
    AADAuthorityConstants["ORGANIZATIONS"] = "organizations";
    AADAuthorityConstants["CONSUMERS"] = "consumers";
})(AADAuthorityConstants || (AADAuthorityConstants = {}));
/**
 * Keys in the hashParams sent by AAD Server
 */
var AADServerParamKeys;
(function (AADServerParamKeys) {
    AADServerParamKeys["CLIENT_ID"] = "client_id";
    AADServerParamKeys["REDIRECT_URI"] = "redirect_uri";
    AADServerParamKeys["RESPONSE_TYPE"] = "response_type";
    AADServerParamKeys["RESPONSE_MODE"] = "response_mode";
    AADServerParamKeys["GRANT_TYPE"] = "grant_type";
    AADServerParamKeys["CLAIMS"] = "claims";
    AADServerParamKeys["SCOPE"] = "scope";
    AADServerParamKeys["ERROR"] = "error";
    AADServerParamKeys["ERROR_DESCRIPTION"] = "error_description";
    AADServerParamKeys["ACCESS_TOKEN"] = "access_token";
    AADServerParamKeys["ID_TOKEN"] = "id_token";
    AADServerParamKeys["REFRESH_TOKEN"] = "refresh_token";
    AADServerParamKeys["EXPIRES_IN"] = "expires_in";
    AADServerParamKeys["STATE"] = "state";
    AADServerParamKeys["NONCE"] = "nonce";
    AADServerParamKeys["PROMPT"] = "prompt";
    AADServerParamKeys["SESSION_STATE"] = "session_state";
    AADServerParamKeys["CLIENT_INFO"] = "client_info";
    AADServerParamKeys["CODE"] = "code";
    AADServerParamKeys["CODE_CHALLENGE"] = "code_challenge";
    AADServerParamKeys["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
    AADServerParamKeys["CODE_VERIFIER"] = "code_verifier";
    AADServerParamKeys["CLIENT_REQUEST_ID"] = "client-request-id";
    AADServerParamKeys["X_CLIENT_SKU"] = "x-client-SKU";
    AADServerParamKeys["X_CLIENT_VER"] = "x-client-VER";
    AADServerParamKeys["X_CLIENT_OS"] = "x-client-OS";
    AADServerParamKeys["X_CLIENT_CPU"] = "x-client-CPU";
    AADServerParamKeys["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
    AADServerParamKeys["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
    AADServerParamKeys["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
    AADServerParamKeys["X_APP_NAME"] = "x-app-name";
    AADServerParamKeys["X_APP_VER"] = "x-app-ver";
    AADServerParamKeys["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
    AADServerParamKeys["ID_TOKEN_HINT"] = "id_token_hint";
    AADServerParamKeys["DEVICE_CODE"] = "device_code";
    AADServerParamKeys["CLIENT_SECRET"] = "client_secret";
    AADServerParamKeys["CLIENT_ASSERTION"] = "client_assertion";
    AADServerParamKeys["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
    AADServerParamKeys["TOKEN_TYPE"] = "token_type";
    AADServerParamKeys["REQ_CNF"] = "req_cnf";
    AADServerParamKeys["OBO_ASSERTION"] = "assertion";
    AADServerParamKeys["REQUESTED_TOKEN_USE"] = "requested_token_use";
    AADServerParamKeys["ON_BEHALF_OF"] = "on_behalf_of";
    AADServerParamKeys["FOCI"] = "foci";
    AADServerParamKeys["CCS_HEADER"] = "X-AnchorMailbox";
    AADServerParamKeys["RETURN_SPA_CODE"] = "return_spa_code";
    AADServerParamKeys["NATIVE_BROKER"] = "nativebroker";
    AADServerParamKeys["LOGOUT_HINT"] = "logout_hint";
})(AADServerParamKeys || (AADServerParamKeys = {}));
/**
 * Claims request keys
 */
var ClaimsRequestKeys;
(function (ClaimsRequestKeys) {
    ClaimsRequestKeys["ACCESS_TOKEN"] = "access_token";
    ClaimsRequestKeys["XMS_CC"] = "xms_cc";
})(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
/**
 * we considered making this "enum" in the request instead of string, however it looks like the allowed list of
 * prompt values kept changing over past couple of years. There are some undocumented prompt values for some
 * internal partners too, hence the choice of generic "string" type instead of the "enum"
 */
var PromptValue = {
    LOGIN: "login",
    SELECT_ACCOUNT: "select_account",
    CONSENT: "consent",
    NONE: "none",
    CREATE: "create"
};
/**
 * SSO Types - generated to populate hints
 */
var SSOTypes;
(function (SSOTypes) {
    SSOTypes["ACCOUNT"] = "account";
    SSOTypes["SID"] = "sid";
    SSOTypes["LOGIN_HINT"] = "login_hint";
    SSOTypes["ID_TOKEN"] = "id_token";
    SSOTypes["DOMAIN_HINT"] = "domain_hint";
    SSOTypes["ORGANIZATIONS"] = "organizations";
    SSOTypes["CONSUMERS"] = "consumers";
    SSOTypes["ACCOUNT_ID"] = "accountIdentifier";
    SSOTypes["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
})(SSOTypes || (SSOTypes = {}));
/**
 * Disallowed extra query parameters.
 */
[
    SSOTypes.SID,
    SSOTypes.LOGIN_HINT
];
/**
 * allowed values for codeVerifier
 */
var CodeChallengeMethodValues = {
    PLAIN: "plain",
    S256: "S256"
};
/**
 * The method used to encode the code verifier for the code challenge parameter. can be one
 * of plain or s256. if excluded, code challenge is assumed to be plaintext. for more
 * information, see the pkce rcf: https://tools.ietf.org/html/rfc7636
 */
[
    CodeChallengeMethodValues.PLAIN,
    CodeChallengeMethodValues.S256
];
/**
 * allowed values for response_mode
 */
exports.ResponseMode = void 0;
(function (ResponseMode) {
    ResponseMode["QUERY"] = "query";
    ResponseMode["FRAGMENT"] = "fragment";
    ResponseMode["FORM_POST"] = "form_post";
})(exports.ResponseMode || (exports.ResponseMode = {}));
/**
 * allowed grant_type
 */
var GrantType;
(function (GrantType) {
    GrantType["IMPLICIT_GRANT"] = "implicit";
    GrantType["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
    GrantType["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
    GrantType["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
    GrantType["REFRESH_TOKEN_GRANT"] = "refresh_token";
    GrantType["DEVICE_CODE_GRANT"] = "device_code";
    GrantType["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer";
})(GrantType || (GrantType = {}));
/**
 * Account types in Cache
 */
exports.CacheAccountType = void 0;
(function (CacheAccountType) {
    CacheAccountType["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
    CacheAccountType["ADFS_ACCOUNT_TYPE"] = "ADFS";
    CacheAccountType["MSAV1_ACCOUNT_TYPE"] = "MSA";
    CacheAccountType["GENERIC_ACCOUNT_TYPE"] = "Generic"; // NTLM, Kerberos, FBA, Basic etc
})(exports.CacheAccountType || (exports.CacheAccountType = {}));
/**
 * Separators used in cache
 */
var Separators;
(function (Separators) {
    Separators["CACHE_KEY_SEPARATOR"] = "-";
    Separators["CLIENT_INFO_SEPARATOR"] = ".";
})(Separators || (Separators = {}));
/**
 * Credential Type stored in the cache
 */
exports.CredentialType = void 0;
(function (CredentialType) {
    CredentialType["ID_TOKEN"] = "IdToken";
    CredentialType["ACCESS_TOKEN"] = "AccessToken";
    CredentialType["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
    CredentialType["REFRESH_TOKEN"] = "RefreshToken";
})(exports.CredentialType || (exports.CredentialType = {}));
/**
 * Credential Type stored in the cache
 */
exports.CacheSchemaType = void 0;
(function (CacheSchemaType) {
    CacheSchemaType["ACCOUNT"] = "Account";
    CacheSchemaType["CREDENTIAL"] = "Credential";
    CacheSchemaType["ID_TOKEN"] = "IdToken";
    CacheSchemaType["ACCESS_TOKEN"] = "AccessToken";
    CacheSchemaType["REFRESH_TOKEN"] = "RefreshToken";
    CacheSchemaType["APP_METADATA"] = "AppMetadata";
    CacheSchemaType["TEMPORARY"] = "TempCache";
    CacheSchemaType["TELEMETRY"] = "Telemetry";
    CacheSchemaType["UNDEFINED"] = "Undefined";
    CacheSchemaType["THROTTLING"] = "Throttling";
})(exports.CacheSchemaType || (exports.CacheSchemaType = {}));
/**
 * Combine all cache types
 */
exports.CacheType = void 0;
(function (CacheType) {
    CacheType[CacheType["ADFS"] = 1001] = "ADFS";
    CacheType[CacheType["MSA"] = 1002] = "MSA";
    CacheType[CacheType["MSSTS"] = 1003] = "MSSTS";
    CacheType[CacheType["GENERIC"] = 1004] = "GENERIC";
    CacheType[CacheType["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
    CacheType[CacheType["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
    CacheType[CacheType["ID_TOKEN"] = 2003] = "ID_TOKEN";
    CacheType[CacheType["APP_METADATA"] = 3001] = "APP_METADATA";
    CacheType[CacheType["UNDEFINED"] = 9999] = "UNDEFINED";
})(exports.CacheType || (exports.CacheType = {}));
/**
 * More Cache related constants
 */
var APP_METADATA = "appmetadata";
var CLIENT_INFO = "client_info";
var THE_FAMILY_ID = "1";
var AUTHORITY_METADATA_CONSTANTS = {
    CACHE_KEY: "authority-metadata",
    REFRESH_TIME_SECONDS: 3600 * 24 // 24 Hours
};
var AuthorityMetadataSource;
(function (AuthorityMetadataSource) {
    AuthorityMetadataSource["CONFIG"] = "config";
    AuthorityMetadataSource["CACHE"] = "cache";
    AuthorityMetadataSource["NETWORK"] = "network";
    AuthorityMetadataSource["HARDCODED_VALUES"] = "hardcoded_values";
})(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
var SERVER_TELEM_CONSTANTS = {
    SCHEMA_VERSION: 5,
    MAX_CUR_HEADER_BYTES: 80,
    MAX_LAST_HEADER_BYTES: 330,
    MAX_CACHED_ERRORS: 50,
    CACHE_KEY: "server-telemetry",
    CATEGORY_SEPARATOR: "|",
    VALUE_SEPARATOR: ",",
    OVERFLOW_TRUE: "1",
    OVERFLOW_FALSE: "0",
    UNKNOWN_ERROR: "unknown_error"
};
/**
 * Type of the authentication request
 */
exports.AuthenticationScheme = void 0;
(function (AuthenticationScheme) {
    AuthenticationScheme["BEARER"] = "Bearer";
    AuthenticationScheme["POP"] = "pop";
    AuthenticationScheme["SSH"] = "ssh-cert";
})(exports.AuthenticationScheme || (exports.AuthenticationScheme = {}));
/**
 * Constants related to throttling
 */
var ThrottlingConstants = {
    // Default time to throttle RequestThumbprint in seconds
    DEFAULT_THROTTLE_TIME_SECONDS: 60,
    // Default maximum time to throttle in seconds, overrides what the server sends back
    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
    // Prefix for storing throttling entries
    THROTTLING_PREFIX: "throttling",
    // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
};
var Errors = {
    INVALID_GRANT_ERROR: "invalid_grant",
    CLIENT_MISMATCH_ERROR: "client_mismatch",
};
/**
 * Password grant parameters
 */
var PasswordGrantConstants;
(function (PasswordGrantConstants) {
    PasswordGrantConstants["username"] = "username";
    PasswordGrantConstants["password"] = "password";
})(PasswordGrantConstants || (PasswordGrantConstants = {}));
/**
 * Response codes
 */
var ResponseCodes;
(function (ResponseCodes) {
    ResponseCodes[ResponseCodes["httpSuccess"] = 200] = "httpSuccess";
    ResponseCodes[ResponseCodes["httpBadRequest"] = 400] = "httpBadRequest";
})(ResponseCodes || (ResponseCodes = {}));
/**
 * Region Discovery Sources
 */
var RegionDiscoverySources;
(function (RegionDiscoverySources) {
    RegionDiscoverySources["FAILED_AUTO_DETECTION"] = "1";
    RegionDiscoverySources["INTERNAL_CACHE"] = "2";
    RegionDiscoverySources["ENVIRONMENT_VARIABLE"] = "3";
    RegionDiscoverySources["IMDS"] = "4";
})(RegionDiscoverySources || (RegionDiscoverySources = {}));
/**
 * Region Discovery Outcomes
 */
var RegionDiscoveryOutcomes;
(function (RegionDiscoveryOutcomes) {
    RegionDiscoveryOutcomes["CONFIGURED_MATCHES_DETECTED"] = "1";
    RegionDiscoveryOutcomes["CONFIGURED_NO_AUTO_DETECTION"] = "2";
    RegionDiscoveryOutcomes["CONFIGURED_NOT_DETECTED"] = "3";
    RegionDiscoveryOutcomes["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
    RegionDiscoveryOutcomes["AUTO_DETECTION_REQUESTED_FAILED"] = "5";
})(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
var CacheOutcome;
(function (CacheOutcome) {
    CacheOutcome["NO_CACHE_HIT"] = "0";
    CacheOutcome["FORCE_REFRESH"] = "1";
    CacheOutcome["NO_CACHED_ACCESS_TOKEN"] = "2";
    CacheOutcome["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
    CacheOutcome["REFRESH_CACHED_ACCESS_TOKEN"] = "4";
})(CacheOutcome || (CacheOutcome = {}));
var JsonTypes;
(function (JsonTypes) {
    JsonTypes["Jwt"] = "JWT";
    JsonTypes["Jwk"] = "JWK";
})(JsonTypes || (JsonTypes = {}));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * AuthErrorMessage class containing string constants used by error codes and messages.
 */
var AuthErrorMessage = {
    unexpectedError: {
        code: "unexpected_error",
        desc: "Unexpected error in authentication."
    },
    postRequestFailed: {
        code: "post_request_failed",
        desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    }
};
/**
 * General error class thrown by the MSAL.js library.
 */
var AuthError = /** @class */ (function (_super) {
    __extends(AuthError, _super);
    function AuthError(errorCode, errorMessage, suberror) {
        var _this = this;
        var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
        _this = _super.call(this, errorString) || this;
        Object.setPrototypeOf(_this, AuthError.prototype);
        _this.errorCode = errorCode || Constants.EMPTY_STRING;
        _this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        _this.subError = suberror || Constants.EMPTY_STRING;
        _this.name = "AuthError";
        return _this;
    }
    AuthError.prototype.setCorrelationId = function (correlationId) {
        this.correlationId = correlationId;
    };
    /**
     * Creates an error that is thrown when something unexpected happens in the library.
     * @param errDesc
     */
    AuthError.createUnexpectedError = function (errDesc) {
        return new AuthError(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
    };
    /**
     * Creates an error for post request failures.
     * @param errDesc
     * @returns
     */
    AuthError.createPostRequestFailed = function (errDesc) {
        return new AuthError(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + errDesc);
    };
    return AuthError;
}(Error));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var DEFAULT_CRYPTO_IMPLEMENTATION = {
    createNewGuid: function () {
        var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    base64Decode: function () {
        var notImplErr = "Crypto interface - base64Decode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    base64Encode: function () {
        var notImplErr = "Crypto interface - base64Encode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    generatePkceCodes: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    getPublicKeyThumbprint: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    removeTokenBindingKey: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    clearKeystore: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - clearKeystore() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    signJwt: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - signJwt() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    hashString: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - hashString() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
 */
var ClientAuthErrorMessage = {
    clientInfoDecodingError: {
        code: "client_info_decoding_error",
        desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
    },
    clientInfoEmptyError: {
        code: "client_info_empty_error",
        desc: "The client info was empty. Please review the trace to determine the root cause."
    },
    tokenParsingError: {
        code: "token_parsing_error",
        desc: "Token cannot be parsed. Please review stack trace to determine root cause."
    },
    nullOrEmptyToken: {
        code: "null_or_empty_token",
        desc: "The token is null or empty. Please review the trace to determine the root cause."
    },
    endpointResolutionError: {
        code: "endpoints_resolution_error",
        desc: "Error: could not resolve endpoints. Please check network and try again."
    },
    networkError: {
        code: "network_error",
        desc: "Network request failed. Please check network trace to determine root cause."
    },
    unableToGetOpenidConfigError: {
        code: "openid_config_error",
        desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
    },
    hashNotDeserialized: {
        code: "hash_not_deserialized",
        desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
    },
    blankGuidGenerated: {
        code: "blank_guid_generated",
        desc: "The guid generated was blank. Please review the trace to determine the root cause."
    },
    invalidStateError: {
        code: "invalid_state",
        desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
    },
    stateMismatchError: {
        code: "state_mismatch",
        desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
    },
    stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found"
    },
    nonceMismatchError: {
        code: "nonce_mismatch",
        desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
    },
    nonceNotFoundError: {
        code: "nonce_not_found",
        desc: "nonce not found"
    },
    noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
    },
    multipleMatchingTokens: {
        code: "multiple_matching_tokens",
        desc: "The cache contains multiple tokens satisfying the requirements. " +
            "Call AcquireToken again providing more requirements such as authority or account."
    },
    multipleMatchingAccounts: {
        code: "multiple_matching_accounts",
        desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
    },
    multipleMatchingAppMetadata: {
        code: "multiple_matching_appMetadata",
        desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
    },
    tokenRequestCannotBeMade: {
        code: "request_cannot_be_made",
        desc: "Token request cannot be made without authorization code or refresh token."
    },
    appendEmptyScopeError: {
        code: "cannot_append_empty_scope",
        desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
    },
    removeEmptyScopeError: {
        code: "cannot_remove_empty_scope",
        desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
    },
    appendScopeSetError: {
        code: "cannot_append_scopeset",
        desc: "Cannot append ScopeSet due to error."
    },
    emptyInputScopeSetError: {
        code: "empty_input_scopeset",
        desc: "Empty input ScopeSet cannot be processed."
    },
    DeviceCodePollingCancelled: {
        code: "device_code_polling_cancelled",
        desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
    },
    DeviceCodeExpired: {
        code: "device_code_expired",
        desc: "Device code is expired."
    },
    DeviceCodeUnknownError: {
        code: "device_code_unknown_error",
        desc: "Device code stopped polling for unknown reasons."
    },
    NoAccountInSilentRequest: {
        code: "no_account_in_silent_request",
        desc: "Please pass an account object, silent flow is not supported without account information"
    },
    invalidCacheRecord: {
        code: "invalid_cache_record",
        desc: "Cache record object was null or undefined."
    },
    invalidCacheEnvironment: {
        code: "invalid_cache_environment",
        desc: "Invalid environment when attempting to create cache entry"
    },
    noAccountFound: {
        code: "no_account_found",
        desc: "No account found in cache for given key."
    },
    CachePluginError: {
        code: "no cache plugin set on CacheManager",
        desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
    },
    noCryptoObj: {
        code: "no_crypto_object",
        desc: "No crypto object detected. This is required for the following operation: "
    },
    invalidCacheType: {
        code: "invalid_cache_type",
        desc: "Invalid cache type"
    },
    unexpectedAccountType: {
        code: "unexpected_account_type",
        desc: "Unexpected account type."
    },
    unexpectedCredentialType: {
        code: "unexpected_credential_type",
        desc: "Unexpected credential type."
    },
    invalidAssertion: {
        code: "invalid_assertion",
        desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
    },
    invalidClientCredential: {
        code: "invalid_client_credential",
        desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
    },
    tokenRefreshRequired: {
        code: "token_refresh_required",
        desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
    },
    userTimeoutReached: {
        code: "user_timeout_reached",
        desc: "User defined timeout for device code polling reached",
    },
    tokenClaimsRequired: {
        code: "token_claims_cnf_required_for_signedjwt",
        desc: "Cannot generate a POP jwt if the token_claims are not populated"
    },
    noAuthorizationCodeFromServer: {
        code: "authorization_code_missing_from_server_response",
        desc: "Server response does not contain an authorization code to proceed"
    },
    noAzureRegionDetected: {
        code: "no_azure_region_detected",
        desc: "No azure region was detected and no fallback was made available"
    },
    accessTokenEntityNullError: {
        code: "access_token_entity_null",
        desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
    },
    bindingKeyNotRemovedError: {
        code: "binding_key_not_removed",
        desc: "Could not remove the credential's binding key from storage."
    },
    logoutNotSupported: {
        code: "end_session_endpoint_not_supported",
        desc: "Provided authority does not support logout."
    },
    keyIdMissing: {
        code: "key_id_missing",
        desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
    }
};
/**
 * Error thrown when there is an error in the client code running on the browser.
 */
var ClientAuthError = /** @class */ (function (_super) {
    __extends(ClientAuthError, _super);
    function ClientAuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientAuthError";
        Object.setPrototypeOf(_this, ClientAuthError.prototype);
        return _this;
    }
    /**
     * Creates an error thrown when client info object doesn't decode correctly.
     * @param caughtError
     */
    ClientAuthError.createClientInfoDecodingError = function (caughtError) {
        return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
    };
    /**
     * Creates an error thrown if the client info is empty.
     * @param rawClientInfo
     */
    ClientAuthError.createClientInfoEmptyError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
    };
    /**
     * Creates an error thrown when the id token extraction errors out.
     * @param err
     */
    ClientAuthError.createTokenParsingError = function (caughtExtractionError) {
        return new ClientAuthError(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError);
    };
    /**
     * Creates an error thrown when the id token string is null or empty.
     * @param invalidRawTokenString
     */
    ClientAuthError.createTokenNullOrEmptyError = function (invalidRawTokenString) {
        return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString);
    };
    /**
     * Creates an error thrown when the endpoint discovery doesn't complete correctly.
     */
    ClientAuthError.createEndpointDiscoveryIncompleteError = function (errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
    };
    /**
     * Creates an error thrown when the fetch client throws
     */
    ClientAuthError.createNetworkError = function (endpoint, errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
    };
    /**
     * Creates an error thrown when the openid-configuration endpoint cannot be reached or does not contain the required data
     */
    ClientAuthError.createUnableToGetOpenidConfigError = function (errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail);
    };
    /**
     * Creates an error thrown when the hash cannot be deserialized.
     * @param hashParamObj
     */
    ClientAuthError.createHashNotDeserializedError = function (hashParamObj) {
        return new ClientAuthError(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
    };
    /**
     * Creates an error thrown when the state cannot be parsed.
     * @param invalidState
     */
    ClientAuthError.createInvalidStateError = function (invalidState, errorString) {
        return new ClientAuthError(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString);
    };
    /**
     * Creates an error thrown when two states do not match.
     */
    ClientAuthError.createStateMismatchError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
    };
    /**
     * Creates an error thrown when the state is not present
     * @param missingState
     */
    ClientAuthError.createStateNotFoundError = function (missingState) {
        return new ClientAuthError(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState);
    };
    /**
     * Creates an error thrown when the nonce does not match.
     */
    ClientAuthError.createNonceMismatchError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
    };
    /**
     * Creates an error thrown when the mnonce is not present
     * @param missingNonce
     */
    ClientAuthError.createNonceNotFoundError = function (missingNonce) {
        return new ClientAuthError(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce);
    };
    /**
     * Throws error when multiple tokens are in cache.
     */
    ClientAuthError.createMultipleMatchingTokensInCacheError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
    };
    /**
     * Throws error when multiple accounts are in cache for the given params
     */
    ClientAuthError.createMultipleMatchingAccountsInCacheError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
    };
    /**
     * Throws error when multiple appMetada are in cache for the given clientId.
     */
    ClientAuthError.createMultipleMatchingAppMetadataInCacheError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
    };
    /**
     * Throws error when no auth code or refresh token is given to ServerTokenRequestParameters.
     */
    ClientAuthError.createTokenRequestCannotBeMadeError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
    };
    /**
     * Throws error when attempting to append a null, undefined or empty scope to a set
     * @param givenScope
     */
    ClientAuthError.createAppendEmptyScopeToSetError = function (givenScope) {
        return new ClientAuthError(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
    };
    /**
     * Throws error when attempting to append a null, undefined or empty scope to a set
     * @param givenScope
     */
    ClientAuthError.createRemoveEmptyScopeFromSetError = function (givenScope) {
        return new ClientAuthError(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
    };
    /**
     * Throws error when attempting to append null or empty ScopeSet.
     * @param appendError
     */
    ClientAuthError.createAppendScopeSetError = function (appendError) {
        return new ClientAuthError(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
    };
    /**
     * Throws error if ScopeSet is null or undefined.
     * @param givenScopeSet
     */
    ClientAuthError.createEmptyInputScopeSetError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
    };
    /**
     * Throws error if user sets CancellationToken.cancel = true during polling of token endpoint during device code flow
     */
    ClientAuthError.createDeviceCodeCancelledError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
    };
    /**
     * Throws error if device code is expired
     */
    ClientAuthError.createDeviceCodeExpiredError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
    };
    /**
     * Throws error if device code is expired
     */
    ClientAuthError.createDeviceCodeUnknownError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
    };
    /**
     * Throws error when silent requests are made without an account object
     */
    ClientAuthError.createNoAccountInSilentRequestError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
    };
    /**
     * Throws error when cache record is null or undefined.
     */
    ClientAuthError.createNullOrUndefinedCacheRecord = function () {
        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
    };
    /**
     * Throws error when provided environment is not part of the CloudDiscoveryMetadata object
     */
    ClientAuthError.createInvalidCacheEnvironmentError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
    };
    /**
     * Throws error when account is not found in cache.
     */
    ClientAuthError.createNoAccountFoundError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
    };
    /**
     * Throws error if ICachePlugin not set on CacheManager.
     */
    ClientAuthError.createCachePluginError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
    };
    /**
     * Throws error if crypto object not found.
     * @param operationName
     */
    ClientAuthError.createNoCryptoObjectError = function (operationName) {
        return new ClientAuthError(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName);
    };
    /**
     * Throws error if cache type is invalid.
     */
    ClientAuthError.createInvalidCacheTypeError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
    };
    /**
     * Throws error if unexpected account type.
     */
    ClientAuthError.createUnexpectedAccountTypeError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
    };
    /**
     * Throws error if unexpected credential type.
     */
    ClientAuthError.createUnexpectedCredentialTypeError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
    };
    /**
     * Throws error if client assertion is not valid.
     */
    ClientAuthError.createInvalidAssertionError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
    };
    /**
     * Throws error if client assertion is not valid.
     */
    ClientAuthError.createInvalidCredentialError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
    };
    /**
     * Throws error if token cannot be retrieved from cache due to refresh being required.
     */
    ClientAuthError.createRefreshRequiredError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
    };
    /**
     * Throws error if the user defined timeout is reached.
     */
    ClientAuthError.createUserTimeoutReachedError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
    };
    /*
     * Throws error if token claims are not populated for a signed jwt generation
     */
    ClientAuthError.createTokenClaimsRequiredError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
    };
    /**
     * Throws error when the authorization code is missing from the server response
     */
    ClientAuthError.createNoAuthCodeInServerResponseError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
    };
    ClientAuthError.createBindingKeyNotRemovedError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
    };
    /**
     * Thrown when logout is attempted for an authority that doesnt have an end_session_endpoint
     */
    ClientAuthError.createLogoutNotSupportedError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
    };
    /**
     * Create an error when kid attribute is missing from a PoP token's cache record
     */
    ClientAuthError.createKeyIdMissingError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
    };
    return ClientAuthError;
}(AuthError));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * @hidden
 */
var StringUtils = /** @class */ (function () {
    function StringUtils() {
    }
    /**
     * decode a JWT
     *
     * @param authToken
     */
    StringUtils.decodeAuthToken = function (authToken) {
        if (StringUtils.isEmpty(authToken)) {
            throw ClientAuthError.createTokenNullOrEmptyError(authToken);
        }
        var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
        var matches = tokenPartsRegex.exec(authToken);
        if (!matches || matches.length < 4) {
            throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
        }
        var crackedToken = {
            header: matches[1],
            JWSPayload: matches[2],
            JWSSig: matches[3]
        };
        return crackedToken;
    };
    /**
     * Check if a string is empty.
     *
     * @param str
     */
    StringUtils.isEmpty = function (str) {
        return (typeof str === "undefined" || !str || 0 === str.length);
    };
    /**
     * Check if stringified object is empty
     * @param strObj
     */
    StringUtils.isEmptyObj = function (strObj) {
        if (strObj && !StringUtils.isEmpty(strObj)) {
            try {
                var obj = JSON.parse(strObj);
                return Object.keys(obj).length === 0;
            }
            catch (e) { }
        }
        return true;
    };
    StringUtils.startsWith = function (str, search) {
        return str.indexOf(search) === 0;
    };
    StringUtils.endsWith = function (str, search) {
        return (str.length >= search.length) && (str.lastIndexOf(search) === (str.length - search.length));
    };
    /**
     * Parses string into an object.
     *
     * @param query
     */
    StringUtils.queryStringToObject = function (query) {
        var obj = {};
        var params = query.split("&");
        var decode = function (s) { return decodeURIComponent(s.replace(/\+/g, " ")); };
        params.forEach(function (pair) {
            if (pair.trim()) {
                var _a = pair.split(/=(.+)/g, 2), key = _a[0], value = _a[1]; // Split on the first occurence of the '=' character
                if (key && value) {
                    obj[decode(key)] = decode(value);
                }
            }
        });
        return obj;
    };
    /**
     * Trims entries in an array.
     *
     * @param arr
     */
    StringUtils.trimArrayEntries = function (arr) {
        return arr.map(function (entry) { return entry.trim(); });
    };
    /**
     * Removes empty strings from array
     * @param arr
     */
    StringUtils.removeEmptyStringsFromArray = function (arr) {
        return arr.filter(function (entry) {
            return !StringUtils.isEmpty(entry);
        });
    };
    /**
     * Attempts to parse a string into JSON
     * @param str
     */
    StringUtils.jsonParseHelper = function (str) {
        try {
            return JSON.parse(str);
        }
        catch (e) {
            return null;
        }
    };
    /**
     * Tests if a given string matches a given pattern, with support for wildcards and queries.
     * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
     * @param input String to match against
     */
    StringUtils.matchPattern = function (pattern, input) {
        /**
         * Wildcard support: https://stackoverflow.com/a/3117248/4888559
         * Queries: replaces "?" in string with escaped "\?" for regex test
         */
        var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\\?")); // eslint-disable-line security/detect-non-literal-regexp
        return regex.test(input);
    };
    return StringUtils;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Log message level.
 */
exports.LogLevel = void 0;
(function (LogLevel) {
    LogLevel[LogLevel["Error"] = 0] = "Error";
    LogLevel[LogLevel["Warning"] = 1] = "Warning";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
    LogLevel[LogLevel["Trace"] = 4] = "Trace";
})(exports.LogLevel || (exports.LogLevel = {}));
/**
 * Class which facilitates logging of messages to a specific place.
 */
var Logger = /** @class */ (function () {
    function Logger(loggerOptions, packageName, packageVersion) {
        // Current log level, defaults to info.
        this.level = exports.LogLevel.Info;
        var defaultLoggerCallback = function () {
            return;
        };
        this.localCallback = loggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled || false;
        this.level = typeof (loggerOptions.logLevel) === "number" ? loggerOptions.logLevel : exports.LogLevel.Info;
        this.correlationId = loggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
    }
    /**
     * Create new Logger with existing configurations.
     */
    Logger.prototype.clone = function (packageName, packageVersion, correlationId) {
        return new Logger({ loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId }, packageName, packageVersion);
    };
    /**
     * Log message with required options.
     */
    Logger.prototype.logMessage = function (logMessage, options) {
        if ((options.logLevel > this.level) || (!this.piiLoggingEnabled && options.containsPii)) {
            return;
        }
        var timestamp = new Date().toUTCString();
        // Add correlationId to logs if set, correlationId provided on log messages take precedence
        var logHeader;
        if (!StringUtils.isEmpty(options.correlationId)) {
            logHeader = "[" + timestamp + "] : [" + options.correlationId + "]";
        }
        else if (!StringUtils.isEmpty(this.correlationId)) {
            logHeader = "[" + timestamp + "] : [" + this.correlationId + "]";
        }
        else {
            logHeader = "[" + timestamp + "]";
        }
        var log = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + exports.LogLevel[options.logLevel] + " - " + logMessage;
        // debug(`msal:${LogLevel[options.logLevel]}${options.containsPii ? "-Pii": Constants.EMPTY_STRING}${options.context ? `:${options.context}` : Constants.EMPTY_STRING}`)(logMessage);
        this.executeCallback(options.logLevel, log, options.containsPii || false);
    };
    /**
     * Execute callback with message.
     */
    Logger.prototype.executeCallback = function (level, message, containsPii) {
        if (this.localCallback) {
            this.localCallback(level, message, containsPii);
        }
    };
    /**
     * Logs error messages.
     */
    Logger.prototype.error = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Error,
            containsPii: false,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs error messages with PII.
     */
    Logger.prototype.errorPii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Error,
            containsPii: true,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs warning messages.
     */
    Logger.prototype.warning = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Warning,
            containsPii: false,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs warning messages with PII.
     */
    Logger.prototype.warningPii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Warning,
            containsPii: true,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs info messages.
     */
    Logger.prototype.info = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Info,
            containsPii: false,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs info messages with PII.
     */
    Logger.prototype.infoPii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Info,
            containsPii: true,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs verbose messages.
     */
    Logger.prototype.verbose = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Verbose,
            containsPii: false,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs verbose messages with PII.
     */
    Logger.prototype.verbosePii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Verbose,
            containsPii: true,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs trace messages.
     */
    Logger.prototype.trace = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Trace,
            containsPii: false,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Logs trace messages with PII.
     */
    Logger.prototype.tracePii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: exports.LogLevel.Trace,
            containsPii: true,
            correlationId: correlationId || Constants.EMPTY_STRING
        });
    };
    /**
     * Returns whether PII Logging is enabled or not.
     */
    Logger.prototype.isPiiLoggingEnabled = function () {
        return this.piiLoggingEnabled || false;
    };
    return Logger;
}());

/* eslint-disable header/header */
var name = "@azure/msal-common";
var version = "7.4.0";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
exports.AzureCloudInstance = void 0;
(function (AzureCloudInstance) {
    // AzureCloudInstance is not specified.
    AzureCloudInstance[AzureCloudInstance["None"] = 0] = "None";
    // Microsoft Azure public cloud
    AzureCloudInstance["AzurePublic"] = "https://login.microsoftonline.com";
    // Microsoft PPE
    AzureCloudInstance["AzurePpe"] = "https://login.windows-ppe.net";
    // Microsoft Chinese national cloud
    AzureCloudInstance["AzureChina"] = "https://login.chinacloudapi.cn";
    // Microsoft German national cloud ("Black Forest")
    AzureCloudInstance["AzureGermany"] = "https://login.microsoftonline.de";
    // US Government cloud
    AzureCloudInstance["AzureUsGovernment"] = "https://login.microsoftonline.us";
})(exports.AzureCloudInstance || (exports.AzureCloudInstance = {}));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc
 *
 * Key:Value Schema:
 *
 * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>
 *
 * Value Schema:
 * {
 *      homeAccountId: home account identifier for the auth scheme,
 *      environment: entity that issued the token, represented as a full host
 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
 *      clientId: client ID of the application
 *      secret: Actual credential as a string
 *      familyId: Family ID identifier, usually only used for refresh tokens
 *      realm: Full tenant or organizational identifier that the account belongs to
 *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.
 *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)
 *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request
 *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow
 * }
 */
var CredentialEntity = /** @class */ (function () {
    function CredentialEntity() {
    }
    /**
     * Generate Account Id key component as per the schema: <home_account_id>-<environment>
     */
    CredentialEntity.prototype.generateAccountId = function () {
        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
    };
    /**
     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>
     */
    CredentialEntity.prototype.generateCredentialId = function () {
        return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
    };
    /**
     * Generate target key component as per schema: <target>
     */
    CredentialEntity.prototype.generateTarget = function () {
        return CredentialEntity.generateTargetForCacheKey(this.target);
    };
    /**
     * generates credential key
     */
    CredentialEntity.prototype.generateCredentialKey = function () {
        return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
    };
    /**
     * returns the type of the cache (in this case credential)
     */
    CredentialEntity.prototype.generateType = function () {
        switch (this.credentialType) {
            case exports.CredentialType.ID_TOKEN:
                return exports.CacheType.ID_TOKEN;
            case exports.CredentialType.ACCESS_TOKEN:
            case exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
                return exports.CacheType.ACCESS_TOKEN;
            case exports.CredentialType.REFRESH_TOKEN:
                return exports.CacheType.REFRESH_TOKEN;
            default: {
                throw ClientAuthError.createUnexpectedCredentialTypeError();
            }
        }
    };
    /**
     * helper function to return `CredentialType`
     * @param key
     */
    CredentialEntity.getCredentialType = function (key) {
        // First keyword search will match all "AccessToken" and "AccessToken_With_AuthScheme" credentials
        if (key.indexOf(exports.CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {
            // Perform second search to differentiate between "AccessToken" and "AccessToken_With_AuthScheme" credential types
            if (key.indexOf(exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {
                return exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
            }
            return exports.CredentialType.ACCESS_TOKEN;
        }
        else if (key.indexOf(exports.CredentialType.ID_TOKEN.toLowerCase()) !== -1) {
            return exports.CredentialType.ID_TOKEN;
        }
        else if (key.indexOf(exports.CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {
            return exports.CredentialType.REFRESH_TOKEN;
        }
        return Constants.NOT_DEFINED;
    };
    /**
     * generates credential key
     * <home_account_id*>-\<environment>-<credential_type>-<client_id>-<realm\*>-<target\*>-<scheme\*>
     */
    CredentialEntity.generateCredentialCacheKey = function (homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
        var credentialKey = [
            this.generateAccountIdForCacheKey(homeAccountId, environment),
            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),
            this.generateTargetForCacheKey(target),
            this.generateClaimsHashForCacheKey(requestedClaimsHash),
            this.generateSchemeForCacheKey(tokenType)
        ];
        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    /**
     * generates Account Id for keys
     * @param homeAccountId
     * @param environment
     */
    CredentialEntity.generateAccountIdForCacheKey = function (homeAccountId, environment) {
        var accountId = [homeAccountId, environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    /**
     * Generates Credential Id for keys
     * @param credentialType
     * @param realm
     * @param clientId
     * @param familyId
     */
    CredentialEntity.generateCredentialIdForCacheKey = function (credentialType, clientId, realm, familyId) {
        var clientOrFamilyId = credentialType === exports.CredentialType.REFRESH_TOKEN
            ? familyId || clientId
            : clientId;
        var credentialId = [
            credentialType,
            clientOrFamilyId,
            realm || Constants.EMPTY_STRING,
        ];
        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    /**
     * Generate target key component as per schema: <target>
     */
    CredentialEntity.generateTargetForCacheKey = function (scopes) {
        return (scopes || Constants.EMPTY_STRING).toLowerCase();
    };
    /**
     * Generate requested claims key component as per schema: <requestedClaims>
     */
    CredentialEntity.generateClaimsHashForCacheKey = function (requestedClaimsHash) {
        return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();
    };
    /**
     * Generate scheme key componenet as per schema: <scheme>
     */
    CredentialEntity.generateSchemeForCacheKey = function (tokenType) {
        /*
         * PoP Tokens and SSH certs include scheme in cache key
         * Cast to lowercase to handle "bearer" from ADFS
         */
        return (tokenType && tokenType.toLowerCase() !== exports.AuthenticationScheme.BEARER.toLowerCase()) ? tokenType.toLowerCase() : Constants.EMPTY_STRING;
    };
    return CredentialEntity;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.
 */
var ClientConfigurationErrorMessage = {
    redirectUriNotSet: {
        code: "redirect_uri_empty",
        desc: "A redirect URI is required for all calls, and none has been set."
    },
    postLogoutUriNotSet: {
        code: "post_logout_uri_empty",
        desc: "A post logout redirect has not been set."
    },
    claimsRequestParsingError: {
        code: "claims_request_parsing_error",
        desc: "Could not parse the given claims request object."
    },
    authorityUriInsecure: {
        code: "authority_uri_insecure",
        desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
    },
    urlParseError: {
        code: "url_parse_error",
        desc: "URL could not be parsed into appropriate segments."
    },
    urlEmptyError: {
        code: "empty_url_error",
        desc: "URL was empty or null."
    },
    emptyScopesError: {
        code: "empty_input_scopes_error",
        desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
    },
    nonArrayScopesError: {
        code: "nonarray_input_scopes_error",
        desc: "Scopes cannot be passed as non-array."
    },
    clientIdSingleScopeError: {
        code: "clientid_input_scopes_error",
        desc: "Client ID can only be provided as a single scope."
    },
    invalidPrompt: {
        code: "invalid_prompt_value",
        desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create' and 'none'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",
    },
    invalidClaimsRequest: {
        code: "invalid_claims",
        desc: "Given claims parameter must be a stringified JSON object."
    },
    tokenRequestEmptyError: {
        code: "token_request_empty",
        desc: "Token request was empty and not found in cache."
    },
    logoutRequestEmptyError: {
        code: "logout_request_empty",
        desc: "The logout request was null or undefined."
    },
    invalidCodeChallengeMethod: {
        code: "invalid_code_challenge_method",
        desc: "code_challenge_method passed is invalid. Valid values are \"plain\" and \"S256\"."
    },
    invalidCodeChallengeParams: {
        code: "pkce_params_missing",
        desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
    },
    invalidCloudDiscoveryMetadata: {
        code: "invalid_cloud_discovery_metadata",
        desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
    },
    invalidAuthorityMetadata: {
        code: "invalid_authority_metadata",
        desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
    },
    untrustedAuthority: {
        code: "untrusted_authority",
        desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
    },
    invalidAzureCloudInstance: {
        code: "invalid_azure_cloud_instance",
        desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
    },
    missingSshJwk: {
        code: "missing_ssh_jwk",
        desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
    },
    missingSshKid: {
        code: "missing_ssh_kid",
        desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
    },
    missingNonceAuthenticationHeader: {
        code: "missing_nonce_authentication_header",
        desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
    },
    invalidAuthenticationHeader: {
        code: "invalid_authentication_header",
        desc: "Invalid authentication header provided"
    }
};
/**
 * Error thrown when there is an error in configuration of the MSAL.js library.
 */
var ClientConfigurationError = /** @class */ (function (_super) {
    __extends(ClientConfigurationError, _super);
    function ClientConfigurationError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientConfigurationError";
        Object.setPrototypeOf(_this, ClientConfigurationError.prototype);
        return _this;
    }
    /**
     * Creates an error thrown when the redirect uri is empty (not set by caller)
     */
    ClientConfigurationError.createRedirectUriEmptyError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
    };
    /**
     * Creates an error thrown when the post-logout redirect uri is empty (not set by caller)
     */
    ClientConfigurationError.createPostLogoutRedirectUriEmptyError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
    };
    /**
     * Creates an error thrown when the claims request could not be successfully parsed
     */
    ClientConfigurationError.createClaimsRequestParsingError = function (claimsRequestParseError) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
    };
    /**
     * Creates an error thrown if authority uri is given an insecure protocol.
     * @param urlString
     */
    ClientConfigurationError.createInsecureAuthorityUriError = function (urlString) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
    };
    /**
     * Creates an error thrown if URL string does not parse into separate segments.
     * @param urlString
     */
    ClientConfigurationError.createUrlParseError = function (urlParseError) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
    };
    /**
     * Creates an error thrown if URL string is empty or null.
     * @param urlString
     */
    ClientConfigurationError.createUrlEmptyError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
    };
    /**
     * Error thrown when scopes are empty.
     * @param scopesValue
     */
    ClientConfigurationError.createEmptyScopesArrayError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
    };
    /**
     * Error thrown when client id scope is not provided as single scope.
     * @param inputScopes
     */
    ClientConfigurationError.createClientIdSingleScopeError = function (inputScopes) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
    };
    /**
     * Error thrown when prompt is not an allowed type.
     * @param promptValue
     */
    ClientConfigurationError.createInvalidPromptError = function (promptValue) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
    };
    /**
     * Creates error thrown when claims parameter is not a stringified JSON object
     */
    ClientConfigurationError.createInvalidClaimsRequestError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
    };
    /**
     * Throws error when token request is empty and nothing cached in storage.
     */
    ClientConfigurationError.createEmptyLogoutRequestError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
    };
    /**
     * Throws error when token request is empty and nothing cached in storage.
     */
    ClientConfigurationError.createEmptyTokenRequestError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
    };
    /**
     * Throws error when an invalid code_challenge_method is passed by the user
     */
    ClientConfigurationError.createInvalidCodeChallengeMethodError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
    };
    /**
     * Throws error when both params: code_challenge and code_challenge_method are not passed together
     */
    ClientConfigurationError.createInvalidCodeChallengeParamsError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
    };
    /**
     * Throws an error when the user passes invalid cloudDiscoveryMetadata
     */
    ClientConfigurationError.createInvalidCloudDiscoveryMetadataError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
    };
    /**
     * Throws an error when the user passes invalid cloudDiscoveryMetadata
     */
    ClientConfigurationError.createInvalidAuthorityMetadataError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
    };
    /**
     * Throws error when provided authority is not a member of the trusted host list
     */
    ClientConfigurationError.createUntrustedAuthorityError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
    };
    /**
     * Throws error when the AzureCloudInstance is set to an invalid value
     */
    ClientConfigurationError.createInvalidAzureCloudInstanceError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
    };
    /**
     * Throws an error when the authentication scheme is set to SSH but the SSH public key is omitted from the request
     */
    ClientConfigurationError.createMissingSshJwkError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
    };
    /**
     * Throws an error when the authentication scheme is set to SSH but the SSH public key ID is omitted from the request
     */
    ClientConfigurationError.createMissingSshKidError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
    };
    /**
     * Throws error when provided headers don't contain a header that a server nonce can be extracted from
     */
    ClientConfigurationError.createMissingNonceAuthenticationHeadersError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
    };
    /**
     * Throws error when a provided header is invalid in any way
     */
    ClientConfigurationError.createInvalidAuthenticationHeaderError = function (invalidHeaderName, details) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details);
    };
    return ClientConfigurationError;
}(ClientAuthError));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes
 * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings in intersection and union functions
 * to ensure uniqueness of strings.
 */
var ScopeSet = /** @class */ (function () {
    function ScopeSet(inputScopes) {
        var _this = this;
        // Filter empty string and null/undefined array items
        var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
        var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        // Validate and filter scopes (validate function throws if validation fails)
        this.validateInputScopes(filteredInput);
        this.scopes = new Set(); // Iterator in constructor not supported by IE11
        filteredInput.forEach(function (scope) { return _this.scopes.add(scope); });
    }
    /**
     * Factory method to create ScopeSet from space-delimited string
     * @param inputScopeString
     * @param appClientId
     * @param scopesRequired
     */
    ScopeSet.fromString = function (inputScopeString) {
        var scopeString = inputScopeString || Constants.EMPTY_STRING;
        var inputScopes = scopeString.split(" ");
        return new ScopeSet(inputScopes);
    };
    /**
     * Used to validate the scopes input parameter requested  by the developer.
     * @param {Array<string>} inputScopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.
     * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not
     */
    ScopeSet.prototype.validateInputScopes = function (inputScopes) {
        // Check if scopes are required but not given or is an empty array
        if (!inputScopes || inputScopes.length < 1) {
            throw ClientConfigurationError.createEmptyScopesArrayError();
        }
    };
    /**
     * Check if a given scope is present in this set of scopes.
     * @param scope
     */
    ScopeSet.prototype.containsScope = function (scope) {
        var lowerCaseScopes = this.printScopesLowerCase().split(" ");
        var lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);
        // compare lowercase scopes
        return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
    };
    /**
     * Check if a set of scopes is present in this set of scopes.
     * @param scopeSet
     */
    ScopeSet.prototype.containsScopeSet = function (scopeSet) {
        var _this = this;
        if (!scopeSet || scopeSet.scopes.size <= 0) {
            return false;
        }
        return (this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function (scope) { return _this.containsScope(scope); }));
    };
    /**
     * Check if set of scopes contains only the defaults
     */
    ScopeSet.prototype.containsOnlyOIDCScopes = function () {
        var _this = this;
        var defaultScopeCount = 0;
        OIDC_SCOPES.forEach(function (defaultScope) {
            if (_this.containsScope(defaultScope)) {
                defaultScopeCount += 1;
            }
        });
        return this.scopes.size === defaultScopeCount;
    };
    /**
     * Appends single scope if passed
     * @param newScope
     */
    ScopeSet.prototype.appendScope = function (newScope) {
        if (!StringUtils.isEmpty(newScope)) {
            this.scopes.add(newScope.trim());
        }
    };
    /**
     * Appends multiple scopes if passed
     * @param newScopes
     */
    ScopeSet.prototype.appendScopes = function (newScopes) {
        var _this = this;
        try {
            newScopes.forEach(function (newScope) { return _this.appendScope(newScope); });
        }
        catch (e) {
            throw ClientAuthError.createAppendScopeSetError(e);
        }
    };
    /**
     * Removes element from set of scopes.
     * @param scope
     */
    ScopeSet.prototype.removeScope = function (scope) {
        if (StringUtils.isEmpty(scope)) {
            throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
        }
        this.scopes.delete(scope.trim());
    };
    /**
     * Removes default scopes from set of scopes
     * Primarily used to prevent cache misses if the default scopes are not returned from the server
     */
    ScopeSet.prototype.removeOIDCScopes = function () {
        var _this = this;
        OIDC_SCOPES.forEach(function (defaultScope) {
            _this.scopes.delete(defaultScope);
        });
    };
    /**
     * Combines an array of scopes with the current set of scopes.
     * @param otherScopes
     */
    ScopeSet.prototype.unionScopeSets = function (otherScopes) {
        if (!otherScopes) {
            throw ClientAuthError.createEmptyInputScopeSetError();
        }
        var unionScopes = new Set(); // Iterator in constructor not supported in IE11
        otherScopes.scopes.forEach(function (scope) { return unionScopes.add(scope.toLowerCase()); });
        this.scopes.forEach(function (scope) { return unionScopes.add(scope.toLowerCase()); });
        return unionScopes;
    };
    /**
     * Check if scopes intersect between this set and another.
     * @param otherScopes
     */
    ScopeSet.prototype.intersectingScopeSets = function (otherScopes) {
        if (!otherScopes) {
            throw ClientAuthError.createEmptyInputScopeSetError();
        }
        // Do not allow OIDC scopes to be the only intersecting scopes
        if (!otherScopes.containsOnlyOIDCScopes()) {
            otherScopes.removeOIDCScopes();
        }
        var unionScopes = this.unionScopeSets(otherScopes);
        var sizeOtherScopes = otherScopes.getScopeCount();
        var sizeThisScopes = this.getScopeCount();
        var sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < (sizeThisScopes + sizeOtherScopes);
    };
    /**
     * Returns size of set of scopes.
     */
    ScopeSet.prototype.getScopeCount = function () {
        return this.scopes.size;
    };
    /**
     * Returns the scopes as an array of string values
     */
    ScopeSet.prototype.asArray = function () {
        var array = [];
        this.scopes.forEach(function (val) { return array.push(val); });
        return array;
    };
    /**
     * Prints scopes into a space-delimited string
     */
    ScopeSet.prototype.printScopes = function () {
        if (this.scopes) {
            var scopeArr = this.asArray();
            return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
    };
    /**
     * Prints scopes into a space-delimited lower-case string (used for caching)
     */
    ScopeSet.prototype.printScopesLowerCase = function () {
        return this.printScopes().toLowerCase();
    };
    return ScopeSet;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Function to build a client info object from server clientInfo string
 * @param rawClientInfo
 * @param crypto
 */
function buildClientInfo(rawClientInfo, crypto) {
    if (StringUtils.isEmpty(rawClientInfo)) {
        throw ClientAuthError.createClientInfoEmptyError();
    }
    try {
        var decodedClientInfo = crypto.base64Decode(rawClientInfo);
        return JSON.parse(decodedClientInfo);
    }
    catch (e) {
        throw ClientAuthError.createClientInfoDecodingError(e.message);
    }
}
/**
 * Function to build a client info object from cached homeAccountId string
 * @param homeAccountId
 */
function buildClientInfoFromHomeAccountId(homeAccountId) {
    if (StringUtils.isEmpty(homeAccountId)) {
        throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
    }
    var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
    return {
        uid: clientInfoParts[0],
        utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
    };
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Authority types supported by MSAL.
 */
exports.AuthorityType = void 0;
(function (AuthorityType) {
    AuthorityType[AuthorityType["Default"] = 0] = "Default";
    AuthorityType[AuthorityType["Adfs"] = 1] = "Adfs";
})(exports.AuthorityType || (exports.AuthorityType = {}));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).
 *
 * Key : Value Schema
 *
 * Key: <home_account_id>-<environment>-<realm*>
 *
 * Value Schema:
 * {
 *      homeAccountId: home account identifier for the auth scheme,
 *      environment: entity that issued the token, represented as a full host
 *      realm: Full tenant or organizational identifier that the account belongs to
 *      localAccountId: Original tenant-specific accountID, usually used for legacy cases
 *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt
 *      authorityType: Accounts authority type as a string
 *      name: Full name for the account, including given name and family name,
 *      clientInfo: Full base64 encoded client info received from ESTS
 *      lastModificationTime: last time this entity was modified in the cache
 *      lastModificationApp:
 *      idTokenClaims: Object containing claims parsed from ID token
 *      nativeAccountId: Account identifier on the native device
 * }
 */
var AccountEntity = /** @class */ (function () {
    function AccountEntity() {
    }
    /**
     * Generate Account Id key component as per the schema: <home_account_id>-<environment>
     */
    AccountEntity.prototype.generateAccountId = function () {
        var accountId = [this.homeAccountId, this.environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    /**
     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>
     */
    AccountEntity.prototype.generateAccountKey = function () {
        return AccountEntity.generateAccountCacheKey({
            homeAccountId: this.homeAccountId,
            environment: this.environment,
            tenantId: this.realm,
            username: this.username,
            localAccountId: this.localAccountId
        });
    };
    /**
     * returns the type of the cache (in this case account)
     */
    AccountEntity.prototype.generateType = function () {
        switch (this.authorityType) {
            case exports.CacheAccountType.ADFS_ACCOUNT_TYPE:
                return exports.CacheType.ADFS;
            case exports.CacheAccountType.MSAV1_ACCOUNT_TYPE:
                return exports.CacheType.MSA;
            case exports.CacheAccountType.MSSTS_ACCOUNT_TYPE:
                return exports.CacheType.MSSTS;
            case exports.CacheAccountType.GENERIC_ACCOUNT_TYPE:
                return exports.CacheType.GENERIC;
            default: {
                throw ClientAuthError.createUnexpectedAccountTypeError();
            }
        }
    };
    /**
     * Returns the AccountInfo interface for this account.
     */
    AccountEntity.prototype.getAccountInfo = function () {
        return {
            homeAccountId: this.homeAccountId,
            environment: this.environment,
            tenantId: this.realm,
            username: this.username,
            localAccountId: this.localAccountId,
            name: this.name,
            idTokenClaims: this.idTokenClaims,
            nativeAccountId: this.nativeAccountId
        };
    };
    /**
     * Generates account key from interface
     * @param accountInterface
     */
    AccountEntity.generateAccountCacheKey = function (accountInterface) {
        var accountKey = [
            accountInterface.homeAccountId,
            accountInterface.environment || Constants.EMPTY_STRING,
            accountInterface.tenantId || Constants.EMPTY_STRING,
        ];
        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    /**
     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
     * @param clientInfo
     * @param authority
     * @param idToken
     * @param policy
     */
    AccountEntity.createAccount = function (clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
        var _a, _b, _c, _d, _e, _f;
        var account = new AccountEntity();
        account.authorityType = exports.CacheAccountType.MSSTS_ACCOUNT_TYPE;
        account.clientInfo = clientInfo;
        account.homeAccountId = homeAccountId;
        account.nativeAccountId = nativeAccountId;
        var env = environment || (authority && authority.getPreferredCache());
        if (!env) {
            throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        account.environment = env;
        // non AAD scenarios can have empty realm
        account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || Constants.EMPTY_STRING;
        if (idToken) {
            account.idTokenClaims = idToken.claims;
            // How do you account for MSA CID here?
            account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;
            /*
             * In B2C scenarios the emails claim is used instead of preferred_username and it is an array. In most cases it will contain a single email.
             * This field should not be relied upon if a custom policy is configured to return more than 1 email.
             */
            account.username = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username) || (((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : Constants.EMPTY_STRING);
            account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;
        }
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account;
    };
    /**
     * Builds non-AAD/ADFS account.
     * @param authority
     * @param idToken
     */
    AccountEntity.createGenericAccount = function (homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {
        var _a, _b, _c, _d;
        var account = new AccountEntity();
        account.authorityType = (authority && authority.authorityType === exports.AuthorityType.Adfs) ? exports.CacheAccountType.ADFS_ACCOUNT_TYPE : exports.CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = homeAccountId;
        // non AAD scenarios can have empty realm
        account.realm = Constants.EMPTY_STRING;
        var env = environment || authority && authority.getPreferredCache();
        if (!env) {
            throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        if (idToken) {
            // How do you account for MSA CID here?
            account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING;
            // upn claim for most ADFS scenarios
            account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;
            account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;
            account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;
        }
        account.environment = env;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        /*
         * add uniqueName to claims
         * account.name = idToken.claims.uniqueName;
         */
        return account;
    };
    /**
     * Generate HomeAccountId from server response
     * @param serverClientInfo
     * @param authType
     */
    AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idToken) {
        var _a;
        var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;
        // since ADFS does not have tid and does not set client_info
        if (authType === exports.AuthorityType.Adfs) {
            return accountId;
        }
        // for cases where there is clientInfo
        if (serverClientInfo) {
            try {
                var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
                if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
                    return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;
                }
            }
            catch (e) { }
        }
        // default to "sub" claim
        logger.verbose("No client info in response");
        return accountId;
    };
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    AccountEntity.isAccountEntity = function (entity) {
        if (!entity) {
            return false;
        }
        return (entity.hasOwnProperty("homeAccountId") &&
            entity.hasOwnProperty("environment") &&
            entity.hasOwnProperty("realm") &&
            entity.hasOwnProperty("localAccountId") &&
            entity.hasOwnProperty("username") &&
            entity.hasOwnProperty("authorityType"));
    };
    /**
     * Helper function to determine whether 2 accountInfo objects represent the same account
     * @param accountA
     * @param accountB
     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
     */
    AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
            return false;
        }
        var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false
        if (compareClaims) {
            var accountAClaims = (accountA.idTokenClaims || {});
            var accountBClaims = (accountB.idTokenClaims || {});
            // issued at timestamp and nonce are expected to change each time a new id token is acquired
            claimsMatch = (accountAClaims.iat === accountBClaims.iat) &&
                (accountAClaims.nonce === accountBClaims.nonce);
        }
        return (accountA.homeAccountId === accountB.homeAccountId) &&
            (accountA.localAccountId === accountB.localAccountId) &&
            (accountA.username === accountB.username) &&
            (accountA.tenantId === accountB.tenantId) &&
            (accountA.environment === accountB.environment) &&
            (accountA.nativeAccountId === accountB.nativeAccountId) &&
            claimsMatch;
    };
    return AccountEntity;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * JWT Token representation class. Parses token string and generates claims object.
 */
var AuthToken = /** @class */ (function () {
    function AuthToken(rawToken, crypto) {
        if (StringUtils.isEmpty(rawToken)) {
            throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
        }
        this.rawToken = rawToken;
        this.claims = AuthToken.extractTokenClaims(rawToken, crypto);
    }
    /**
     * Extract token by decoding the rawToken
     *
     * @param encodedToken
     */
    AuthToken.extractTokenClaims = function (encodedToken, crypto) {
        var decodedToken = StringUtils.decodeAuthToken(encodedToken);
        // token will be decoded to get the username
        try {
            var base64TokenPayload = decodedToken.JWSPayload;
            // base64Decode() should throw an error if there is an issue
            var base64Decoded = crypto.base64Decode(base64TokenPayload);
            return JSON.parse(base64Decoded);
        }
        catch (err) {
            throw ClientAuthError.createTokenParsingError(err);
        }
    };
    return AuthToken;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.
 */
var CacheManager = /** @class */ (function () {
    function CacheManager(clientId, cryptoImpl) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
    }
    /**
     * Returns all accounts in cache
     */
    CacheManager.prototype.getAllAccounts = function () {
        var _this = this;
        var currentAccounts = this.getAccountsFilteredBy();
        var accountValues = Object.keys(currentAccounts).map(function (accountKey) { return currentAccounts[accountKey]; });
        var numAccounts = accountValues.length;
        if (numAccounts < 1) {
            return [];
        }
        else {
            var allAccounts = accountValues.map(function (value) {
                var accountEntity = CacheManager.toObject(new AccountEntity(), value);
                var accountInfo = accountEntity.getAccountInfo();
                var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);
                if (idToken && !accountInfo.idTokenClaims) {
                    accountInfo.idToken = idToken.secret;
                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;
                }
                return accountInfo;
            });
            return allAccounts;
        }
    };
    /**
     * saves a cache record
     * @param cacheRecord
     */
    CacheManager.prototype.saveCacheRecord = function (cacheRecord) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!cacheRecord) {
                            throw ClientAuthError.createNullOrUndefinedCacheRecord();
                        }
                        if (!!cacheRecord.account) {
                            this.setAccount(cacheRecord.account);
                        }
                        if (!!cacheRecord.idToken) {
                            this.setIdTokenCredential(cacheRecord.idToken);
                        }
                        if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!!cacheRecord.refreshToken) {
                            this.setRefreshTokenCredential(cacheRecord.refreshToken);
                        }
                        if (!!cacheRecord.appMetadata) {
                            this.setAppMetadata(cacheRecord.appMetadata);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * saves access token credential
     * @param credential
     */
    CacheManager.prototype.saveAccessToken = function (credential) {
        return __awaiter(this, void 0, void 0, function () {
            var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentTokenCache = this.getCredentialsFilteredBy({
                            clientId: credential.clientId,
                            credentialType: credential.credentialType,
                            environment: credential.environment,
                            homeAccountId: credential.homeAccountId,
                            realm: credential.realm,
                            tokenType: credential.tokenType,
                            requestedClaimsHash: credential.requestedClaimsHash
                        });
                        currentScopes = ScopeSet.fromString(credential.target);
                        currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) { return currentTokenCache.accessTokens[key]; });
                        if (!currentAccessTokens) return [3 /*break*/, 2];
                        removedAccessTokens_1 = [];
                        currentAccessTokens.forEach(function (tokenEntity) {
                            var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
                            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
                                removedAccessTokens_1.push(_this.removeCredential(tokenEntity));
                            }
                        });
                        return [4 /*yield*/, Promise.all(removedAccessTokens_1)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.setAccessTokenCredential(credential);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * retrieve accounts matching all provided filters; if no filter is set, get all accounts
     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
     * @param homeAccountId
     * @param environment
     * @param realm
     */
    CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {
        return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);
    };
    /**
     * retrieve accounts matching all provided filters; if no filter is set, get all accounts
     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
     * @param homeAccountId
     * @param environment
     * @param realm
     */
    CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm, nativeAccountId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAccounts = {};
        allCacheKeys.forEach(function (cacheKey) {
            var entity = _this.getAccount(cacheKey);
            if (!entity) {
                return;
            }
            if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
                return;
            }
            if (!!environment && !_this.matchEnvironment(entity, environment)) {
                return;
            }
            if (!!realm && !_this.matchRealm(entity, realm)) {
                return;
            }
            if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {
                return;
            }
            matchingAccounts[cacheKey] = entity;
        });
        return matchingAccounts;
    };
    /**
     * retrieve credentails matching all provided filters; if no filter is set, get all credentials
     * @param homeAccountId
     * @param environment
     * @param credentialType
     * @param clientId
     * @param realm
     * @param target
     */
    CacheManager.prototype.getCredentialsFilteredBy = function (filter) {
        return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);
    };
    /**
     * Support function to help match credentials
     * @param homeAccountId
     * @param environment
     * @param credentialType
     * @param clientId
     * @param realm
     * @param target
     * @param userAssertionHash
     * @param tokenType
     */
    CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingCredentials = {
            idTokens: {},
            accessTokens: {},
            refreshTokens: {},
        };
        allCacheKeys.forEach(function (cacheKey) {
            // don't parse any non-credential type cache entities
            var credType = CredentialEntity.getCredentialType(cacheKey);
            if (credType === Constants.NOT_DEFINED) {
                return;
            }
            // Attempt retrieval
            var entity = _this.getSpecificCredential(cacheKey, credType);
            if (!entity) {
                return;
            }
            if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {
                return;
            }
            if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
                return;
            }
            if (!!environment && !_this.matchEnvironment(entity, environment)) {
                return;
            }
            if (!!realm && !_this.matchRealm(entity, realm)) {
                return;
            }
            if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {
                return;
            }
            if (!!clientId && !_this.matchClientId(entity, clientId)) {
                return;
            }
            if (!!familyId && !_this.matchFamilyId(entity, familyId)) {
                return;
            }
            /*
             * idTokens do not have "target", target specific refreshTokens do exist for some types of authentication
             * Resource specific refresh tokens case will be added when the support is deemed necessary
             */
            if (!!target && !_this.matchTarget(entity, target)) {
                return;
            }
            // If request OR cached entity has requested Claims Hash, check if they match
            if (requestedClaimsHash || entity.requestedClaimsHash) {
                // Don't match if either is undefined or they are different
                if (entity.requestedClaimsHash !== requestedClaimsHash) {
                    return;
                }
            }
            // Access Token with Auth Scheme specific matching
            if (credentialType === exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
                if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {
                    return;
                }
                // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key
                if (tokenType === exports.AuthenticationScheme.SSH) {
                    if (keyId && !_this.matchKeyId(entity, keyId)) {
                        return;
                    }
                }
            }
            // At this point, the entity matches the request, update cache key if key schema has changed
            var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);
            switch (credType) {
                case exports.CredentialType.ID_TOKEN:
                    matchingCredentials.idTokens[updatedCacheKey] = entity;
                    break;
                case exports.CredentialType.ACCESS_TOKEN:
                case exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
                    matchingCredentials.accessTokens[updatedCacheKey] = entity;
                    break;
                case exports.CredentialType.REFRESH_TOKEN:
                    matchingCredentials.refreshTokens[updatedCacheKey] = entity;
                    break;
            }
        });
        return matchingCredentials;
    };
    /**
     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
     * @param filter
     */
    CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {
        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);
    };
    /**
     * Support function to help match appMetadata
     * @param environment
     * @param clientId
     */
    CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAppMetadata = {};
        allCacheKeys.forEach(function (cacheKey) {
            // don't parse any non-appMetadata type cache entities
            if (!_this.isAppMetadata(cacheKey)) {
                return;
            }
            // Attempt retrieval
            var entity = _this.getAppMetadata(cacheKey);
            if (!entity) {
                return;
            }
            if (!!environment && !_this.matchEnvironment(entity, environment)) {
                return;
            }
            if (!!clientId && !_this.matchClientId(entity, clientId)) {
                return;
            }
            matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
    };
    /**
     * retrieve authorityMetadata that contains a matching alias
     * @param filter
     */
    CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {
        var _this = this;
        var allCacheKeys = this.getAuthorityMetadataKeys();
        var matchedEntity = null;
        allCacheKeys.forEach(function (cacheKey) {
            // don't parse any non-authorityMetadata type cache entities
            if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
                return;
            }
            // Attempt retrieval
            var entity = _this.getAuthorityMetadata(cacheKey);
            if (!entity) {
                return;
            }
            if (entity.aliases.indexOf(host) === -1) {
                return;
            }
            matchedEntity = entity;
        });
        return matchedEntity;
    };
    /**
     * Removes all accounts and related tokens from cache.
     */
    CacheManager.prototype.removeAllAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            var allCacheKeys, removedAccounts;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        allCacheKeys = this.getKeys();
                        removedAccounts = [];
                        allCacheKeys.forEach(function (cacheKey) {
                            var entity = _this.getAccount(cacheKey);
                            if (!entity) {
                                return;
                            }
                            removedAccounts.push(_this.removeAccount(cacheKey));
                        });
                        return [4 /*yield*/, Promise.all(removedAccounts)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, true];
                }
            });
        });
    };
    /**
     * returns a boolean if the given account is removed
     * @param account
     */
    CacheManager.prototype.removeAccount = function (accountKey) {
        return __awaiter(this, void 0, void 0, function () {
            var account;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        account = this.getAccount(accountKey);
                        if (!account) {
                            throw ClientAuthError.createNoAccountFoundError();
                        }
                        return [4 /*yield*/, this.removeAccountContext(account)];
                    case 1: return [2 /*return*/, ((_a.sent()) && this.removeItem(accountKey, exports.CacheSchemaType.ACCOUNT))];
                }
            });
        });
    };
    /**
     * Removes credentials associated with the provided account
     * @param account
     */
    CacheManager.prototype.removeAccountContext = function (account) {
        return __awaiter(this, void 0, void 0, function () {
            var allCacheKeys, accountId, removedCredentials;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        allCacheKeys = this.getKeys();
                        accountId = account.generateAccountId();
                        removedCredentials = [];
                        allCacheKeys.forEach(function (cacheKey) {
                            // don't parse any non-credential type cache entities
                            var credType = CredentialEntity.getCredentialType(cacheKey);
                            if (credType === Constants.NOT_DEFINED) {
                                return;
                            }
                            var cacheEntity = _this.getSpecificCredential(cacheKey, credType);
                            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {
                                removedCredentials.push(_this.removeCredential(cacheEntity));
                            }
                        });
                        return [4 /*yield*/, Promise.all(removedCredentials)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, true];
                }
            });
        });
    };
    /**
     * returns a boolean if the given credential is removed
     * @param credential
     */
    CacheManager.prototype.removeCredential = function (credential) {
        return __awaiter(this, void 0, void 0, function () {
            var key, accessTokenWithAuthSchemeEntity, kid;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        key = credential.generateCredentialKey();
                        if (!(credential.credentialType.toLowerCase() === exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];
                        if (!(credential.tokenType === exports.AuthenticationScheme.POP)) return [3 /*break*/, 4];
                        accessTokenWithAuthSchemeEntity = credential;
                        kid = accessTokenWithAuthSchemeEntity.keyId;
                        if (!kid) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a.sent();
                        throw ClientAuthError.createBindingKeyNotRemovedError();
                    case 4: return [2 /*return*/, this.removeItem(key, exports.CacheSchemaType.CREDENTIAL)];
                }
            });
        });
    };
    /**
     * Removes all app metadata objects from cache.
     */
    CacheManager.prototype.removeAppMetadata = function () {
        var _this = this;
        var allCacheKeys = this.getKeys();
        allCacheKeys.forEach(function (cacheKey) {
            if (_this.isAppMetadata(cacheKey)) {
                _this.removeItem(cacheKey, exports.CacheSchemaType.APP_METADATA);
            }
        });
        return true;
    };
    /**
     * Retrieve the cached credentials into a cacherecord
     * @param account
     * @param clientId
     * @param scopes
     * @param environment
     * @param authScheme
     */
    CacheManager.prototype.readCacheRecord = function (account, clientId, request, environment) {
        var cachedAccount = this.readAccountFromCache(account);
        var cachedIdToken = this.readIdTokenFromCache(clientId, account);
        var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);
        var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);
        var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);
        if (cachedAccount && cachedIdToken) {
            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;
        }
        return {
            account: cachedAccount,
            idToken: cachedIdToken,
            accessToken: cachedAccessToken,
            refreshToken: cachedRefreshToken,
            appMetadata: cachedAppMetadata,
        };
    };
    /**
     * Retrieve AccountEntity from cache
     * @param account
     */
    CacheManager.prototype.readAccountFromCache = function (account) {
        var accountKey = AccountEntity.generateAccountCacheKey(account);
        return this.getAccount(accountKey);
    };
    /**
     * Retrieve AccountEntity from cache
     * @param nativeAccountId
     * @returns AccountEntity or Null
     */
    CacheManager.prototype.readAccountFromCacheWithNativeAccountId = function (nativeAccountId) {
        // fetch account from memory
        var accountFilter = {
            nativeAccountId: nativeAccountId
        };
        var accountCache = this.getAccountsFilteredBy(accountFilter);
        var accounts = Object.keys(accountCache).map(function (key) { return accountCache[key]; });
        if (accounts.length < 1) {
            return null;
        }
        else if (accounts.length > 1) {
            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();
        }
        return accountCache[0];
    };
    /**
     * Retrieve IdTokenEntity from cache
     * @param clientId
     * @param account
     * @param inputRealm
     */
    CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {
        var idTokenFilter = {
            homeAccountId: account.homeAccountId,
            environment: account.environment,
            credentialType: exports.CredentialType.ID_TOKEN,
            clientId: clientId,
            realm: account.tenantId,
        };
        var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function (key) { return credentialCache.idTokens[key]; });
        var numIdTokens = idTokens.length;
        if (numIdTokens < 1) {
            return null;
        }
        else if (numIdTokens > 1) {
            throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return idTokens[0];
    };
    /**
     * Retrieve AccessTokenEntity from cache
     * @param clientId
     * @param account
     * @param scopes
     * @param authScheme
     */
    CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, request) {
        var scopes = new ScopeSet(request.scopes || []);
        var authScheme = request.authenticationScheme || exports.AuthenticationScheme.BEARER;
        /*
         * Distinguish between Bearer and PoP/SSH token cache types
         * Cast to lowercase to handle "bearer" from ADFS
         */
        var credentialType = (authScheme && authScheme.toLowerCase() !== exports.AuthenticationScheme.BEARER.toLowerCase()) ? exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : exports.CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
            homeAccountId: account.homeAccountId,
            environment: account.environment,
            credentialType: credentialType,
            clientId: clientId,
            realm: account.tenantId,
            target: scopes.printScopesLowerCase(),
            tokenType: authScheme,
            keyId: request.sshKid,
            requestedClaimsHash: request.requestedClaimsHash,
        };
        var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) { return credentialCache.accessTokens[key]; });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
            return null;
        }
        else if (numAccessTokens > 1) {
            throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
    };
    /**
     * Helper to retrieve the appropriate refresh token from cache
     * @param clientId
     * @param account
     * @param familyRT
     */
    CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {
        var id = familyRT ? THE_FAMILY_ID : undefined;
        var refreshTokenFilter = {
            homeAccountId: account.homeAccountId,
            environment: account.environment,
            credentialType: exports.CredentialType.REFRESH_TOKEN,
            clientId: clientId,
            familyId: id,
        };
        var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);
        var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) { return credentialCache.refreshTokens[key]; });
        var numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
            return null;
        }
        // address the else case after remove functions address environment aliases
        return refreshTokens[0];
    };
    /**
     * Retrieve AppMetadataEntity from cache
     */
    CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {
        var appMetadataFilter = {
            environment: environment,
            clientId: clientId,
        };
        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        var appMetadataEntries = Object.keys(appMetadata).map(function (key) { return appMetadata[key]; });
        var numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
            return null;
        }
        else if (numAppMetadata > 1) {
            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
        }
        return appMetadataEntries[0];
    };
    /**
     * Return the family_id value associated  with FOCI
     * @param environment
     * @param clientId
     */
    CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {
        var appMetadata = this.readAppMetadataFromCache(environment, clientId);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
    };
    /**
     * helper to match account ids
     * @param value
     * @param homeAccountId
     */
    CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {
        return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);
    };
    /**
     * helper to match assertion
     * @param value
     * @param oboAssertion
     */
    CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
    };
    /**
     * helper to match environment
     * @param value
     * @param environment
     */
    CacheManager.prototype.matchEnvironment = function (entity, environment) {
        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
            return true;
        }
        return false;
    };
    /**
     * helper to match credential type
     * @param entity
     * @param credentialType
     */
    CacheManager.prototype.matchCredentialType = function (entity, credentialType) {
        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());
    };
    /**
     * helper to match client ids
     * @param entity
     * @param clientId
     */
    CacheManager.prototype.matchClientId = function (entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
    };
    /**
     * helper to match family ids
     * @param entity
     * @param familyId
     */
    CacheManager.prototype.matchFamilyId = function (entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
    };
    /**
     * helper to match realm
     * @param entity
     * @param realm
     */
    CacheManager.prototype.matchRealm = function (entity, realm) {
        return !!(entity.realm && realm === entity.realm);
    };
    /**
     * helper to match nativeAccountId
     * @param entity
     * @param nativeAccountId
     * @returns boolean indicating the match result
     */
    CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
    };
    /**
     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
     * @param entity
     * @param target
     */
    CacheManager.prototype.matchTarget = function (entity, target) {
        var isNotAccessTokenCredential = (entity.credentialType !== exports.CredentialType.ACCESS_TOKEN && entity.credentialType !== exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
        if (isNotAccessTokenCredential || !entity.target) {
            return false;
        }
        var entityScopeSet = ScopeSet.fromString(entity.target);
        var requestTargetScopeSet = ScopeSet.fromString(target);
        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {
            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes
        }
        else {
            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return entityScopeSet.containsScopeSet(requestTargetScopeSet);
    };
    /**
     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
     * @param entity
     * @param tokenType
     */
    CacheManager.prototype.matchTokenType = function (entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
    };
    /**
     * Returns true if the credential's keyId matches the one in the request, false otherwise
     * @param entity
     * @param tokenType
     */
    CacheManager.prototype.matchKeyId = function (entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
    };
    /**
     * returns if a given cache entity is of the type appmetadata
     * @param key
     */
    CacheManager.prototype.isAppMetadata = function (key) {
        return key.indexOf(APP_METADATA) !== -1;
    };
    /**
     * returns if a given cache entity is of the type authoritymetadata
     * @param key
     */
    CacheManager.prototype.isAuthorityMetadata = function (key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
    };
    /**
     * returns cache key used for cloud instance metadata
     */
    CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {
        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority;
    };
    /**
     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache
     * @param key
     * @param credType
     */
    CacheManager.prototype.getSpecificCredential = function (key, credType) {
        switch (credType) {
            case exports.CredentialType.ID_TOKEN: {
                return this.getIdTokenCredential(key);
            }
            case exports.CredentialType.ACCESS_TOKEN:
            case exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {
                return this.getAccessTokenCredential(key);
            }
            case exports.CredentialType.REFRESH_TOKEN: {
                return this.getRefreshTokenCredential(key);
            }
            default:
                return null;
        }
    };
    /**
     * Helper to convert serialized data to object
     * @param obj
     * @param json
     */
    CacheManager.toObject = function (obj, json) {
        for (var propertyName in json) {
            obj[propertyName] = json[propertyName];
        }
        return obj;
    };
    return CacheManager;
}());
var DefaultStorageClass = /** @class */ (function (_super) {
    __extends(DefaultStorageClass, _super);
    function DefaultStorageClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultStorageClass.prototype.setAccount = function () {
        var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getAccount = function () {
        var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setIdTokenCredential = function () {
        var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getIdTokenCredential = function () {
        var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setAccessTokenCredential = function () {
        var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getAccessTokenCredential = function () {
        var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setRefreshTokenCredential = function () {
        var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getRefreshTokenCredential = function () {
        var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setAppMetadata = function () {
        var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getAppMetadata = function () {
        var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setServerTelemetry = function () {
        var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getServerTelemetry = function () {
        var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setAuthorityMetadata = function () {
        var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getAuthorityMetadata = function () {
        var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {
        var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.setThrottlingCache = function () {
        var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getThrottlingCache = function () {
        var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.removeItem = function () {
        var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.containsKey = function () {
        var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.getKeys = function () {
        var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass.prototype.clear = function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    };
    DefaultStorageClass.prototype.updateCredentialCacheKey = function () {
        var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    };
    return DefaultStorageClass;
}(CacheManager));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// Token renewal offset default in seconds
var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
var DEFAULT_SYSTEM_OPTIONS = {
    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
    preventCorsPreflight: false,
    proxyUrl: Constants.EMPTY_STRING
};
var DEFAULT_LOGGER_IMPLEMENTATION = {
    loggerCallback: function () {
        // allow users to not set loggerCallback
    },
    piiLoggingEnabled: false,
    logLevel: exports.LogLevel.Info,
    correlationId: Constants.EMPTY_STRING
};
var DEFAULT_NETWORK_IMPLEMENTATION = {
    sendGetRequestAsync: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    sendPostRequestAsync: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    }
};
var DEFAULT_LIBRARY_INFO = {
    sku: Constants.SKU,
    version: version,
    cpu: Constants.EMPTY_STRING,
    os: Constants.EMPTY_STRING
};
var DEFAULT_CLIENT_CREDENTIALS = {
    clientSecret: Constants.EMPTY_STRING,
    clientAssertion: undefined
};
var DEFAULT_AZURE_CLOUD_OPTIONS = {
    azureCloudInstance: exports.AzureCloudInstance.None,
    tenant: "" + Constants.DEFAULT_COMMON_TENANT
};
var DEFAULT_TELEMETRY_OPTIONS = {
    application: {
        appName: "",
        appVersion: ""
    }
};
/**
 * Function that sets the default options when not explicitly configured from app developer
 *
 * @param Configuration
 *
 * @returns Configuration
 */
function buildClientConfiguration(_a) {
    var userAuthOptions = _a.authOptions, userSystemOptions = _a.systemOptions, userLoggerOption = _a.loggerOptions, storageImplementation = _a.storageInterface, networkImplementation = _a.networkInterface, cryptoImplementation = _a.cryptoInterface, clientCredentials = _a.clientCredentials, libraryInfo = _a.libraryInfo, telemetry = _a.telemetry, serverTelemetryManager = _a.serverTelemetryManager, persistencePlugin = _a.persistencePlugin, serializableCache = _a.serializableCache;
    var loggerOptions = __assign(__assign({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
    return {
        authOptions: buildAuthOptions(userAuthOptions),
        systemOptions: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS), userSystemOptions),
        loggerOptions: loggerOptions,
        storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION),
        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
        libraryInfo: __assign(__assign({}, DEFAULT_LIBRARY_INFO), libraryInfo),
        telemetry: __assign(__assign({}, DEFAULT_TELEMETRY_OPTIONS), telemetry),
        serverTelemetryManager: serverTelemetryManager || null,
        persistencePlugin: persistencePlugin || null,
        serializableCache: serializableCache || null,
    };
}
/**
 * Construct authoptions from the client and platform passed values
 * @param authOptions
 */
function buildAuthOptions(authOptions) {
    return __assign({ clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS, skipAuthorityMetadataCache: false }, authOptions);
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Error thrown when there is an error with the server code, for example, unavailability.
 */
var ServerError = /** @class */ (function (_super) {
    __extends(ServerError, _super);
    function ServerError(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "ServerError";
        Object.setPrototypeOf(_this, ServerError.prototype);
        return _this;
    }
    return ServerError;
}(AuthError));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ThrottlingUtils = /** @class */ (function () {
    function ThrottlingUtils() {
    }
    /**
     * Prepares a RequestThumbprint to be stored as a key.
     * @param thumbprint
     */
    ThrottlingUtils.generateThrottlingStorageKey = function (thumbprint) {
        return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint);
    };
    /**
     * Performs necessary throttling checks before a network request.
     * @param cacheManager
     * @param thumbprint
     */
    ThrottlingUtils.preProcess = function (cacheManager, thumbprint) {
        var _a;
        var key = ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        var value = cacheManager.getThrottlingCache(key);
        if (value) {
            if (value.throttleTime < Date.now()) {
                cacheManager.removeItem(key, exports.CacheSchemaType.THROTTLING);
                return;
            }
            throw new ServerError(((_a = value.errorCodes) === null || _a === void 0 ? void 0 : _a.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
    };
    /**
     * Performs necessary throttling checks after a network request.
     * @param cacheManager
     * @param thumbprint
     * @param response
     */
    ThrottlingUtils.postProcess = function (cacheManager, thumbprint, response) {
        if (ThrottlingUtils.checkResponseStatus(response) || ThrottlingUtils.checkResponseForRetryAfter(response)) {
            var thumbprintValue = {
                throttleTime: ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
                error: response.body.error,
                errorCodes: response.body.error_codes,
                errorMessage: response.body.error_description,
                subError: response.body.suberror
            };
            cacheManager.setThrottlingCache(ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue);
        }
    };
    /**
     * Checks a NetworkResponse object's status codes against 429 or 5xx
     * @param response
     */
    ThrottlingUtils.checkResponseStatus = function (response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
    };
    /**
     * Checks a NetworkResponse object's RetryAfter header
     * @param response
     */
    ThrottlingUtils.checkResponseForRetryAfter = function (response) {
        if (response.headers) {
            return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
    };
    /**
     * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
     * @param throttleTime
     */
    ThrottlingUtils.calculateThrottleTime = function (throttleTime) {
        var time = throttleTime <= 0 ? 0 : throttleTime;
        var currentSeconds = Date.now() / 1000;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1000);
    };
    ThrottlingUtils.removeThrottle = function (cacheManager, clientId, request, homeAccountIdentifier) {
        var thumbprint = {
            clientId: clientId,
            authority: request.authority,
            scopes: request.scopes,
            homeAccountIdentifier: homeAccountIdentifier,
            claims: request.claims,
            authenticationScheme: request.authenticationScheme,
            resourceRequestMethod: request.resourceRequestMethod,
            resourceRequestUri: request.resourceRequestUri,
            shrClaims: request.shrClaims,
            sshKid: request.sshKid
        };
        var key = this.generateThrottlingStorageKey(thumbprint);
        return cacheManager.removeItem(key, exports.CacheSchemaType.THROTTLING);
    };
    return ThrottlingUtils;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var NetworkManager = /** @class */ (function () {
    function NetworkManager(networkClient, cacheManager) {
        this.networkClient = networkClient;
        this.cacheManager = cacheManager;
    }
    /**
     * Wraps sendPostRequestAsync with necessary preflight and postflight logic
     * @param thumbprint
     * @param tokenEndpoint
     * @param options
     */
    NetworkManager.prototype.sendPostRequest = function (thumbprint, tokenEndpoint, options) {
        return __awaiter(this, void 0, void 0, function () {
            var response, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        if (e_1 instanceof AuthError) {
                            throw e_1;
                        }
                        else {
                            throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
                        }
                    case 4:
                        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
                        return [2 /*return*/, response];
                }
            });
        });
    };
    return NetworkManager;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
exports.CcsCredentialType = void 0;
(function (CcsCredentialType) {
    CcsCredentialType["HOME_ACCOUNT_ID"] = "home_account_id";
    CcsCredentialType["UPN"] = "UPN";
})(exports.CcsCredentialType || (exports.CcsCredentialType = {}));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Base application class which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.
 */
var BaseClient = /** @class */ (function () {
    function BaseClient(configuration, performanceClient) {
        // Set the configuration
        this.config = buildClientConfiguration(configuration);
        // Initialize the logger
        this.logger = new Logger(this.config.loggerOptions, name, version);
        // Initialize crypto
        this.cryptoUtils = this.config.cryptoInterface;
        // Initialize storage interface
        this.cacheManager = this.config.storageInterface;
        // Set the network interface
        this.networkClient = this.config.networkInterface;
        // Set the NetworkManager
        this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
        // Set TelemetryManager
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        // set Authority
        this.authority = this.config.authOptions.authority;
        // set performance telemetry client
        this.performanceClient = performanceClient;
    }
    /**
     * Creates default headers for requests to token endpoint
     */
    BaseClient.prototype.createTokenRequestHeaders = function (ccsCred) {
        var headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
            switch (ccsCred.type) {
                case exports.CcsCredentialType.HOME_ACCOUNT_ID:
                    try {
                        var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                        headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid;
                    }
                    catch (e) {
                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                    }
                    break;
                case exports.CcsCredentialType.UPN:
                    headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
                    break;
            }
        }
        return headers;
    };
    /**
     * Http post to token endpoint
     * @param tokenEndpoint
     * @param queryString
     * @param headers
     * @param thumbprint
     */
    BaseClient.prototype.executePostToTokenEndpoint = function (tokenEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers: headers, proxyUrl: this.config.systemOptions.proxyUrl })];
                    case 1:
                        response = _a.sent();
                        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
                            // Telemetry data successfully logged by server, clear Telemetry cache
                            this.config.serverTelemetryManager.clearTelemetryCache();
                        }
                        return [2 /*return*/, response];
                }
            });
        });
    };
    /**
     * Updates the authority object of the client. Endpoint discovery must be completed.
     * @param updatedAuthority
     */
    BaseClient.prototype.updateAuthority = function (updatedAuthority) {
        if (!updatedAuthority.discoveryComplete()) {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
        }
        this.authority = updatedAuthority;
    };
    return BaseClient;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Validates server consumable params from the "request" objects
 */
var RequestValidator = /** @class */ (function () {
    function RequestValidator() {
    }
    /**
     * Utility to check if the `redirectUri` in the request is a non-null value
     * @param redirectUri
     */
    RequestValidator.validateRedirectUri = function (redirectUri) {
        if (StringUtils.isEmpty(redirectUri)) {
            throw ClientConfigurationError.createRedirectUriEmptyError();
        }
    };
    /**
     * Utility to validate prompt sent by the user in the request
     * @param prompt
     */
    RequestValidator.validatePrompt = function (prompt) {
        var promptValues = [];
        for (var value in PromptValue) {
            promptValues.push(PromptValue[value]);
        }
        if (promptValues.indexOf(prompt) < 0) {
            throw ClientConfigurationError.createInvalidPromptError(prompt);
        }
    };
    RequestValidator.validateClaims = function (claims) {
        try {
            JSON.parse(claims);
        }
        catch (e) {
            throw ClientConfigurationError.createInvalidClaimsRequestError();
        }
    };
    /**
     * Utility to validate code_challenge and code_challenge_method
     * @param codeChallenge
     * @param codeChallengeMethod
     */
    RequestValidator.validateCodeChallengeParams = function (codeChallenge, codeChallengeMethod) {
        if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
            throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        }
        else {
            this.validateCodeChallengeMethod(codeChallengeMethod);
        }
    };
    /**
     * Utility to validate code_challenge_method
     * @param codeChallengeMethod
     */
    RequestValidator.validateCodeChallengeMethod = function (codeChallengeMethod) {
        if ([
            CodeChallengeMethodValues.PLAIN,
            CodeChallengeMethodValues.S256
        ].indexOf(codeChallengeMethod) < 0) {
            throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
        }
    };
    /**
     * Removes unnecessary or duplicate query parameters from extraQueryParameters
     * @param request
     */
    RequestValidator.sanitizeEQParams = function (eQParams, queryParams) {
        if (!eQParams) {
            return {};
        }
        // Remove any query parameters already included in SSO params
        queryParams.forEach(function (value, key) {
            if (eQParams[key]) {
                delete eQParams[key];
            }
        });
        return eQParams;
    };
    return RequestValidator;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var RequestParameterBuilder = /** @class */ (function () {
    function RequestParameterBuilder() {
        this.parameters = new Map();
    }
    /**
     * add response_type = code
     */
    RequestParameterBuilder.prototype.addResponseTypeCode = function () {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
    };
    /**
     * add response_type = token id_token
     */
    RequestParameterBuilder.prototype.addResponseTypeForTokenAndIdToken = function () {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.TOKEN_RESPONSE_TYPE + " " + Constants.ID_TOKEN_RESPONSE_TYPE));
    };
    /**
     * add response_mode. defaults to query.
     * @param responseMode
     */
    RequestParameterBuilder.prototype.addResponseMode = function (responseMode) {
        this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent((responseMode) ? responseMode : exports.ResponseMode.QUERY));
    };
    /**
     * Add flag to indicate STS should attempt to use WAM if available
     */
    RequestParameterBuilder.prototype.addNativeBroker = function () {
        this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
    };
    /**
     * add scopes. set addOidcScopes to false to prevent default scopes in non-user scenarios
     * @param scopeSet
     * @param addOidcScopes
     */
    RequestParameterBuilder.prototype.addScopes = function (scopes, addOidcScopes) {
        if (addOidcScopes === void 0) { addOidcScopes = true; }
        var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
        var scopeSet = new ScopeSet(requestScopes);
        this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));
    };
    /**
     * add clientId
     * @param clientId
     */
    RequestParameterBuilder.prototype.addClientId = function (clientId) {
        this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));
    };
    /**
     * add redirect_uri
     * @param redirectUri
     */
    RequestParameterBuilder.prototype.addRedirectUri = function (redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));
    };
    /**
     * add post logout redirectUri
     * @param redirectUri
     */
    RequestParameterBuilder.prototype.addPostLogoutRedirectUri = function (redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri));
    };
    /**
     * add id_token_hint to logout request
     * @param idTokenHint
     */
    RequestParameterBuilder.prototype.addIdTokenHint = function (idTokenHint) {
        this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
    };
    /**
     * add domain_hint
     * @param domainHint
     */
    RequestParameterBuilder.prototype.addDomainHint = function (domainHint) {
        this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));
    };
    /**
     * add login_hint
     * @param loginHint
     */
    RequestParameterBuilder.prototype.addLoginHint = function (loginHint) {
        this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));
    };
    /**
     * Adds the CCS (Cache Credential Service) query parameter for login_hint
     * @param loginHint
     */
    RequestParameterBuilder.prototype.addCcsUpn = function (loginHint) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint));
    };
    /**
     * Adds the CCS (Cache Credential Service) query parameter for account object
     * @param loginHint
     */
    RequestParameterBuilder.prototype.addCcsOid = function (clientInfo) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid));
    };
    /**
     * add sid
     * @param sid
     */
    RequestParameterBuilder.prototype.addSid = function (sid) {
        this.parameters.set(SSOTypes.SID, encodeURIComponent(sid));
    };
    /**
     * add claims
     * @param claims
     */
    RequestParameterBuilder.prototype.addClaims = function (claims, clientCapabilities) {
        var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
        RequestValidator.validateClaims(mergedClaims);
        this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims));
    };
    /**
     * add correlationId
     * @param correlationId
     */
    RequestParameterBuilder.prototype.addCorrelationId = function (correlationId) {
        this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
    };
    /**
     * add library info query params
     * @param libraryInfo
     */
    RequestParameterBuilder.prototype.addLibraryInfo = function (libraryInfo) {
        // Telemetry Info
        this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
        this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
        if (libraryInfo.os) {
            this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
        }
        if (libraryInfo.cpu) {
            this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);
        }
    };
    /**
     * Add client telemetry parameters
     * @param appTelemetry
     */
    RequestParameterBuilder.prototype.addApplicationTelemetry = function (appTelemetry) {
        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appName) {
            this.parameters.set(AADServerParamKeys.X_APP_NAME, appTelemetry.appName);
        }
        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appVersion) {
            this.parameters.set(AADServerParamKeys.X_APP_VER, appTelemetry.appVersion);
        }
    };
    /**
     * add prompt
     * @param prompt
     */
    RequestParameterBuilder.prototype.addPrompt = function (prompt) {
        RequestValidator.validatePrompt(prompt);
        this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt));
    };
    /**
     * add state
     * @param state
     */
    RequestParameterBuilder.prototype.addState = function (state) {
        if (!StringUtils.isEmpty(state)) {
            this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state));
        }
    };
    /**
     * add nonce
     * @param nonce
     */
    RequestParameterBuilder.prototype.addNonce = function (nonce) {
        this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));
    };
    /**
     * add code_challenge and code_challenge_method
     * - throw if either of them are not passed
     * @param codeChallenge
     * @param codeChallengeMethod
     */
    RequestParameterBuilder.prototype.addCodeChallengeParams = function (codeChallenge, codeChallengeMethod) {
        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
        if (codeChallenge && codeChallengeMethod) {
            this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
            this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
        }
        else {
            throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        }
    };
    /**
     * add the `authorization_code` passed by the user to exchange for a token
     * @param code
     */
    RequestParameterBuilder.prototype.addAuthorizationCode = function (code) {
        this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code));
    };
    /**
     * add the `authorization_code` passed by the user to exchange for a token
     * @param code
     */
    RequestParameterBuilder.prototype.addDeviceCode = function (code) {
        this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code));
    };
    /**
     * add the `refreshToken` passed by the user
     * @param refreshToken
     */
    RequestParameterBuilder.prototype.addRefreshToken = function (refreshToken) {
        this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));
    };
    /**
     * add the `code_verifier` passed by the user to exchange for a token
     * @param codeVerifier
     */
    RequestParameterBuilder.prototype.addCodeVerifier = function (codeVerifier) {
        this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));
    };
    /**
     * add client_secret
     * @param clientSecret
     */
    RequestParameterBuilder.prototype.addClientSecret = function (clientSecret) {
        this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret));
    };
    /**
     * add clientAssertion for confidential client flows
     * @param clientAssertion
     */
    RequestParameterBuilder.prototype.addClientAssertion = function (clientAssertion) {
        if (!StringUtils.isEmpty(clientAssertion)) {
            this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
        }
    };
    /**
     * add clientAssertionType for confidential client flows
     * @param clientAssertionType
     */
    RequestParameterBuilder.prototype.addClientAssertionType = function (clientAssertionType) {
        if (!StringUtils.isEmpty(clientAssertionType)) {
            this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
        }
    };
    /**
     * add OBO assertion for confidential client flows
     * @param clientAssertion
     */
    RequestParameterBuilder.prototype.addOboAssertion = function (oboAssertion) {
        this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion));
    };
    /**
     * add grant type
     * @param grantType
     */
    RequestParameterBuilder.prototype.addRequestTokenUse = function (tokenUse) {
        this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
    };
    /**
     * add grant type
     * @param grantType
     */
    RequestParameterBuilder.prototype.addGrantType = function (grantType) {
        this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));
    };
    /**
     * add client info
     *
     */
    RequestParameterBuilder.prototype.addClientInfo = function () {
        this.parameters.set(CLIENT_INFO, "1");
    };
    /**
     * add extraQueryParams
     * @param eQparams
     */
    RequestParameterBuilder.prototype.addExtraQueryParameters = function (eQparams) {
        var _this = this;
        RequestValidator.sanitizeEQParams(eQparams, this.parameters);
        Object.keys(eQparams).forEach(function (key) {
            _this.parameters.set(key, eQparams[key]);
        });
    };
    RequestParameterBuilder.prototype.addClientCapabilitiesToClaims = function (claims, clientCapabilities) {
        var mergedClaims;
        // Parse provided claims into JSON object or initialize empty object
        if (!claims) {
            mergedClaims = {};
        }
        else {
            try {
                mergedClaims = JSON.parse(claims);
            }
            catch (e) {
                throw ClientConfigurationError.createInvalidClaimsRequestError();
            }
        }
        if (clientCapabilities && clientCapabilities.length > 0) {
            if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
                // Add access_token key to claims object
                mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
            }
            // Add xms_cc claim with provided clientCapabilities to access_token key
            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
                values: clientCapabilities
            };
        }
        return JSON.stringify(mergedClaims);
    };
    /**
     * adds `username` for Password Grant flow
     * @param username
     */
    RequestParameterBuilder.prototype.addUsername = function (username) {
        this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
    };
    /**
     * adds `password` for Password Grant flow
     * @param password
     */
    RequestParameterBuilder.prototype.addPassword = function (password) {
        this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
    };
    /**
     * add pop_jwk to query params
     * @param cnfString
     */
    RequestParameterBuilder.prototype.addPopToken = function (cnfString) {
        if (!StringUtils.isEmpty(cnfString)) {
            this.parameters.set(AADServerParamKeys.TOKEN_TYPE, exports.AuthenticationScheme.POP);
            this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString));
        }
    };
    /**
     * add SSH JWK and key ID to query params
     */
    RequestParameterBuilder.prototype.addSshJwk = function (sshJwkString) {
        if (!StringUtils.isEmpty(sshJwkString)) {
            this.parameters.set(AADServerParamKeys.TOKEN_TYPE, exports.AuthenticationScheme.SSH);
            this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString));
        }
    };
    /**
     * add server telemetry fields
     * @param serverTelemetryManager
     */
    RequestParameterBuilder.prototype.addServerTelemetry = function (serverTelemetryManager) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
        this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
    };
    /**
     * Adds parameter that indicates to the server that throttling is supported
     */
    RequestParameterBuilder.prototype.addThrottling = function () {
        this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
    };
    /**
     * Adds logout_hint parameter for "silent" logout which prevent server account picker
     */
    RequestParameterBuilder.prototype.addLogoutHint = function (logoutHint) {
        this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint));
    };
    /**
     * Utility to create a URL from the params map
     */
    RequestParameterBuilder.prototype.createQueryString = function () {
        var queryParameterArray = new Array();
        this.parameters.forEach(function (value, key) {
            queryParameterArray.push(key + "=" + value);
        });
        return queryParameterArray.join("&");
    };
    return RequestParameterBuilder;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * ID_TOKEN Cache
 *
 * Key:Value Schema:
 *
 * Key Example: uid.utid-login.microsoftonline.com-idtoken-clientId-contoso.com-
 *
 * Value Schema:
 * {
 *      homeAccountId: home account identifier for the auth scheme,
 *      environment: entity that issued the token, represented as a full host
 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
 *      clientId: client ID of the application
 *      secret: Actual credential as a string
 *      realm: Full tenant or organizational identifier that the account belongs to
 * }
 */
var IdTokenEntity = /** @class */ (function (_super) {
    __extends(IdTokenEntity, _super);
    function IdTokenEntity() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create IdTokenEntity
     * @param homeAccountId
     * @param authenticationResult
     * @param clientId
     * @param authority
     */
    IdTokenEntity.createIdTokenEntity = function (homeAccountId, environment, idToken, clientId, tenantId) {
        var idTokenEntity = new IdTokenEntity();
        idTokenEntity.credentialType = exports.CredentialType.ID_TOKEN;
        idTokenEntity.homeAccountId = homeAccountId;
        idTokenEntity.environment = environment;
        idTokenEntity.clientId = clientId;
        idTokenEntity.secret = idToken;
        idTokenEntity.realm = tenantId;
        return idTokenEntity;
    };
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    IdTokenEntity.isIdTokenEntity = function (entity) {
        if (!entity) {
            return false;
        }
        return (entity.hasOwnProperty("homeAccountId") &&
            entity.hasOwnProperty("environment") &&
            entity.hasOwnProperty("credentialType") &&
            entity.hasOwnProperty("realm") &&
            entity.hasOwnProperty("clientId") &&
            entity.hasOwnProperty("secret") &&
            entity["credentialType"] === exports.CredentialType.ID_TOKEN);
    };
    return IdTokenEntity;
}(CredentialEntity));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Utility class which exposes functions for managing date and time operations.
 */
var TimeUtils = /** @class */ (function () {
    function TimeUtils() {
    }
    /**
     * return the current time in Unix time (seconds).
     */
    TimeUtils.nowSeconds = function () {
        // Date.getTime() returns in milliseconds.
        return Math.round(new Date().getTime() / 1000.0);
    };
    /**
     * check if a token is expired based on given UTC time in seconds.
     * @param expiresOn
     */
    TimeUtils.isTokenExpired = function (expiresOn, offset) {
        // check for access token expiry
        var expirationSec = Number(expiresOn) || 0;
        var offsetCurrentTimeSec = TimeUtils.nowSeconds() + offset;
        // If current time + offset is greater than token expiration time, then token is expired.
        return (offsetCurrentTimeSec > expirationSec);
    };
    /**
     * If the current time is earlier than the time that a token was cached at, we must discard the token
     * i.e. The system clock was turned back after acquiring the cached token
     * @param cachedAt
     * @param offset
     */
    TimeUtils.wasClockTurnedBack = function (cachedAt) {
        var cachedAtSec = Number(cachedAt);
        return cachedAtSec > TimeUtils.nowSeconds();
    };
    /**
     * Waits for t number of milliseconds
     * @param t number
     * @param value T
     */
    TimeUtils.delay = function (t, value) {
        return new Promise(function (resolve) { return setTimeout(function () { return resolve(value); }, t); });
    };
    return TimeUtils;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * ACCESS_TOKEN Credential Type
 *
 * Key:Value Schema:
 *
 * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read
 *
 * Value Schema:
 * {
 *      homeAccountId: home account identifier for the auth scheme,
 *      environment: entity that issued the token, represented as a full host
 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
 *      clientId: client ID of the application
 *      secret: Actual credential as a string
 *      familyId: Family ID identifier, usually only used for refresh tokens
 *      realm: Full tenant or organizational identifier that the account belongs to
 *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.
 *      cachedAt: Absolute device time when entry was created in the cache.
 *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.
 *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.
 *      keyId: used for POP and SSH tokenTypes
 *      tokenType: Type of the token issued. Usually "Bearer"
 * }
 */
var AccessTokenEntity = /** @class */ (function (_super) {
    __extends(AccessTokenEntity, _super);
    function AccessTokenEntity() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create AccessTokenEntity
     * @param homeAccountId
     * @param environment
     * @param accessToken
     * @param clientId
     * @param tenantId
     * @param scopes
     * @param expiresOn
     * @param extExpiresOn
     */
    AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
        var _a, _b;
        var atEntity = new AccessTokenEntity();
        atEntity.homeAccountId = homeAccountId;
        atEntity.credentialType = exports.CredentialType.ACCESS_TOKEN;
        atEntity.secret = accessToken;
        var currentTime = TimeUtils.nowSeconds();
        atEntity.cachedAt = currentTime.toString();
        /*
         * Token expiry time.
         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.
         */
        atEntity.expiresOn = expiresOn.toString();
        atEntity.extendedExpiresOn = extExpiresOn.toString();
        if (refreshOn) {
            atEntity.refreshOn = refreshOn.toString();
        }
        atEntity.environment = environment;
        atEntity.clientId = clientId;
        atEntity.realm = tenantId;
        atEntity.target = scopes;
        atEntity.userAssertionHash = userAssertionHash;
        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? exports.AuthenticationScheme.BEARER : tokenType;
        if (requestedClaims) {
            atEntity.requestedClaims = requestedClaims;
            atEntity.requestedClaimsHash = requestedClaimsHash;
        }
        /*
         * Create Access Token With Auth Scheme instead of regular access token
         * Cast to lower to handle "bearer" from ADFS
         */
        if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== exports.AuthenticationScheme.BEARER.toLowerCase()) {
            atEntity.credentialType = exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
            switch (atEntity.tokenType) {
                case exports.AuthenticationScheme.POP:
                    // Make sure keyId is present and add it to credential
                    var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
                    if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {
                        throw ClientAuthError.createTokenClaimsRequiredError();
                    }
                    atEntity.keyId = tokenClaims.cnf.kid;
                    break;
                case exports.AuthenticationScheme.SSH:
                    atEntity.keyId = keyId;
            }
        }
        return atEntity;
    };
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    AccessTokenEntity.isAccessTokenEntity = function (entity) {
        if (!entity) {
            return false;
        }
        return (entity.hasOwnProperty("homeAccountId") &&
            entity.hasOwnProperty("environment") &&
            entity.hasOwnProperty("credentialType") &&
            entity.hasOwnProperty("realm") &&
            entity.hasOwnProperty("clientId") &&
            entity.hasOwnProperty("secret") &&
            entity.hasOwnProperty("target") &&
            (entity["credentialType"] === exports.CredentialType.ACCESS_TOKEN || entity["credentialType"] === exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));
    };
    return AccessTokenEntity;
}(CredentialEntity));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * REFRESH_TOKEN Cache
 *
 * Key:Value Schema:
 *
 * Key Example: uid.utid-login.microsoftonline.com-refreshtoken-clientId--
 *
 * Value:
 * {
 *      homeAccountId: home account identifier for the auth scheme,
 *      environment: entity that issued the token, represented as a full host
 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
 *      clientId: client ID of the application
 *      secret: Actual credential as a string
 *      familyId: Family ID identifier, '1' represents Microsoft Family
 *      realm: Full tenant or organizational identifier that the account belongs to
 *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.
 * }
 */
var RefreshTokenEntity = /** @class */ (function (_super) {
    __extends(RefreshTokenEntity, _super);
    function RefreshTokenEntity() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create RefreshTokenEntity
     * @param homeAccountId
     * @param authenticationResult
     * @param clientId
     * @param authority
     */
    RefreshTokenEntity.createRefreshTokenEntity = function (homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {
        var rtEntity = new RefreshTokenEntity();
        rtEntity.clientId = clientId;
        rtEntity.credentialType = exports.CredentialType.REFRESH_TOKEN;
        rtEntity.environment = environment;
        rtEntity.homeAccountId = homeAccountId;
        rtEntity.secret = refreshToken;
        rtEntity.userAssertionHash = userAssertionHash;
        if (familyId)
            rtEntity.familyId = familyId;
        return rtEntity;
    };
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    RefreshTokenEntity.isRefreshTokenEntity = function (entity) {
        if (!entity) {
            return false;
        }
        return (entity.hasOwnProperty("homeAccountId") &&
            entity.hasOwnProperty("environment") &&
            entity.hasOwnProperty("credentialType") &&
            entity.hasOwnProperty("clientId") &&
            entity.hasOwnProperty("secret") &&
            entity["credentialType"] === exports.CredentialType.REFRESH_TOKEN);
    };
    return RefreshTokenEntity;
}(CredentialEntity));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * InteractionRequiredServerErrorMessage contains string constants used by error codes and messages returned by the server indicating interaction is required
 */
var InteractionRequiredServerErrorMessage = [
    "interaction_required",
    "consent_required",
    "login_required"
];
var InteractionRequiredAuthSubErrorMessage = [
    "message_only",
    "additional_action",
    "basic_action",
    "user_password_expired",
    "consent_required"
];
/**
 * Interaction required errors defined by the SDK
 */
var InteractionRequiredAuthErrorMessage = {
    noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No refresh token found in the cache. Please sign-in."
    },
    native_account_unavailable: {
        code: "native_account_unavailable",
        desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
    }
};
/**
 * Error thrown when user interaction is required.
 */
var InteractionRequiredAuthError = /** @class */ (function (_super) {
    __extends(InteractionRequiredAuthError, _super);
    function InteractionRequiredAuthError(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "InteractionRequiredAuthError";
        Object.setPrototypeOf(_this, InteractionRequiredAuthError.prototype);
        return _this;
    }
    /**
     * Helper function used to determine if an error thrown by the server requires interaction to resolve
     * @param errorCode
     * @param errorString
     * @param subError
     */
    InteractionRequiredAuthError.isInteractionRequiredError = function (errorCode, errorString, subError) {
        var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
        var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
        var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function (irErrorCode) {
            return errorString.indexOf(irErrorCode) > -1;
        });
        return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
    };
    /**
     * Creates an error thrown when the authorization code required for a token request is null or empty.
     */
    InteractionRequiredAuthError.createNoTokensFoundError = function () {
        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
    };
    /**
     * Creates an error thrown when the native broker returns ACCOUNT_UNAVAILABLE status, indicating that the account was removed and interactive sign-in is required
     * @returns
     */
    InteractionRequiredAuthError.createNativeAccountUnavailableError = function () {
        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
    };
    return InteractionRequiredAuthError;
}(AuthError));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var CacheRecord = /** @class */ (function () {
    function CacheRecord(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
        this.account = accountEntity || null;
        this.idToken = idTokenEntity || null;
        this.accessToken = accessTokenEntity || null;
        this.refreshToken = refreshTokenEntity || null;
        this.appMetadata = appMetadataEntity || null;
    }
    return CacheRecord;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Class which provides helpers for OAuth 2.0 protocol specific values
 */
var ProtocolUtils = /** @class */ (function () {
    function ProtocolUtils() {
    }
    /**
     * Appends user state with random guid, or returns random guid.
     * @param userState
     * @param randomGuid
     */
    ProtocolUtils.setRequestState = function (cryptoObj, userState, meta) {
        var libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState;
    };
    /**
     * Generates the state value used by the common library.
     * @param randomGuid
     * @param cryptoObj
     */
    ProtocolUtils.generateLibraryState = function (cryptoObj, meta) {
        if (!cryptoObj) {
            throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
        }
        // Create a state object containing a unique id and the timestamp of the request creation
        var stateObj = {
            id: cryptoObj.createNewGuid()
        };
        if (meta) {
            stateObj.meta = meta;
        }
        var stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
    };
    /**
     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
     * @param state
     * @param cryptoObj
     */
    ProtocolUtils.parseRequestState = function (cryptoObj, state) {
        if (!cryptoObj) {
            throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
        }
        if (StringUtils.isEmpty(state)) {
            throw ClientAuthError.createInvalidStateError(state, "Null, undefined or empty state");
        }
        try {
            // Split the state between library state and user passed state and decode them separately
            var splitState = state.split(Constants.RESOURCE_DELIM);
            var libraryState = splitState[0];
            var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
            var libraryStateString = cryptoObj.base64Decode(libraryState);
            var libraryStateObj = JSON.parse(libraryStateString);
            return {
                userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,
                libraryState: libraryStateObj
            };
        }
        catch (e) {
            throw ClientAuthError.createInvalidStateError(state, e);
        }
    };
    return ProtocolUtils;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Url object class which can perform various transformations on url strings.
 */
var UrlString = /** @class */ (function () {
    function UrlString(url) {
        this._urlString = url;
        if (StringUtils.isEmpty(this._urlString)) {
            // Throws error if url is empty
            throw ClientConfigurationError.createUrlEmptyError();
        }
        if (StringUtils.isEmpty(this.getHash())) {
            this._urlString = UrlString.canonicalizeUri(url);
        }
    }
    Object.defineProperty(UrlString.prototype, "urlString", {
        get: function () {
            return this._urlString;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Ensure urls are lower case and end with a / character.
     * @param url
     */
    UrlString.canonicalizeUri = function (url) {
        if (url) {
            var lowerCaseUrl = url.toLowerCase();
            if (StringUtils.endsWith(lowerCaseUrl, "?")) {
                lowerCaseUrl = lowerCaseUrl.slice(0, -1);
            }
            else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
                lowerCaseUrl = lowerCaseUrl.slice(0, -2);
            }
            if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
                lowerCaseUrl += "/";
            }
            return lowerCaseUrl;
        }
        return url;
    };
    /**
     * Throws if urlString passed is not a valid authority URI string.
     */
    UrlString.prototype.validateAsUri = function () {
        // Attempts to parse url for uri components
        var components;
        try {
            components = this.getUrlComponents();
        }
        catch (e) {
            throw ClientConfigurationError.createUrlParseError(e);
        }
        // Throw error if URI or path segments are not parseable.
        if (!components.HostNameAndPort || !components.PathSegments) {
            throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        // Throw error if uri is insecure.
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
        }
    };
    /**
     * Given a url and a query string return the url with provided query string appended
     * @param url
     * @param queryString
     */
    UrlString.appendQueryString = function (url, queryString) {
        if (StringUtils.isEmpty(queryString)) {
            return url;
        }
        return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString;
    };
    /**
     * Returns a url with the hash removed
     * @param url
     */
    UrlString.removeHashFromUrl = function (url) {
        return UrlString.canonicalizeUri(url.split("#")[0]);
    };
    /**
     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
     * @param href The url
     * @param tenantId The tenant id to replace
     */
    UrlString.prototype.replaceTenantPath = function (tenantId) {
        var urlObject = this.getUrlComponents();
        var pathArray = urlObject.PathSegments;
        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
            pathArray[0] = tenantId;
        }
        return UrlString.constructAuthorityUriFromObject(urlObject);
    };
    /**
     * Returns the anchor part(#) of the URL
     */
    UrlString.prototype.getHash = function () {
        return UrlString.parseHash(this.urlString);
    };
    /**
     * Parses out the components from a url string.
     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
     */
    UrlString.prototype.getUrlComponents = function () {
        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0
        var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        // If url string does not match regEx, we throw an error
        var match = this.urlString.match(regEx);
        if (!match) {
            throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        // Url component object
        var urlComponents = {
            Protocol: match[1],
            HostNameAndPort: match[4],
            AbsolutePath: match[5],
            QueryString: match[7]
        };
        var pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter(function (val) { return val && val.length > 0; }); // remove empty elements
        urlComponents.PathSegments = pathSegments;
        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
    };
    UrlString.getDomainFromUrl = function (url) {
        var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        var match = url.match(regEx);
        if (!match) {
            throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
        }
        return match[2];
    };
    UrlString.getAbsoluteUrl = function (relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
            var url = new UrlString(baseUrl);
            var baseComponents = url.getUrlComponents();
            return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
    };
    /**
     * Parses hash string from given string. Returns empty string if no hash symbol is found.
     * @param hashString
     */
    UrlString.parseHash = function (hashString) {
        var hashIndex1 = hashString.indexOf("#");
        var hashIndex2 = hashString.indexOf("#/");
        if (hashIndex2 > -1) {
            return hashString.substring(hashIndex2 + 2);
        }
        else if (hashIndex1 > -1) {
            return hashString.substring(hashIndex1 + 1);
        }
        return Constants.EMPTY_STRING;
    };
    /**
     * Parses query string from given string. Returns empty string if no query symbol is found.
     * @param queryString
     */
    UrlString.parseQueryString = function (queryString) {
        var queryIndex1 = queryString.indexOf("?");
        var queryIndex2 = queryString.indexOf("/?");
        if (queryIndex2 > -1) {
            return queryString.substring(queryIndex2 + 2);
        }
        else if (queryIndex1 > -1) {
            return queryString.substring(queryIndex1 + 1);
        }
        return Constants.EMPTY_STRING;
    };
    UrlString.constructAuthorityUriFromObject = function (urlObject) {
        return new UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
    };
    /**
     * Returns URL hash as server auth code response object.
     */
    UrlString.getDeserializedHash = function (hash) {
        // Check if given hash is empty
        if (StringUtils.isEmpty(hash)) {
            return {};
        }
        // Strip the # symbol if present
        var parsedHash = UrlString.parseHash(hash);
        // If # symbol was not present, above will return empty string, so give original hash value
        var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
        // Check if deserialization didn't work
        if (!deserializedHash) {
            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
        }
        return deserializedHash;
    };
    /**
     * Returns URL query string as server auth code response object.
     */
    UrlString.getDeserializedQueryString = function (query) {
        // Check if given query is empty
        if (StringUtils.isEmpty(query)) {
            return {};
        }
        // Strip the ? symbol if present
        var parsedQueryString = UrlString.parseQueryString(query);
        // If ? symbol was not present, above will return empty string, so give original query value
        var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);
        // Check if deserialization didn't work
        if (!deserializedQueryString) {
            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));
        }
        return deserializedQueryString;
    };
    /**
     * Check if the hash of the URL string contains known properties
     */
    UrlString.hashContainsKnownProperties = function (hash) {
        if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
            // Hash doesn't contain key/value pairs
            return false;
        }
        var parameters = UrlString.getDeserializedHash(hash);
        return !!(parameters.code ||
            parameters.error_description ||
            parameters.error ||
            parameters.state);
    };
    return UrlString;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var KeyLocation;
(function (KeyLocation) {
    KeyLocation["SW"] = "sw";
    KeyLocation["UHW"] = "uhw";
})(KeyLocation || (KeyLocation = {}));
var PopTokenGenerator = /** @class */ (function () {
    function PopTokenGenerator(cryptoUtils) {
        this.cryptoUtils = cryptoUtils;
    }
    /**
     * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
     * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
     * @param request
     * @returns
     */
    PopTokenGenerator.prototype.generateCnf = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var reqCnf, reqCnfString, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.generateKid(request)];
                    case 1:
                        reqCnf = _b.sent();
                        reqCnfString = this.cryptoUtils.base64Encode(JSON.stringify(reqCnf));
                        _a = {
                            kid: reqCnf.kid,
                            reqCnfString: reqCnfString
                        };
                        return [4 /*yield*/, this.cryptoUtils.hashString(reqCnfString)];
                    case 2: return [2 /*return*/, (_a.reqCnfHash = _b.sent(),
                            _a)];
                }
            });
        });
    };
    /**
     * Generates key_id for a SHR token request
     * @param request
     * @returns
     */
    PopTokenGenerator.prototype.generateKid = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var kidThumbprint;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cryptoUtils.getPublicKeyThumbprint(request)];
                    case 1:
                        kidThumbprint = _a.sent();
                        return [2 /*return*/, {
                                kid: kidThumbprint,
                                xms_ksl: KeyLocation.SW
                            }];
                }
            });
        });
    };
    /**
     * Signs the POP access_token with the local generated key-pair
     * @param accessToken
     * @param request
     * @returns
     */
    PopTokenGenerator.prototype.signPopToken = function (accessToken, keyId, request) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.signPayload(accessToken, keyId, request)];
            });
        });
    };
    /**
     * Utility function to generate the signed JWT for an access_token
     * @param payload
     * @param kid
     * @param request
     * @param claims
     * @returns
     */
    PopTokenGenerator.prototype.signPayload = function (payload, keyId, request, claims) {
        return __awaiter(this, void 0, void 0, function () {
            var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resourceRequestMethod = request.resourceRequestMethod, resourceRequestUri = request.resourceRequestUri, shrClaims = request.shrClaims, shrNonce = request.shrNonce;
                        resourceUrlString = (resourceRequestUri) ? new UrlString(resourceRequestUri) : undefined;
                        resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
                        return [4 /*yield*/, this.cryptoUtils.signJwt(__assign({ at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : undefined, client_claims: shrClaims || undefined }, claims), keyId, request.correlationId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return PopTokenGenerator;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * APP_METADATA Cache
 *
 * Key:Value Schema:
 *
 * Key: appmetadata-<environment>-<client_id>
 *
 * Value:
 * {
 *      clientId: client ID of the application
 *      environment: entity that issued the token, represented as a full host
 *      familyId: Family ID identifier, '1' represents Microsoft Family
 * }
 */
var AppMetadataEntity = /** @class */ (function () {
    function AppMetadataEntity() {
    }
    /**
     * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>
     */
    AppMetadataEntity.prototype.generateAppMetadataKey = function () {
        return AppMetadataEntity.generateAppMetadataCacheKey(this.environment, this.clientId);
    };
    /**
     * Generate AppMetadata Cache Key
     */
    AppMetadataEntity.generateAppMetadataCacheKey = function (environment, clientId) {
        var appMetaDataKeyArray = [
            APP_METADATA,
            environment,
            clientId,
        ];
        return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    /**
     * Creates AppMetadataEntity
     * @param clientId
     * @param environment
     * @param familyId
     */
    AppMetadataEntity.createAppMetadataEntity = function (clientId, environment, familyId) {
        var appMetadata = new AppMetadataEntity();
        appMetadata.clientId = clientId;
        appMetadata.environment = environment;
        if (familyId) {
            appMetadata.familyId = familyId;
        }
        return appMetadata;
    };
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    AppMetadataEntity.isAppMetadataEntity = function (key, entity) {
        if (!entity) {
            return false;
        }
        return (key.indexOf(APP_METADATA) === 0 &&
            entity.hasOwnProperty("clientId") &&
            entity.hasOwnProperty("environment"));
    };
    return AppMetadataEntity;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class instance helps track the memory changes facilitating
 * decisions to read from and write to the persistent cache
 */ var TokenCacheContext = /** @class */ (function () {
    function TokenCacheContext(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
    }
    Object.defineProperty(TokenCacheContext.prototype, "cacheHasChanged", {
        /**
         * boolean which indicates the changes in cache
         */
        get: function () {
            return this.hasChanged;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TokenCacheContext.prototype, "tokenCache", {
        /**
         * function to retrieve the token cache
         */
        get: function () {
            return this.cache;
        },
        enumerable: false,
        configurable: true
    });
    return TokenCacheContext;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Class that handles response parsing.
 */
var ResponseHandler = /** @class */ (function () {
    function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
    }
    /**
     * Function which validates server authorization code response.
     * @param serverResponseHash
     * @param cachedState
     * @param cryptoObj
     */
    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {
        if (!serverResponseHash.state || !cachedState) {
            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
        }
        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
            throw ClientAuthError.createStateMismatchError();
        }
        // Check for error
        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
            }
            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
        }
        if (serverResponseHash.client_info) {
            buildClientInfo(serverResponseHash.client_info, cryptoObj);
        }
    };
    /**
     * Function which validates server authorization token response.
     * @param serverResponse
     */
    ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {
        // Check for error
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);
            }
            var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
        }
    };
    /**
     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
     * @param serverTokenResponse
     * @param authority
     */
    ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse) {
        return __awaiter(this, void 0, void 0, function () {
            var idTokenObj, requestStateObj, cacheRecord, cacheContext, key, account;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (serverTokenResponse.id_token) {
                            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);
                            // token nonce check (TODO: Add a warning if no nonce is given?)
                            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
                                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
                                    throw ClientAuthError.createNonceMismatchError();
                                }
                            }
                        }
                        // generate homeAccountId
                        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
                        if (!!authCodePayload && !!authCodePayload.state) {
                            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
                        }
                        // Add keyId from request to serverTokenResponse if defined
                        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;
                        cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 5, 8]);
                        if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];
                        this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
                        cacheContext = new TokenCacheContext(this.serializableCache, true);
                        return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        /*
                         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.
                         * If not present, we should return null, as it's the case that another application called removeAccount in between
                         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by
                         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.
                         */
                        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
                            key = cacheRecord.account.generateAccountKey();
                            account = this.cacheStorage.getAccount(key);
                            if (!account) {
                                this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
                                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined)];
                            }
                        }
                        return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 5:
                        if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];
                        this.logger.verbose("Persistence enabled, calling afterCacheAccess");
                        return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse.spa_code)];
                }
            });
        });
    };
    /**
     * Generates CacheRecord
     * @param serverTokenResponse
     * @param idTokenObj
     * @param authority
     */
    ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {
        var env = authority.getPreferredCache();
        if (StringUtils.isEmpty(env)) {
            throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        // IdToken: non AAD scenarios can have empty realm
        var cachedIdToken;
        var cachedAccount;
        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);
            cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);
        }
        // AccessToken
        var cachedAccessToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
            // If scopes not returned in server response, use request scopes
            var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
            /*
             * Use timestamp calculated before request
             * Server may return timestamps as strings, parse to numbers if so.
             */
            var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
            var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
            var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;
            var tokenExpirationSeconds = reqTimestamp + expiresIn;
            var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
            var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;
            // non AAD scenarios can have empty realm
            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
        }
        // refreshToken
        var cachedRefreshToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);
        }
        // appMetadata
        var cachedAppMetadata = null;
        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);
        }
        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);
    };
    /**
     * Generate Account
     * @param serverTokenResponse
     * @param idToken
     * @param authority
     */
    ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {
        var authorityType = authority.authorityType;
        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;
        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;
        // ADFS does not require client_info in the response
        if (authorityType === exports.AuthorityType.Adfs) {
            this.logger.verbose("Authority type is ADFS, creating ADFS account");
            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
        }
        // This fallback applies to B2C as well as they fall under an AAD account type.
        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
            throw ClientAuthError.createClientInfoEmptyError();
        }
        return serverTokenResponse.client_info ?
            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :
            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
    };
    /**
     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
     *
     * Optionally takes a state string that is set as-is in the response.
     *
     * @param cacheRecord
     * @param idTokenObj
     * @param fromTokenCache
     * @param stateString
     */
    ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, code) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        accessToken = Constants.EMPTY_STRING;
                        responseScopes = [];
                        expiresOn = null;
                        familyId = Constants.EMPTY_STRING;
                        if (!cacheRecord.accessToken) return [3 /*break*/, 4];
                        if (!(cacheRecord.accessToken.tokenType === exports.AuthenticationScheme.POP)) return [3 /*break*/, 2];
                        popTokenGenerator = new PopTokenGenerator(cryptoObj);
                        _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;
                        if (!keyId) {
                            throw ClientAuthError.createKeyIdMissingError();
                        }
                        return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];
                    case 1:
                        accessToken = _e.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        accessToken = cacheRecord.accessToken.secret;
                        _e.label = 3;
                    case 3:
                        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
                        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);
                        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);
                        _e.label = 4;
                    case 4:
                        if (cacheRecord.appMetadata) {
                            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;
                        }
                        uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
                        tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
                        return [2 /*return*/, {
                                authority: authority.canonicalAuthority,
                                uniqueId: uid,
                                tenantId: tid,
                                scopes: responseScopes,
                                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,
                                idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,
                                idTokenClaims: idTokenObj ? idTokenObj.claims : {},
                                accessToken: accessToken,
                                fromCache: fromTokenCache,
                                expiresOn: expiresOn,
                                correlationId: request.correlationId,
                                extExpiresOn: extExpiresOn,
                                familyId: familyId,
                                tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,
                                state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
                                cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,
                                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,
                                code: code,
                                fromNativeBroker: false
                            }];
                }
            });
        });
    };
    return ResponseHandler;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Oauth2.0 Authorization Code client
 */
var AuthorizationCodeClient = /** @class */ (function (_super) {
    __extends(AuthorizationCodeClient, _super);
    function AuthorizationCodeClient(configuration) {
        var _this = _super.call(this, configuration) || this;
        // Flag to indicate if client is for hybrid spa auth code redemption
        _this.includeRedirectUri = true;
        return _this;
    }
    /**
     * Creates the URL of the authorization request letting the user input credentials and consent to the
     * application. The URL target the /authorize endpoint of the authority configured in the
     * application object.
     *
     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
     * acquireToken(AuthorizationCodeRequest)
     * @param request
     */
    AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var queryString;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createAuthCodeUrlQueryString(request)];
                    case 1:
                        queryString = _a.sent();
                        return [2 /*return*/, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];
                }
            });
        });
    };
    /**
     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
     * authorization_code_grant
     * @param request
     */
    AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {
        return __awaiter(this, void 0, void 0, function () {
            var reqTimestamp, response, responseHandler;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.info("in acquireToken call");
                        if (!request || StringUtils.isEmpty(request.code)) {
                            throw ClientAuthError.createTokenRequestCannotBeMadeError();
                        }
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.executeTokenRequest(this.authority, request)];
                    case 1:
                        response = _a.sent();
                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                        // Validate response. This function throws a server error if an error is returned by the server.
                        responseHandler.validateTokenResponse(response.body);
                        return [4 /*yield*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Handles the hash fragment response from public client code request. Returns a code response used by
     * the client to exchange for a token in acquireToken.
     * @param hashFragment
     */
    AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {
        // Handle responses.
        var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
        // Deserialize hash fragment response parameters.
        var hashUrlString = new UrlString(hashFragment);
        // Deserialize hash fragment response parameters.
        var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
        // Get code response
        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
        // throw when there is no auth code in the response
        if (!serverParams.code) {
            throw ClientAuthError.createNoAuthCodeInServerResponseError();
        }
        return __assign(__assign({}, serverParams), { 
            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod
            code: serverParams.code });
    };
    /**
     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
     * Default behaviour is to redirect the user to `window.location.href`.
     * @param authorityUri
     */
    AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {
        // Throw error if logoutRequest is null/undefined
        if (!logoutRequest) {
            throw ClientConfigurationError.createEmptyLogoutRequestError();
        }
        var queryString = this.createLogoutUrlQueryString(logoutRequest);
        // Construct logout URI
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
    };
    /**
     * Executes POST request to token endpoint
     * @param authority
     * @param request
     */
    AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {
        return __awaiter(this, void 0, void 0, function () {
            var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        thumbprint = {
                            clientId: this.config.authOptions.clientId,
                            authority: authority.canonicalAuthority,
                            scopes: request.scopes,
                            claims: request.claims,
                            authenticationScheme: request.authenticationScheme,
                            resourceRequestMethod: request.resourceRequestMethod,
                            resourceRequestUri: request.resourceRequestUri,
                            shrClaims: request.shrClaims,
                            sshKid: request.sshKid
                        };
                        return [4 /*yield*/, this.createTokenRequestBody(request)];
                    case 1:
                        requestBody = _a.sent();
                        queryParameters = this.createTokenQueryParameters(request);
                        ccsCredential = undefined;
                        if (request.clientInfo) {
                            try {
                                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                                ccsCredential = {
                                    credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                                    type: exports.CcsCredentialType.HOME_ACCOUNT_ID
                                };
                            }
                            catch (e) {
                                this.logger.verbose("Could not parse client info for CCS Header: " + e);
                            }
                        }
                        headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
                        endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + "?" + queryParameters;
                        return [2 /*return*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
                }
            });
        });
    };
    /**
     * Creates query string for the /token request
     * @param request
     */
    AuthorizationCodeClient.prototype.createTokenQueryParameters = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request.tokenQueryParameters) {
            parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
    };
    /**
     * Generates a map for all the params to be sent to the service
     * @param request
     */
    AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        parameterBuilder = new RequestParameterBuilder();
                        parameterBuilder.addClientId(this.config.authOptions.clientId);
                        /*
                         * For hybrid spa flow, there will be a code but no verifier
                         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI
                         */
                        if (!this.includeRedirectUri) {
                            // Just validate
                            RequestValidator.validateRedirectUri(request.redirectUri);
                        }
                        else {
                            // Validate and include redirect uri
                            parameterBuilder.addRedirectUri(request.redirectUri);
                        }
                        // Add scope array, parameter builder will add default scopes and dedupe
                        parameterBuilder.addScopes(request.scopes);
                        // add code: user set, not validated
                        parameterBuilder.addAuthorizationCode(request.code);
                        // Add library metadata
                        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                        parameterBuilder.addThrottling();
                        if (this.serverTelemetryManager) {
                            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
                        }
                        // add code_verifier if passed
                        if (request.codeVerifier) {
                            parameterBuilder.addCodeVerifier(request.codeVerifier);
                        }
                        if (this.config.clientCredentials.clientSecret) {
                            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
                        }
                        if (this.config.clientCredentials.clientAssertion) {
                            clientAssertion = this.config.clientCredentials.clientAssertion;
                            parameterBuilder.addClientAssertion(clientAssertion.assertion);
                            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
                        }
                        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
                        parameterBuilder.addClientInfo();
                        if (!(request.authenticationScheme === exports.AuthenticationScheme.POP)) return [3 /*break*/, 2];
                        popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                        return [4 /*yield*/, popTokenGenerator.generateCnf(request)];
                    case 1:
                        reqCnfData = _b.sent();
                        // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
                        parameterBuilder.addPopToken(reqCnfData.reqCnfString);
                        return [3 /*break*/, 3];
                    case 2:
                        if (request.authenticationScheme === exports.AuthenticationScheme.SSH) {
                            if (request.sshJwk) {
                                parameterBuilder.addSshJwk(request.sshJwk);
                            }
                            else {
                                throw ClientConfigurationError.createMissingSshJwkError();
                            }
                        }
                        _b.label = 3;
                    case 3:
                        correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
                        parameterBuilder.addCorrelationId(correlationId);
                        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
                        }
                        ccsCred = undefined;
                        if (request.clientInfo) {
                            try {
                                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                                ccsCred = {
                                    credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                                    type: exports.CcsCredentialType.HOME_ACCOUNT_ID
                                };
                            }
                            catch (e) {
                                this.logger.verbose("Could not parse client info for CCS Header: " + e);
                            }
                        }
                        else {
                            ccsCred = request.ccsCredential;
                        }
                        // Adds these as parameters in the request instead of headers to prevent CORS preflight request
                        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
                            switch (ccsCred.type) {
                                case exports.CcsCredentialType.HOME_ACCOUNT_ID:
                                    try {
                                        clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                                        parameterBuilder.addCcsOid(clientInfo);
                                    }
                                    catch (e) {
                                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                                    }
                                    break;
                                case exports.CcsCredentialType.UPN:
                                    parameterBuilder.addCcsUpn(ccsCred.credential);
                                    break;
                            }
                        }
                        if (request.tokenBodyParameters) {
                            parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);
                        }
                        // Add hybrid spa parameters if not already provided
                        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
                            parameterBuilder.addExtraQueryParameters((_a = {},
                                _a[AADServerParamKeys.RETURN_SPA_CODE] = "1",
                                _a));
                        }
                        return [2 /*return*/, parameterBuilder.createQueryString()];
                }
            });
        });
    };
    /**
     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL
     * @param request
     */
    AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parameterBuilder = new RequestParameterBuilder();
                        parameterBuilder.addClientId(this.config.authOptions.clientId);
                        requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);
                        parameterBuilder.addScopes(requestScopes);
                        // validate the redirectUri (to be a non null value)
                        parameterBuilder.addRedirectUri(request.redirectUri);
                        correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
                        parameterBuilder.addCorrelationId(correlationId);
                        // add response_mode. If not passed in it defaults to query.
                        parameterBuilder.addResponseMode(request.responseMode);
                        // add response_type = code
                        parameterBuilder.addResponseTypeCode();
                        // add library info parameters
                        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                        // add client_info=1
                        parameterBuilder.addClientInfo();
                        if (request.codeChallenge && request.codeChallengeMethod) {
                            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);
                        }
                        if (request.prompt) {
                            parameterBuilder.addPrompt(request.prompt);
                        }
                        if (request.domainHint) {
                            parameterBuilder.addDomainHint(request.domainHint);
                        }
                        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object
                        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
                            // AAD will throw if prompt=select_account is passed with an account hint
                            if (request.sid && request.prompt === PromptValue.NONE) {
                                // SessionID is only used in silent calls
                                this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
                                parameterBuilder.addSid(request.sid);
                            }
                            else if (request.account) {
                                accountSid = this.extractAccountSid(request.account);
                                accountLoginHintClaim = this.extractLoginHint(request.account);
                                // If login_hint claim is present, use it over sid/username
                                if (accountLoginHintClaim) {
                                    this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
                                    parameterBuilder.addLoginHint(accountLoginHintClaim);
                                    try {
                                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                                        parameterBuilder.addCcsOid(clientInfo);
                                    }
                                    catch (e) {
                                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                                    }
                                }
                                else if (accountSid && request.prompt === PromptValue.NONE) {
                                    /*
                                     * If account and loginHint are provided, we will check account first for sid before adding loginHint
                                     * SessionId is only used in silent calls
                                     */
                                    this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
                                    parameterBuilder.addSid(accountSid);
                                    try {
                                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                                        parameterBuilder.addCcsOid(clientInfo);
                                    }
                                    catch (e) {
                                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                                    }
                                }
                                else if (request.loginHint) {
                                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
                                    parameterBuilder.addLoginHint(request.loginHint);
                                    parameterBuilder.addCcsUpn(request.loginHint);
                                }
                                else if (request.account.username) {
                                    // Fallback to account username if provided
                                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
                                    parameterBuilder.addLoginHint(request.account.username);
                                    try {
                                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                                        parameterBuilder.addCcsOid(clientInfo);
                                    }
                                    catch (e) {
                                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                                    }
                                }
                            }
                            else if (request.loginHint) {
                                this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
                                parameterBuilder.addLoginHint(request.loginHint);
                                parameterBuilder.addCcsUpn(request.loginHint);
                            }
                        }
                        else {
                            this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
                        }
                        if (request.nonce) {
                            parameterBuilder.addNonce(request.nonce);
                        }
                        if (request.state) {
                            parameterBuilder.addState(request.state);
                        }
                        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
                        }
                        if (request.extraQueryParameters) {
                            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
                        }
                        if (!request.nativeBroker) return [3 /*break*/, 2];
                        // signal ests that this is a WAM call
                        parameterBuilder.addNativeBroker();
                        if (!(request.authenticationScheme === exports.AuthenticationScheme.POP)) return [3 /*break*/, 2];
                        popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                        return [4 /*yield*/, popTokenGenerator.generateCnf(request)];
                    case 1:
                        reqCnfData = _a.sent();
                        parameterBuilder.addPopToken(reqCnfData.reqCnfHash);
                        _a.label = 2;
                    case 2: return [2 /*return*/, parameterBuilder.createQueryString()];
                }
            });
        });
    };
    /**
     * This API validates the `EndSessionRequest` and creates a URL
     * @param request
     */
    AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request.postLogoutRedirectUri) {
            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
            parameterBuilder.addCorrelationId(request.correlationId);
        }
        if (request.idTokenHint) {
            parameterBuilder.addIdTokenHint(request.idTokenHint);
        }
        if (request.state) {
            parameterBuilder.addState(request.state);
        }
        if (request.logoutHint) {
            parameterBuilder.addLogoutHint(request.logoutHint);
        }
        if (request.extraQueryParameters) {
            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
        }
        return parameterBuilder.createQueryString();
    };
    /**
     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.
     * @param account
     */
    AuthorizationCodeClient.prototype.extractAccountSid = function (account) {
        var _a;
        return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;
    };
    AuthorizationCodeClient.prototype.extractLoginHint = function (account) {
        var _a;
        return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;
    };
    return AuthorizationCodeClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * OAuth2.0 Device code client
 */
var DeviceCodeClient = /** @class */ (function (_super) {
    __extends(DeviceCodeClient, _super);
    function DeviceCodeClient(configuration) {
        return _super.call(this, configuration) || this;
    }
    /**
     * Gets device code from device code endpoint, calls back to with device code response, and
     * polls token endpoint to exchange device code for tokens
     * @param request
     */
    DeviceCodeClient.prototype.acquireToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var deviceCodeResponse, reqTimestamp, response, responseHandler;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDeviceCode(request)];
                    case 1:
                        deviceCodeResponse = _a.sent();
                        request.deviceCodeCallback(deviceCodeResponse);
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.acquireTokenWithDeviceCode(request, deviceCodeResponse)];
                    case 2:
                        response = _a.sent();
                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                        // Validate response. This function throws a server error if an error is returned by the server.
                        responseHandler.validateTokenResponse(response);
                        return [4 /*yield*/, responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Creates device code request and executes http GET
     * @param request
     */
    DeviceCodeClient.prototype.getDeviceCode = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var queryString, headers, thumbprint;
            return __generator(this, function (_a) {
                queryString = this.createQueryString(request);
                headers = this.createTokenRequestHeaders();
                thumbprint = {
                    clientId: this.config.authOptions.clientId,
                    authority: request.authority,
                    scopes: request.scopes,
                    claims: request.claims,
                    authenticationScheme: request.authenticationScheme,
                    resourceRequestMethod: request.resourceRequestMethod,
                    resourceRequestUri: request.resourceRequestUri,
                    shrClaims: request.shrClaims,
                    sshKid: request.sshKid
                };
                return [2 /*return*/, this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers, thumbprint)];
            });
        });
    };
    /**
     * Executes POST request to device code endpoint
     * @param deviceCodeEndpoint
     * @param queryString
     * @param headers
     */
    DeviceCodeClient.prototype.executePostRequestToDeviceCodeEndpoint = function (deviceCodeEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, userCode, deviceCode, verificationUri, expiresIn, interval, message;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {
                            body: queryString,
                            headers: headers,
                            proxyUrl: this.config.systemOptions.proxyUrl
                        })];
                    case 1:
                        _a = (_b.sent()).body, userCode = _a.user_code, deviceCode = _a.device_code, verificationUri = _a.verification_uri, expiresIn = _a.expires_in, interval = _a.interval, message = _a.message;
                        return [2 /*return*/, {
                                userCode: userCode,
                                deviceCode: deviceCode,
                                verificationUri: verificationUri,
                                expiresIn: expiresIn,
                                interval: interval,
                                message: message
                            }];
                }
            });
        });
    };
    /**
     * Create device code endpoint query parameters and returns string
     */
    DeviceCodeClient.prototype.createQueryString = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addScopes(request.scopes);
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
    };
    /**
     * Breaks the polling with specific conditions.
     * @param request CommonDeviceCodeRequest
     * @param deviceCodeResponse DeviceCodeResponse
     */
    DeviceCodeClient.prototype.continuePolling = function (deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
            this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
            throw ClientAuthError.createDeviceCodeCancelledError();
        }
        else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {
            this.logger.error("User defined timeout for device code polling reached. The timeout was set for " + userSpecifiedTimeout);
            throw ClientAuthError.createUserTimeoutReachedError();
        }
        else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {
            if (userSpecifiedTimeout) {
                this.logger.verbose("User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for " + userSpecifiedTimeout);
            }
            this.logger.error("Device code expired. Expiration time of device code was " + deviceCodeExpirationTime);
            throw ClientAuthError.createDeviceCodeExpiredError();
        }
        return true;
    };
    /**
     * Creates token request with device code response and polls token endpoint at interval set by the device code
     * response
     * @param request
     * @param deviceCodeResponse
     */
    DeviceCodeClient.prototype.acquireTokenWithDeviceCode = function (request, deviceCodeResponse) {
        return __awaiter(this, void 0, void 0, function () {
            var requestBody, headers, userSpecifiedTimeout, deviceCodeExpirationTime, pollingIntervalMilli, thumbprint, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
                        headers = this.createTokenRequestHeaders();
                        userSpecifiedTimeout = request.timeout ? TimeUtils.nowSeconds() + request.timeout : undefined;
                        deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;
                        pollingIntervalMilli = deviceCodeResponse.interval * 1000;
                        _a.label = 1;
                    case 1:
                        if (!this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) return [3 /*break*/, 8];
                        thumbprint = {
                            clientId: this.config.authOptions.clientId,
                            authority: request.authority,
                            scopes: request.scopes,
                            claims: request.claims,
                            authenticationScheme: request.authenticationScheme,
                            resourceRequestMethod: request.resourceRequestMethod,
                            resourceRequestUri: request.resourceRequestUri,
                            shrClaims: request.shrClaims,
                            sshKid: request.sshKid
                        };
                        return [4 /*yield*/, this.executePostToTokenEndpoint(this.authority.tokenEndpoint, requestBody, headers, thumbprint)];
                    case 2:
                        response = _a.sent();
                        if (!(response.body && response.body.error)) return [3 /*break*/, 6];
                        if (!(response.body.error === Constants.AUTHORIZATION_PENDING)) return [3 /*break*/, 4];
                        this.logger.info("Authorization pending. Continue polling.");
                        return [4 /*yield*/, TimeUtils.delay(pollingIntervalMilli)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        // for any other error, throw
                        this.logger.info("Unexpected error in polling from the server");
                        throw ServerError.createPostRequestFailed(response.body.error);
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        this.logger.verbose("Authorization completed successfully. Polling stopped.");
                        return [2 /*return*/, response.body];
                    case 7: return [3 /*break*/, 1];
                    case 8:
                        /*
                         * The above code should've thrown by this point, but to satisfy TypeScript,
                         * and in the rare case the conditionals in continuePolling() may not catch everything...
                         */
                        this.logger.error("Polling stopped for unknown reasons.");
                        throw ClientAuthError.createDeviceCodeUnknownError();
                }
            });
        });
    };
    /**
     * Creates query parameters and converts to string.
     * @param request
     * @param deviceCodeResponse
     */
    DeviceCodeClient.prototype.createTokenRequestBody = function (request, deviceCodeResponse) {
        var requestParameters = new RequestParameterBuilder();
        requestParameters.addScopes(request.scopes);
        requestParameters.addClientId(this.config.authOptions.clientId);
        requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);
        requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        requestParameters.addCorrelationId(correlationId);
        requestParameters.addClientInfo();
        requestParameters.addLibraryInfo(this.config.libraryInfo);
        requestParameters.addApplicationTelemetry(this.config.telemetry.application);
        requestParameters.addThrottling();
        if (this.serverTelemetryManager) {
            requestParameters.addServerTelemetry(this.serverTelemetryManager);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
            requestParameters.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        return requestParameters.createQueryString();
    };
    return DeviceCodeClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Enumeration of operations that are instrumented by have their performance measured by the PerformanceClient.
 *
 * @export
 * @enum {number}
 */
exports.PerformanceEvents = void 0;
(function (PerformanceEvents) {
    /**
     * acquireTokenByCode API (msal-browser and msal-node).
     * Used to acquire tokens by trading an authorization code against the token endpoint.
     */
    PerformanceEvents["AcquireTokenByCode"] = "acquireTokenByCode";
    /**
     * acquireTokenByRefreshToken API (msal-browser and msal-node).
     * Used to renew an access token using a refresh token against the token endpoint.
     */
    PerformanceEvents["AcquireTokenByRefreshToken"] = "acquireTokenByRefreshToken";
    /**
     * acquireTokenSilent API (msal-browser and msal-node).
     * Used to silently acquire a new access token (from the cache or the network).
     */
    PerformanceEvents["AcquireTokenSilent"] = "acquireTokenSilent";
    /**
     * acquireTokenSilentAsync (msal-browser).
     * Internal API for acquireTokenSilent.
     */
    PerformanceEvents["AcquireTokenSilentAsync"] = "acquireTokenSilentAsync";
    /**
     * acquireTokenPopup (msal-browser).
     * Used to acquire a new access token interactively through pop ups
     */
    PerformanceEvents["AcquireTokenPopup"] = "acquireTokenPopup";
    /**
     * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
     * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
     */
    PerformanceEvents["CryptoOptsGetPublicKeyThumbprint"] = "cryptoOptsGetPublicKeyThumbprint";
    /**
     * signJwt API in CryptoOpts class (msal-browser).
     * Used to signed a pop token.
     */
    PerformanceEvents["CryptoOptsSignJwt"] = "cryptoOptsSignJwt";
    /**
     * acquireToken API in the SilentCacheClient class (msal-browser).
     * Used to read access tokens from the cache.
     */
    PerformanceEvents["SilentCacheClientAcquireToken"] = "silentCacheClientAcquireToken";
    /**
     * acquireToken API in the SilentIframeClient class (msal-browser).
     * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
     */
    PerformanceEvents["SilentIframeClientAcquireToken"] = "silentIframeClientAcquireToken";
    /**
     * acquireToken API in SilentRereshClient (msal-browser).
     * Used to acquire a new set of tokens from the token endpoint using a refresh token.
     */
    PerformanceEvents["SilentRefreshClientAcquireToken"] = "silentRefreshClientAcquireToken";
    /**
     * ssoSilent API (msal-browser).
     * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
     */
    PerformanceEvents["SsoSilent"] = "ssoSilent";
    /**
     * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
     * Used to load authority metadata for a request.
     */
    PerformanceEvents["StandardInteractionClientGetDiscoveredAuthority"] = "standardInteractionClientGetDiscoveredAuthority";
    /**
     * acquireToken APIs in msal-browser.
     * Used to make an /authorize endpoint call with native brokering enabled.
     */
    PerformanceEvents["FetchAccountIdWithNativeBroker"] = "fetchAccountIdWithNativeBroker";
    /**
     * acquireToken API in NativeInteractionClient class (msal-browser).
     * Used to acquire a token from Native component when native brokering is enabled.
     */
    PerformanceEvents["NativeInteractionClientAcquireToken"] = "nativeInteractionClientAcquireToken";
    /**
     * Time spent on the network for refresh token acquisition
     */
    PerformanceEvents["RefreshTokenClientExecuteTokenRequest"] = "refreshTokenClientExecuteTokenRequest";
    /**
     * Time spent creating default headers for requests to token endpoint
     */
    PerformanceEvents["BaseClientCreateTokenRequestHeaders"] = "baseClientCreateTokenRequestHeaders";
    /**
     * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
     */
    PerformanceEvents["BrokerHandhshake"] = "brokerHandshake";
    /**
     * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
     */
    PerformanceEvents["AcquireTokenByRefreshTokenInBroker"] = "acquireTokenByRefreshTokenInBroker";
    /**
     * acquireToken API in BrokerClientApplication.
     * Used to acquire a token on behalf of the embedded application (PW-Broker).
     */
    PerformanceEvents["AcquireTokenByBroker"] = "acquireTokenByBroker";
})(exports.PerformanceEvents || (exports.PerformanceEvents = {}));
/**
 * State of the performance event.
 *
 * @export
 * @enum {number}
 */
exports.PerformanceEventStatus = void 0;
(function (PerformanceEventStatus) {
    PerformanceEventStatus[PerformanceEventStatus["NotStarted"] = 0] = "NotStarted";
    PerformanceEventStatus[PerformanceEventStatus["InProgress"] = 1] = "InProgress";
    PerformanceEventStatus[PerformanceEventStatus["Completed"] = 2] = "Completed";
})(exports.PerformanceEventStatus || (exports.PerformanceEventStatus = {}));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * OAuth2.0 refresh token client
 */
var RefreshTokenClient = /** @class */ (function (_super) {
    __extends(RefreshTokenClient, _super);
    function RefreshTokenClient(configuration, performanceClient) {
        return _super.call(this, configuration, performanceClient) || this;
    }
    RefreshTokenClient.prototype.acquireToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var reqTimestamp, response, responseHandler;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority)];
                    case 1:
                        response = _a.sent();
                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                        responseHandler.validateTokenResponse(response.body);
                        return [2 /*return*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache)];
                }
            });
        });
    };
    /**
     * Gets cached refresh token and attaches to request, then calls acquireToken API
     * @param request
     */
    RefreshTokenClient.prototype.acquireTokenByRefreshToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;
            return __generator(this, function (_a) {
                // Cannot renew token if no request object is given.
                if (!request) {
                    throw ClientConfigurationError.createEmptyTokenRequestError();
                }
                // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
                if (!request.account) {
                    throw ClientAuthError.createNoAccountInSilentRequestError();
                }
                isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment, this.config.authOptions.clientId);
                // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest
                if (isFOCI) {
                    try {
                        return [2 /*return*/, this.acquireTokenWithCachedRefreshToken(request, true)];
                    }
                    catch (e) {
                        noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
                        clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
                        // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)
                        if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
                            return [2 /*return*/, this.acquireTokenWithCachedRefreshToken(request, false)];
                            // throw in all other cases
                        }
                        else {
                            throw e;
                        }
                    }
                }
                // fall back to application refresh token acquisition
                return [2 /*return*/, this.acquireTokenWithCachedRefreshToken(request, false)];
            });
        });
    };
    /**
     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
     * @param request
     */
    RefreshTokenClient.prototype.acquireTokenWithCachedRefreshToken = function (request, foci) {
        return __awaiter(this, void 0, void 0, function () {
            var refreshToken, refreshTokenRequest;
            return __generator(this, function (_a) {
                refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request.account, foci);
                // no refresh Token
                if (!refreshToken) {
                    throw InteractionRequiredAuthError.createNoTokensFoundError();
                }
                refreshTokenRequest = __assign(__assign({}, request), { refreshToken: refreshToken.secret, authenticationScheme: request.authenticationScheme || exports.AuthenticationScheme.BEARER, ccsCredential: {
                        credential: request.account.homeAccountId,
                        type: exports.CcsCredentialType.HOME_ACCOUNT_ID
                    } });
                return [2 /*return*/, this.acquireToken(refreshTokenRequest)];
            });
        });
    };
    /**
     * Constructs the network message and makes a NW call to the underlying secure token service
     * @param request
     * @param authority
     */
    RefreshTokenClient.prototype.executeTokenRequest = function (request, authority) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var acquireTokenMeasurement, requestBody, queryParameters, headers, thumbprint, endpoint;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        acquireTokenMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(exports.PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
                        return [4 /*yield*/, this.createTokenRequestBody(request)];
                    case 1:
                        requestBody = _b.sent();
                        queryParameters = this.createTokenQueryParameters(request);
                        headers = this.createTokenRequestHeaders(request.ccsCredential);
                        thumbprint = {
                            clientId: this.config.authOptions.clientId,
                            authority: authority.canonicalAuthority,
                            scopes: request.scopes,
                            claims: request.claims,
                            authenticationScheme: request.authenticationScheme,
                            resourceRequestMethod: request.resourceRequestMethod,
                            resourceRequestUri: request.resourceRequestUri,
                            shrClaims: request.shrClaims,
                            sshKid: request.sshKid
                        };
                        endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParameters);
                        return [2 /*return*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)
                                .then(function (result) {
                                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                                    success: true
                                });
                                return result;
                            })
                                .catch(function (error) {
                                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                                    success: false
                                });
                                throw error;
                            })];
                }
            });
        });
    };
    /**
     * Creates query string for the /token request
     * @param request
     */
    RefreshTokenClient.prototype.createTokenQueryParameters = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request.tokenQueryParameters) {
            parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
    };
    /**
     * Helper function to create the token request body
     * @param request
     */
    RefreshTokenClient.prototype.createTokenRequestBody = function (request) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var correlationId, acquireTokenMeasurement, parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, clientInfo;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        correlationId = request.correlationId;
                        acquireTokenMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(exports.PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);
                        parameterBuilder = new RequestParameterBuilder();
                        parameterBuilder.addClientId(this.config.authOptions.clientId);
                        parameterBuilder.addScopes(request.scopes);
                        parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
                        parameterBuilder.addClientInfo();
                        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                        parameterBuilder.addThrottling();
                        if (this.serverTelemetryManager) {
                            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
                        }
                        parameterBuilder.addCorrelationId(correlationId);
                        parameterBuilder.addRefreshToken(request.refreshToken);
                        if (this.config.clientCredentials.clientSecret) {
                            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
                        }
                        if (this.config.clientCredentials.clientAssertion) {
                            clientAssertion = this.config.clientCredentials.clientAssertion;
                            parameterBuilder.addClientAssertion(clientAssertion.assertion);
                            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
                        }
                        if (!(request.authenticationScheme === exports.AuthenticationScheme.POP)) return [3 /*break*/, 2];
                        popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                        return [4 /*yield*/, popTokenGenerator.generateCnf(request)];
                    case 1:
                        reqCnfData = _b.sent();
                        // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
                        parameterBuilder.addPopToken(reqCnfData.reqCnfString);
                        return [3 /*break*/, 3];
                    case 2:
                        if (request.authenticationScheme === exports.AuthenticationScheme.SSH) {
                            if (request.sshJwk) {
                                parameterBuilder.addSshJwk(request.sshJwk);
                            }
                            else {
                                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                                    success: false
                                });
                                throw ClientConfigurationError.createMissingSshJwkError();
                            }
                        }
                        _b.label = 3;
                    case 3:
                        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
                        }
                        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
                            switch (request.ccsCredential.type) {
                                case exports.CcsCredentialType.HOME_ACCOUNT_ID:
                                    try {
                                        clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                                        parameterBuilder.addCcsOid(clientInfo);
                                    }
                                    catch (e) {
                                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                                    }
                                    break;
                                case exports.CcsCredentialType.UPN:
                                    parameterBuilder.addCcsUpn(request.ccsCredential.credential);
                                    break;
                            }
                        }
                        acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                            success: true
                        });
                        return [2 /*return*/, parameterBuilder.createQueryString()];
                }
            });
        });
    };
    return RefreshTokenClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * OAuth2.0 client credential grant
 */
var ClientCredentialClient = /** @class */ (function (_super) {
    __extends(ClientCredentialClient, _super);
    function ClientCredentialClient(configuration, appTokenProvider) {
        var _this = _super.call(this, configuration) || this;
        _this.appTokenProvider = appTokenProvider;
        return _this;
    }
    /**
     * Public API to acquire a token with ClientCredential Flow for Confidential clients
     * @param request
     */
    ClientCredentialClient.prototype.acquireToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var cachedAuthenticationResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.scopeSet = new ScopeSet(request.scopes || []);
                        if (!request.skipCache) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [4 /*yield*/, this.getCachedAuthenticationResult(request)];
                    case 3:
                        cachedAuthenticationResult = _a.sent();
                        if (!cachedAuthenticationResult) return [3 /*break*/, 4];
                        return [2 /*return*/, cachedAuthenticationResult];
                    case 4: return [4 /*yield*/, this.executeTokenRequest(request, this.authority)];
                    case 5: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * looks up cache if the tokens are cached already
     */
    ClientCredentialClient.prototype.getCachedAuthenticationResult = function (request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var cachedAccessToken;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        cachedAccessToken = this.readAccessTokenFromCache();
                        if (!cachedAccessToken) {
                            (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                            return [2 /*return*/, null];
                        }
                        if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                            (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                                account: null,
                                idToken: null,
                                accessToken: cachedAccessToken,
                                refreshToken: null,
                                appMetadata: null
                            }, true, request)];
                    case 1: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    /**
     * Reads access token from the cache
     * TODO: Move this call to cacheManager instead
     */
    ClientCredentialClient.prototype.readAccessTokenFromCache = function () {
        var accessTokenFilter = {
            homeAccountId: Constants.EMPTY_STRING,
            environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
            credentialType: exports.CredentialType.ACCESS_TOKEN,
            clientId: this.config.authOptions.clientId,
            realm: this.authority.tenant,
            target: this.scopeSet.printScopesLowerCase()
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) { return credentialCache.accessTokens[key]; });
        if (accessTokens.length < 1) {
            return null;
        }
        else if (accessTokens.length > 1) {
            throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
    };
    /**
     * Makes a network call to request the token from the service
     * @param request
     * @param authority
     */
    ClientCredentialClient.prototype.executeTokenRequest = function (request, authority) {
        return __awaiter(this, void 0, void 0, function () {
            var serverTokenResponse, reqTimestamp, appTokenPropviderParameters, appTokenProviderResult, requestBody, headers, thumbprint, response, responseHandler, tokenResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.appTokenProvider) return [3 /*break*/, 2];
                        this.logger.info("Using appTokenProvider extensibility.");
                        appTokenPropviderParameters = {
                            correlationId: request.correlationId,
                            tenantId: this.config.authOptions.authority.tenant,
                            scopes: request.scopes,
                            claims: request.claims,
                        };
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.appTokenProvider(appTokenPropviderParameters)];
                    case 1:
                        appTokenProviderResult = _a.sent();
                        serverTokenResponse = {
                            access_token: appTokenProviderResult.accessToken,
                            expires_in: appTokenProviderResult.expiresInSeconds,
                            refresh_in: appTokenProviderResult.refreshInSeconds,
                            token_type: exports.AuthenticationScheme.BEARER
                        };
                        return [3 /*break*/, 4];
                    case 2:
                        requestBody = this.createTokenRequestBody(request);
                        headers = this.createTokenRequestHeaders();
                        thumbprint = {
                            clientId: this.config.authOptions.clientId,
                            authority: request.authority,
                            scopes: request.scopes,
                            claims: request.claims,
                            authenticationScheme: request.authenticationScheme,
                            resourceRequestMethod: request.resourceRequestMethod,
                            resourceRequestUri: request.resourceRequestUri,
                            shrClaims: request.shrClaims,
                            sshKid: request.sshKid
                        };
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
                    case 3:
                        response = _a.sent();
                        serverTokenResponse = response.body;
                        _a.label = 4;
                    case 4:
                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                        responseHandler.validateTokenResponse(serverTokenResponse);
                        return [4 /*yield*/, responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request)];
                    case 5:
                        tokenResponse = _a.sent();
                        return [2 /*return*/, tokenResponse];
                }
            });
        });
    };
    /**
     * generate the request to the server in the acceptable format
     * @param request
     */
    ClientCredentialClient.prototype.createTokenRequestBody = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request.scopes, false);
        parameterBuilder.addGrantType(GrantType.CLIENT_CREDENTIALS_GRANT);
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        // Use clientAssertion from request, fallback to client assertion in base configuration
        var clientAssertion = request.clientAssertion || this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
            parameterBuilder.addClientAssertion(clientAssertion.assertion);
            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
    };
    return ClientCredentialClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * On-Behalf-Of client
 */
var OnBehalfOfClient = /** @class */ (function (_super) {
    __extends(OnBehalfOfClient, _super);
    function OnBehalfOfClient(configuration) {
        return _super.call(this, configuration) || this;
    }
    /**
     * Public API to acquire tokens with on behalf of flow
     * @param request
     */
    OnBehalfOfClient.prototype.acquireToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.scopeSet = new ScopeSet(request.scopes || []);
                        // generate the user_assertion_hash for OBOAssertion
                        _a = this;
                        return [4 /*yield*/, this.cryptoUtils.hashString(request.oboAssertion)];
                    case 1:
                        // generate the user_assertion_hash for OBOAssertion
                        _a.userAssertionHash = _b.sent();
                        if (!request.skipCache) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        _b.trys.push([3, 5, , 7]);
                        return [4 /*yield*/, this.getCachedAuthenticationResult(request)];
                    case 4: return [2 /*return*/, _b.sent()];
                    case 5:
                        _b.sent();
                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];
                    case 6: 
                    // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT
                    return [2 /*return*/, _b.sent()];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * look up cache for tokens
     * Find idtoken in the cache
     * Find accessToken based on user assertion and account info in the cache
     * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires
     * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session
     * @param request
     */
    OnBehalfOfClient.prototype.getCachedAuthenticationResult = function (request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);
                        if (!cachedAccessToken) {
                            // Must refresh due to non-existent access_token.
                            (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                            this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                            throw ClientAuthError.createRefreshRequiredError();
                        }
                        else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                            // Access token expired, will need to renewed
                            (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                            this.logger.info("OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                            throw ClientAuthError.createRefreshRequiredError();
                        }
                        cachedIdToken = this.readIdTokenFromCacheForOBO(request, cachedAccessToken.homeAccountId);
                        cachedAccount = null;
                        if (cachedIdToken) {
                            idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);
                            localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;
                            accountInfo = {
                                homeAccountId: cachedIdToken.homeAccountId,
                                environment: cachedIdToken.environment,
                                tenantId: cachedIdToken.realm,
                                username: Constants.EMPTY_STRING,
                                localAccountId: localAccountId || Constants.EMPTY_STRING
                            };
                            cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);
                        }
                        // increment telemetry cache hit counter
                        if (this.config.serverTelemetryManager) {
                            this.config.serverTelemetryManager.incrementCacheHits();
                        }
                        return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                                account: cachedAccount,
                                accessToken: cachedAccessToken,
                                idToken: cachedIdToken,
                                refreshToken: null,
                                appMetadata: null
                            }, true, request, idTokenObject)];
                    case 1: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    /**
     * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager
     * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service
     * @param request
     */
    OnBehalfOfClient.prototype.readIdTokenFromCacheForOBO = function (request, atHomeAccountId) {
        var idTokenFilter = {
            homeAccountId: atHomeAccountId,
            environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
            credentialType: exports.CredentialType.ID_TOKEN,
            clientId: this.config.authOptions.clientId,
            realm: this.authority.tenant
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function (key) { return credentialCache.idTokens[key]; });
        // When acquiring a token on behalf of an application, there might not be an id token in the cache
        if (idTokens.length < 1) {
            return null;
        }
        return idTokens[0];
    };
    /**
     * Fetches the cached access token based on incoming assertion
     * @param clientId
     * @param request
     * @param userAssertionHash
     */
    OnBehalfOfClient.prototype.readAccessTokenFromCacheForOBO = function (clientId, request) {
        var authScheme = request.authenticationScheme || exports.AuthenticationScheme.BEARER;
        /*
         * Distinguish between Bearer and PoP/SSH token cache types
         * Cast to lowercase to handle "bearer" from ADFS
         */
        var credentialType = (authScheme && authScheme.toLowerCase() !== exports.AuthenticationScheme.BEARER.toLowerCase()) ? exports.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : exports.CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
            credentialType: credentialType,
            clientId: clientId,
            target: this.scopeSet.printScopesLowerCase(),
            tokenType: authScheme,
            keyId: request.sshKid,
            requestedClaimsHash: request.requestedClaimsHash,
            userAssertionHash: this.userAssertionHash
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) { return credentialCache.accessTokens[key]; });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
            return null;
        }
        else if (numAccessTokens > 1) {
            throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
    };
    /**
     * Make a network call to the server requesting credentials
     * @param request
     * @param authority
     */
    OnBehalfOfClient.prototype.executeTokenRequest = function (request, authority, userAssertionHash) {
        return __awaiter(this, void 0, void 0, function () {
            var requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestBody = this.createTokenRequestBody(request);
                        headers = this.createTokenRequestHeaders();
                        thumbprint = {
                            clientId: this.config.authOptions.clientId,
                            authority: request.authority,
                            scopes: request.scopes,
                            claims: request.claims,
                            authenticationScheme: request.authenticationScheme,
                            resourceRequestMethod: request.resourceRequestMethod,
                            resourceRequestUri: request.resourceRequestUri,
                            shrClaims: request.shrClaims,
                            sshKid: request.sshKid
                        };
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
                    case 1:
                        response = _a.sent();
                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                        responseHandler.validateTokenResponse(response.body);
                        return [4 /*yield*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash)];
                    case 2:
                        tokenResponse = _a.sent();
                        return [2 /*return*/, tokenResponse];
                }
            });
        });
    };
    /**
     * generate a server request in accepable format
     * @param request
     */
    OnBehalfOfClient.prototype.createTokenRequestBody = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request.scopes);
        parameterBuilder.addGrantType(GrantType.JWT_BEARER);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);
        parameterBuilder.addOboAssertion(request.oboAssertion);
        if (this.config.clientCredentials.clientSecret) {
            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
            var clientAssertion = this.config.clientCredentials.clientAssertion;
            parameterBuilder.addClientAssertion(clientAssertion.assertion);
            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        return parameterBuilder.createQueryString();
    };
    return OnBehalfOfClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var SilentFlowClient = /** @class */ (function (_super) {
    __extends(SilentFlowClient, _super);
    function SilentFlowClient(configuration, performanceClient) {
        return _super.call(this, configuration, performanceClient) || this;
    }
    /**
     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew
     * the given token and returns the renewed token
     * @param request
     */
    SilentFlowClient.prototype.acquireToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, refreshTokenClient;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.acquireCachedToken(request)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
                            refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
                            return [2 /*return*/, refreshTokenClient.acquireTokenByRefreshToken(request)];
                        }
                        else {
                            throw e_1;
                        }
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves token from cache or throws an error if it must be refreshed.
     * @param request
     */
    SilentFlowClient.prototype.acquireCachedToken = function (request) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var environment, cacheRecord;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        // Cannot renew token if no request object is given.
                        if (!request) {
                            throw ClientConfigurationError.createEmptyTokenRequestError();
                        }
                        if (request.forceRefresh) {
                            // Must refresh due to present force_refresh flag.
                            (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
                            this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
                            throw ClientAuthError.createRefreshRequiredError();
                        }
                        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
                        if (!request.account) {
                            throw ClientAuthError.createNoAccountInSilentRequestError();
                        }
                        environment = request.authority || this.authority.getPreferredCache();
                        cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);
                        if (!cacheRecord.accessToken) {
                            // Must refresh due to non-existent access_token.
                            (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                            this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                            throw ClientAuthError.createRefreshRequiredError();
                        }
                        else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||
                            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                            // Must refresh due to expired access_token.
                            (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                            this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                            throw ClientAuthError.createRefreshRequiredError();
                        }
                        else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
                            // Must refresh due to the refresh_in value.
                            (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
                            this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
                            throw ClientAuthError.createRefreshRequiredError();
                        }
                        if (this.config.serverTelemetryManager) {
                            this.config.serverTelemetryManager.incrementCacheHits();
                        }
                        return [4 /*yield*/, this.generateResultFromCacheRecord(cacheRecord, request)];
                    case 1: return [2 /*return*/, _e.sent()];
                }
            });
        });
    };
    /**
     * Helper function to build response object from the CacheRecord
     * @param cacheRecord
     */
    SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {
        return __awaiter(this, void 0, void 0, function () {
            var idTokenObj;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (cacheRecord.idToken) {
                            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);
                        }
                        return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return SilentFlowClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Oauth2.0 Password grant client
 * Note: We are only supporting public clients for password grant and for purely testing purposes
 */
var UsernamePasswordClient = /** @class */ (function (_super) {
    __extends(UsernamePasswordClient, _super);
    function UsernamePasswordClient(configuration) {
        return _super.call(this, configuration) || this;
    }
    /**
     * API to acquire a token by passing the username and password to the service in exchage of credentials
     * password_grant
     * @param request
     */
    UsernamePasswordClient.prototype.acquireToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var reqTimestamp, response, responseHandler, tokenResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.info("in acquireToken call");
                        reqTimestamp = TimeUtils.nowSeconds();
                        return [4 /*yield*/, this.executeTokenRequest(this.authority, request)];
                    case 1:
                        response = _a.sent();
                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                        // Validate response. This function throws a server error if an error is returned by the server.
                        responseHandler.validateTokenResponse(response.body);
                        tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);
                        return [2 /*return*/, tokenResponse];
                }
            });
        });
    };
    /**
     * Executes POST request to token endpoint
     * @param authority
     * @param request
     */
    UsernamePasswordClient.prototype.executeTokenRequest = function (authority, request) {
        return __awaiter(this, void 0, void 0, function () {
            var thumbprint, requestBody, headers;
            return __generator(this, function (_a) {
                thumbprint = {
                    clientId: this.config.authOptions.clientId,
                    authority: authority.canonicalAuthority,
                    scopes: request.scopes,
                    claims: request.claims,
                    authenticationScheme: request.authenticationScheme,
                    resourceRequestMethod: request.resourceRequestMethod,
                    resourceRequestUri: request.resourceRequestUri,
                    shrClaims: request.shrClaims,
                    sshKid: request.sshKid
                };
                requestBody = this.createTokenRequestBody(request);
                headers = this.createTokenRequestHeaders({
                    credential: request.username,
                    type: exports.CcsCredentialType.UPN
                });
                return [2 /*return*/, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
            });
        });
    };
    /**
     * Generates a map for all the params to be sent to the service
     * @param request
     */
    UsernamePasswordClient.prototype.createTokenRequestBody = function (request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addUsername(request.username);
        parameterBuilder.addPassword(request.password);
        parameterBuilder.addScopes(request.scopes);
        parameterBuilder.addResponseTypeForTokenAndIdToken();
        parameterBuilder.addGrantType(GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
            var clientAssertion = this.config.clientCredentials.clientAssertion;
            parameterBuilder.addClientAssertion(clientAssertion.assertion);
            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.username) {
            parameterBuilder.addCcsUpn(request.username);
        }
        return parameterBuilder.createQueryString();
    };
    return UsernamePasswordClient;
}(BaseClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function isOpenIdConfigResponse(response) {
    return (response.hasOwnProperty("authorization_endpoint") &&
        response.hasOwnProperty("token_endpoint") &&
        response.hasOwnProperty("issuer") &&
        response.hasOwnProperty("jwks_uri"));
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var rawMetdataJSON = { "endpointMetadata": { "https://login.microsoftonline.com/common/": { "token_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/common/": { "token_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/common/": { "token_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/consumers/": { "token_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/consumers/": { "token_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/consumers/": { "token_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/organizations/": { "token_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/organizations/": { "token_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/organizations/": { "token_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" } }, "instanceDiscoveryMetadata": { "https://login.microsoftonline.com/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/common/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/consumers/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/organizations/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] } } };
var EndpointMetadata = rawMetdataJSON.endpointMetadata;
var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Protocol modes supported by MSAL.
 */
exports.ProtocolMode = void 0;
(function (ProtocolMode) {
    ProtocolMode["AAD"] = "AAD";
    ProtocolMode["OIDC"] = "OIDC";
})(exports.ProtocolMode || (exports.ProtocolMode = {}));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var AuthorityMetadataEntity = /** @class */ (function () {
    function AuthorityMetadataEntity() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    }
    /**
     * Update the entity with new aliases, preferred_cache and preferred_network values
     * @param metadata
     * @param fromNetwork
     */
    AuthorityMetadataEntity.prototype.updateCloudDiscoveryMetadata = function (metadata, fromNetwork) {
        this.aliases = metadata.aliases;
        this.preferred_cache = metadata.preferred_cache;
        this.preferred_network = metadata.preferred_network;
        this.aliasesFromNetwork = fromNetwork;
    };
    /**
     * Update the entity with new endpoints
     * @param metadata
     * @param fromNetwork
     */
    AuthorityMetadataEntity.prototype.updateEndpointMetadata = function (metadata, fromNetwork) {
        this.authorization_endpoint = metadata.authorization_endpoint;
        this.token_endpoint = metadata.token_endpoint;
        this.end_session_endpoint = metadata.end_session_endpoint;
        this.issuer = metadata.issuer;
        this.endpointsFromNetwork = fromNetwork;
        this.jwks_uri = metadata.jwks_uri;
    };
    /**
     * Save the authority that was used to create this cache entry
     * @param authority
     */
    AuthorityMetadataEntity.prototype.updateCanonicalAuthority = function (authority) {
        this.canonical_authority = authority;
    };
    /**
     * Reset the exiresAt value
     */
    AuthorityMetadataEntity.prototype.resetExpiresAt = function () {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    };
    /**
     * Returns whether or not the data needs to be refreshed
     */
    AuthorityMetadataEntity.prototype.isExpired = function () {
        return this.expiresAt <= TimeUtils.nowSeconds();
    };
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    AuthorityMetadataEntity.isAuthorityMetadataEntity = function (key, entity) {
        if (!entity) {
            return false;
        }
        return (key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&
            entity.hasOwnProperty("aliases") &&
            entity.hasOwnProperty("preferred_cache") &&
            entity.hasOwnProperty("preferred_network") &&
            entity.hasOwnProperty("canonical_authority") &&
            entity.hasOwnProperty("authorization_endpoint") &&
            entity.hasOwnProperty("token_endpoint") &&
            entity.hasOwnProperty("issuer") &&
            entity.hasOwnProperty("aliasesFromNetwork") &&
            entity.hasOwnProperty("endpointsFromNetwork") &&
            entity.hasOwnProperty("expiresAt") &&
            entity.hasOwnProperty("jwks_uri"));
    };
    return AuthorityMetadataEntity;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function isCloudInstanceDiscoveryResponse(response) {
    return (response.hasOwnProperty("tenant_discovery_endpoint") &&
        response.hasOwnProperty("metadata"));
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var RegionDiscovery = /** @class */ (function () {
    function RegionDiscovery(networkInterface) {
        this.networkInterface = networkInterface;
    }
    /**
     * Detect the region from the application's environment.
     *
     * @returns Promise<string | null>
     */
    RegionDiscovery.prototype.detectRegion = function (environmentRegion, regionDiscoveryMetadata, proxyUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        autodetectedRegionName = environmentRegion;
                        if (!!autodetectedRegionName) return [3 /*break*/, 8];
                        options = RegionDiscovery.IMDS_OPTIONS;
                        if (proxyUrl) {
                            options.proxyUrl = proxyUrl;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        return [4 /*yield*/, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];
                    case 2:
                        localIMDSVersionResponse = _a.sent();
                        if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                            autodetectedRegionName = localIMDSVersionResponse.body;
                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
                        }
                        if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.getCurrentVersion(options)];
                    case 3:
                        currentIMDSVersion = _a.sent();
                        if (!currentIMDSVersion) {
                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, this.getRegionFromIMDS(currentIMDSVersion, options)];
                    case 4:
                        currentIMDSVersionResponse = _a.sent();
                        if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                            autodetectedRegionName = currentIMDSVersionResponse.body;
                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
                        }
                        _a.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        _a.sent();
                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                        return [2 /*return*/, null];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
                        _a.label = 9;
                    case 9:
                        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION
                        if (!autodetectedRegionName) {
                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                        }
                        return [2 /*return*/, autodetectedRegionName || null];
                }
            });
        });
    };
    /**
     * Make the call to the IMDS endpoint
     *
     * @param imdsEndpointUrl
     * @returns Promise<NetworkResponse<string>>
     */
    RegionDiscovery.prototype.getRegionFromIMDS = function (version, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + version + "&format=text", options, Constants.IMDS_TIMEOUT)];
            });
        });
    };
    /**
     * Get the most recent version of the IMDS endpoint available
     *
     * @returns Promise<string | null>
     */
    RegionDiscovery.prototype.getCurrentVersion = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", options)];
                    case 1:
                        response = _a.sent();
                        // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.
                        if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
                            return [2 /*return*/, response.body["newest-versions"][0]];
                        }
                        return [2 /*return*/, null];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, null];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // Options for the IMDS endpoint request
    RegionDiscovery.IMDS_OPTIONS = {
        headers: {
            Metadata: "true",
        },
    };
    return RegionDiscovery;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the
 * endpoint. It will store the pertinent config data in this object for use during token calls.
 */
var Authority = /** @class */ (function () {
    function Authority(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscovery = new RegionDiscovery(networkInterface);
        this.regionDiscoveryMetadata = { region_used: undefined, region_source: undefined, region_outcome: undefined };
        this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;
    }
    Object.defineProperty(Authority.prototype, "authorityType", {
        // See above for AuthorityType
        get: function () {
            var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;
            if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {
                return exports.AuthorityType.Adfs;
            }
            return exports.AuthorityType.Default;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "protocolMode", {
        /**
         * ProtocolMode enum representing the way endpoints are constructed.
         */
        get: function () {
            return this.authorityOptions.protocolMode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "options", {
        /**
         * Returns authorityOptions which can be used to reinstantiate a new authority instance
         */
        get: function () {
            return this.authorityOptions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "canonicalAuthority", {
        /**
         * A URL that is the authority set by the developer
         */
        get: function () {
            return this._canonicalAuthority.urlString;
        },
        /**
         * Sets canonical authority.
         */
        set: function (url) {
            this._canonicalAuthority = new UrlString(url);
            this._canonicalAuthority.validateAsUri();
            this._canonicalAuthorityUrlComponents = null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "canonicalAuthorityUrlComponents", {
        /**
         * Get authority components.
         */
        get: function () {
            if (!this._canonicalAuthorityUrlComponents) {
                this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
            }
            return this._canonicalAuthorityUrlComponents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "hostnameAndPort", {
        /**
         * Get hostname and port i.e. login.microsoftonline.com
         */
        get: function () {
            return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "tenant", {
        /**
         * Get tenant for authority.
         */
        get: function () {
            return this.canonicalAuthorityUrlComponents.PathSegments[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "authorizationEndpoint", {
        /**
         * OAuth /authorize endpoint for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                var endpoint = this.replacePath(this.metadata.authorization_endpoint);
                return this.replaceTenant(endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "tokenEndpoint", {
        /**
         * OAuth /token endpoint for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                var endpoint = this.replacePath(this.metadata.token_endpoint);
                return this.replaceTenant(endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "deviceCodeEndpoint", {
        get: function () {
            if (this.discoveryComplete()) {
                var endpoint = this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
                return this.replaceTenant(endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "endSessionEndpoint", {
        /**
         * OAuth logout endpoint for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                // ROPC policies may not have end_session_endpoint set
                if (!this.metadata.end_session_endpoint) {
                    throw ClientAuthError.createLogoutNotSupportedError();
                }
                var endpoint = this.replacePath(this.metadata.end_session_endpoint);
                return this.replaceTenant(endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "selfSignedJwtAudience", {
        /**
         * OAuth issuer for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                var endpoint = this.replacePath(this.metadata.issuer);
                return this.replaceTenant(endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "jwksUri", {
        /**
         * Jwks_uri for token signing keys
         */
        get: function () {
            if (this.discoveryComplete()) {
                var endpoint = this.replacePath(this.metadata.jwks_uri);
                return this.replaceTenant(endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Replaces tenant in url path with current tenant. Defaults to common.
     * @param urlString
     */
    Authority.prototype.replaceTenant = function (urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
    };
    /**
     * Replaces path such as tenant or policy with the current tenant or policy.
     * @param urlString
     */
    Authority.prototype.replacePath = function (urlString) {
        var endpoint = urlString;
        var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach(function (currentPart, index) {
            var cachedPart = cachedAuthorityParts[index];
            if (currentPart !== cachedPart) {
                endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/");
            }
        });
        return endpoint;
    };
    Object.defineProperty(Authority.prototype, "defaultOpenIdConfigurationEndpoint", {
        /**
         * The default open id configuration endpoint for any canonical authority.
         */
        get: function () {
            if (this.authorityType === exports.AuthorityType.Adfs || this.protocolMode === exports.ProtocolMode.OIDC) {
                return this.canonicalAuthority + ".well-known/openid-configuration";
            }
            return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Boolean that returns whethr or not tenant discovery has been completed.
     */
    Authority.prototype.discoveryComplete = function () {
        return !!this.metadata;
    };
    /**
     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
     * and the /authorize, /token and logout endpoints.
     */
    Authority.prototype.resolveEndpointsAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
                        if (!metadataEntity) {
                            metadataEntity = new AuthorityMetadataEntity();
                            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
                        }
                        return [4 /*yield*/, this.updateCloudDiscoveryMetadata(metadataEntity)];
                    case 1:
                        cloudDiscoverySource = _a.sent();
                        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
                        return [4 /*yield*/, this.updateEndpointMetadata(metadataEntity)];
                    case 2:
                        endpointSource = _a.sent();
                        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
                            // Reset the expiration time unless both values came from a successful cache lookup
                            metadataEntity.resetExpiresAt();
                            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
                        }
                        cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
                        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
                        this.metadata = metadataEntity;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update AuthorityMetadataEntity with new endpoints and return where the information came from
     * @param metadataEntity
     */
    Authority.prototype.updateEndpointMetadata = function (metadataEntity) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var metadata, harcodedMetadata;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        metadata = this.getEndpointMetadataFromConfig();
                        if (metadata) {
                            metadataEntity.updateEndpointMetadata(metadata, false);
                            return [2 /*return*/, AuthorityMetadataSource.CONFIG];
                        }
                        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
                            // No need to update
                            return [2 /*return*/, AuthorityMetadataSource.CACHE];
                        }
                        harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
                        return [4 /*yield*/, this.getEndpointMetadataFromNetwork()];
                    case 1:
                        metadata = _c.sent();
                        if (!metadata) return [3 /*break*/, 4];
                        if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.updateMetadataWithRegionalInformation(metadata)];
                    case 2:
                        metadata = _c.sent();
                        _c.label = 3;
                    case 3:
                        metadataEntity.updateEndpointMetadata(metadata, true);
                        return [2 /*return*/, AuthorityMetadataSource.NETWORK];
                    case 4:
                        if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache)) return [3 /*break*/, 7];
                        if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.updateMetadataWithRegionalInformation(harcodedMetadata)];
                    case 5:
                        harcodedMetadata = _c.sent();
                        _c.label = 6;
                    case 6:
                        metadataEntity.updateEndpointMetadata(harcodedMetadata, false);
                        return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];
                    case 7: throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
                }
            });
        });
    };
    /**
     * Compares the number of url components after the domain to determine if the cached authority metadata can be used for the requested authority
     * Protects against same domain different authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
     * @param metadataEntity
     */
    Authority.prototype.isAuthoritySameType = function (metadataEntity) {
        var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
    };
    /**
     * Parse authorityMetadata config option
     */
    Authority.prototype.getEndpointMetadataFromConfig = function () {
        if (this.authorityOptions.authorityMetadata) {
            try {
                return JSON.parse(this.authorityOptions.authorityMetadata);
            }
            catch (e) {
                throw ClientConfigurationError.createInvalidAuthorityMetadataError();
            }
        }
        return null;
    };
    /**
     * Gets OAuth endpoints from the given OpenID configuration endpoint.
     *
     * @param hasHardcodedMetadata boolean
     */
    Authority.prototype.getEndpointMetadataFromNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            var options, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = {};
                        if (this.proxyUrl) {
                            options.proxyUrl = this.proxyUrl;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
                    case 2:
                        response = _a.sent();
                        return [2 /*return*/, isOpenIdConfigResponse(response.body) ? response.body : null];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, null];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get OAuth endpoints for common authorities.
     */
    Authority.prototype.getEndpointMetadataFromHardcodedValues = function () {
        if (this.canonicalAuthority in EndpointMetadata) {
            return EndpointMetadata[this.canonicalAuthority];
        }
        return null;
    };
    /**
     * Update the retrieved metadata with regional information.
     */
    Authority.prototype.updateMetadataWithRegionalInformation = function (metadata) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function () {
            var autodetectedRegionName, azureRegion;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0: return [4 /*yield*/, this.regionDiscovery.detectRegion((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];
                    case 1:
                        autodetectedRegionName = _f.sent();
                        azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG
                            ? autodetectedRegionName
                            : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;
                        if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
                            this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ?
                                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL :
                                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
                        }
                        else {
                            if (autodetectedRegionName) {
                                this.regionDiscoveryMetadata.region_outcome = (((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName) ?
                                    RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED :
                                    RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;
                            }
                            else {
                                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
                            }
                        }
                        if (azureRegion) {
                            this.regionDiscoveryMetadata.region_used = azureRegion;
                            return [2 /*return*/, Authority.replaceWithRegionalInformation(metadata, azureRegion)];
                        }
                        return [2 /*return*/, metadata];
                }
            });
        });
    };
    /**
     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache and returns where the information was retrived from
     * @param cachedMetadata
     * @param newMetadata
     */
    Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {
        return __awaiter(this, void 0, void 0, function () {
            var metadata, harcodedMetadata;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        metadata = this.getCloudDiscoveryMetadataFromConfig();
                        if (metadata) {
                            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
                            return [2 /*return*/, AuthorityMetadataSource.CONFIG];
                        }
                        // If The cached metadata came from config but that config was not passed to this instance, we must go to the network
                        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {
                            // No need to update
                            return [2 /*return*/, AuthorityMetadataSource.CACHE];
                        }
                        harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();
                        return [4 /*yield*/, this.getCloudDiscoveryMetadataFromNetwork()];
                    case 1:
                        metadata = _a.sent();
                        if (metadata) {
                            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
                            return [2 /*return*/, AuthorityMetadataSource.NETWORK];
                        }
                        if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {
                            metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);
                            return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];
                        }
                        else {
                            // Metadata could not be obtained from config, cache or network
                            throw ClientConfigurationError.createUntrustedAuthorityError();
                        }
                }
            });
        });
    };
    /**
     * Parse cloudDiscoveryMetadata config or check knownAuthorities
     */
    Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {
        // Check if network response was provided in config
        if (this.authorityOptions.cloudDiscoveryMetadata) {
            try {
                var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
                var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
                if (metadata) {
                    return metadata;
                }
            }
            catch (e) {
                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
            }
        }
        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities
        if (this.isInKnownAuthorities()) {
            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
    };
    /**
     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
     *
     * @param hasHardcodedMetadata boolean
     */
    Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            var instanceDiscoveryEndpoint, options, match, response, metadata;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        instanceDiscoveryEndpoint = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
                        options = {};
                        if (this.proxyUrl) {
                            options.proxyUrl = this.proxyUrl;
                        }
                        match = null;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
                    case 2:
                        response = _a.sent();
                        metadata = isCloudInstanceDiscoveryResponse(response.body)
                            ? response.body.metadata
                            : [];
                        if (metadata.length === 0) {
                            // If no metadata is returned, authority is untrusted
                            return [2 /*return*/, null];
                        }
                        match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
                        return [3 /*break*/, 4];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, null];
                    case 4:
                        if (!match) {
                            // Custom Domain scenario, host is trusted because Instance Discovery call succeeded
                            match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
                        }
                        return [2 /*return*/, match];
                }
            });
        });
    };
    /**
     * Get cloud discovery metadata for common authorities
     */
    Authority.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function () {
        if (this.canonicalAuthority in InstanceDiscoveryMetadata) {
            return InstanceDiscoveryMetadata[this.canonicalAuthority];
        }
        return null;
    };
    /**
     * Helper function to determine if this host is included in the knownAuthorities config option
     */
    Authority.prototype.isInKnownAuthorities = function () {
        var _this = this;
        var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {
            return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;
        });
        return matches.length > 0;
    };
    /**
     * helper function to populate the authority based on azureCloudOptions
     * @param authorityString
     * @param azureCloudOptions
     */
    Authority.generateAuthority = function (authorityString, azureCloudOptions) {
        var authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== exports.AzureCloudInstance.None) {
            var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
            authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/";
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
    };
    /**
     * Creates cloud discovery metadata object from a given host
     * @param host
     */
    Authority.createCloudDiscoveryMetadataFromHost = function (host) {
        return {
            preferred_network: host,
            preferred_cache: host,
            aliases: [host]
        };
    };
    /**
     * Searches instance discovery network response for the entry that contains the host in the aliases list
     * @param response
     * @param authority
     */
    Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {
        for (var i = 0; i < response.length; i++) {
            var metadata = response[i];
            if (metadata.aliases.indexOf(authority) > -1) {
                return metadata;
            }
        }
        return null;
    };
    /**
     * helper function to generate environment from authority object
     */
    Authority.prototype.getPreferredCache = function () {
        if (this.discoveryComplete()) {
            return this.metadata.preferred_cache;
        }
        else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
    };
    /**
     * Returns whether or not the provided host is an alias of this authority instance
     * @param host
     */
    Authority.prototype.isAlias = function (host) {
        return this.metadata.aliases.indexOf(host) > -1;
    };
    /**
     * Checks whether the provided host is that of a public cloud authority
     *
     * @param authority string
     * @returns bool
     */
    Authority.isPublicCloudAuthority = function (host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
    };
    /**
     * Rebuild the authority string with the region
     *
     * @param host string
     * @param region string
     */
    Authority.buildRegionalAuthorityString = function (host, region, queryString) {
        // Create and validate a Url string object with the initial authority string
        var authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        var authorityUrlParts = authorityUrlInstance.getUrlComponents();
        var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
            hostNameAndPort = region + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;
        }
        // Include the query string portion of the url
        var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), { HostNameAndPort: hostNameAndPort })).urlString;
        // Add the query string if a query string was provided
        if (queryString)
            return url + "?" + queryString;
        return url;
    };
    /**
     * Replace the endpoints in the metadata object with their regional equivalents.
     *
     * @param metadata OpenIdConfigResponse
     * @param azureRegion string
     */
    Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {
        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
        // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature
        metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, "allowestsrnonmsi=true");
        if (metadata.end_session_endpoint) {
            metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);
        }
        return metadata;
    };
    return Authority;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var AuthorityFactory = /** @class */ (function () {
    function AuthorityFactory() {
    }
    /**
     * Create an authority object of the correct type based on the url
     * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)
     *
     * Also performs endpoint discovery.
     *
     * @param authorityUri
     * @param networkClient
     * @param protocolMode
     */
    AuthorityFactory.createDiscoveredInstance = function (authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var acquireTokenAuthority, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        acquireTokenAuthority = AuthorityFactory.createInstance(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, acquireTokenAuthority.resolveEndpointsAsync()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, acquireTokenAuthority];
                    case 3:
                        e_1 = _a.sent();
                        throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create an authority object of the correct type based on the url
     * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)
     *
     * Does not perform endpoint discovery.
     *
     * @param authorityUrl
     * @param networkInterface
     * @param protocolMode
     */
    AuthorityFactory.createInstance = function (authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        // Throw error if authority url is empty
        if (StringUtils.isEmpty(authorityUrl)) {
            throw ClientConfigurationError.createUrlEmptyError();
        }
        return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl);
    };
    return AuthorityFactory;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ServerTelemetryEntity = /** @class */ (function () {
    function ServerTelemetryEntity() {
        this.failedRequests = [];
        this.errors = [];
        this.cacheHits = 0;
    }
    /**
     * validates if a given cache entry is "Telemetry", parses <key,value>
     * @param key
     * @param entity
     */
    ServerTelemetryEntity.isServerTelemetryEntity = function (key, entity) {
        var validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
        var validateEntity = true;
        if (entity) {
            validateEntity =
                entity.hasOwnProperty("failedRequests") &&
                    entity.hasOwnProperty("errors") &&
                    entity.hasOwnProperty("cacheHits");
        }
        return validateKey && validateEntity;
    };
    return ServerTelemetryEntity;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ThrottlingEntity = /** @class */ (function () {
    function ThrottlingEntity() {
    }
    /**
     * validates if a given cache entry is "Throttling", parses <key,value>
     * @param key
     * @param entity
     */
    ThrottlingEntity.isThrottlingEntity = function (key, entity) {
        var validateKey = false;
        if (key) {
            validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
        }
        var validateEntity = true;
        if (entity) {
            validateEntity = entity.hasOwnProperty("throttleTime");
        }
        return validateKey && validateEntity;
    };
    return ThrottlingEntity;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var StubbedNetworkModule = {
    sendGetRequestAsync: function () {
        var notImplErr = "Network interface - sendGetRequestAsync() has not been implemented for the Network interface.";
        return Promise.reject(AuthError.createUnexpectedError(notImplErr));
    },
    sendPostRequestAsync: function () {
        var notImplErr = "Network interface - sendPostRequestAsync() has not been implemented for the Network interface.";
        return Promise.reject(AuthError.createUnexpectedError(notImplErr));
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
 */
var JoseHeaderErrorMessage = {
    missingKidError: {
        code: "missing_kid_error",
        desc: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided."
    },
    missingAlgError: {
        code: "missing_alg_error",
        desc: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
    },
};
/**
 * Error thrown when there is an error in the client code running on the browser.
 */
var JoseHeaderError = /** @class */ (function (_super) {
    __extends(JoseHeaderError, _super);
    function JoseHeaderError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "JoseHeaderError";
        Object.setPrototypeOf(_this, JoseHeaderError.prototype);
        return _this;
    }
    /**
     * Creates an error thrown when keyId isn't set on JOSE header.
     */
    JoseHeaderError.createMissingKidError = function () {
        return new JoseHeaderError(JoseHeaderErrorMessage.missingKidError.code, JoseHeaderErrorMessage.missingKidError.desc);
    };
    /**
     * Creates an error thrown when algorithm isn't set on JOSE header.
     */
    JoseHeaderError.createMissingAlgError = function () {
        return new JoseHeaderError(JoseHeaderErrorMessage.missingAlgError.code, JoseHeaderErrorMessage.missingAlgError.desc);
    };
    return JoseHeaderError;
}(AuthError));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var JoseHeader = /** @class */ (function () {
    function JoseHeader(options) {
        this.typ = options.typ;
        this.alg = options.alg;
        this.kid = options.kid;
    }
    /**
     * Builds SignedHttpRequest formatted JOSE Header from the
     * JOSE Header options provided or previously set on the object and returns
     * the stringified header object.
     * Throws if keyId or algorithm aren't provided since they are required for Access Token Binding.
     * @param shrHeaderOptions
     * @returns
     */
    JoseHeader.getShrHeaderString = function (shrHeaderOptions) {
        // KeyID is required on the SHR header
        if (!shrHeaderOptions.kid) {
            throw JoseHeaderError.createMissingKidError();
        }
        // Alg is required on the SHR header
        if (!shrHeaderOptions.alg) {
            throw JoseHeaderError.createMissingAlgError();
        }
        var shrHeader = new JoseHeader({
            // Access Token PoP headers must have type JWT, but the type header can be overriden for special cases
            typ: shrHeaderOptions.typ || JsonTypes.Jwt,
            kid: shrHeaderOptions.kid,
            alg: shrHeaderOptions.alg
        });
        return JSON.stringify(shrHeader);
    };
    return JoseHeader;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This is a helper class that parses supported HTTP response authentication headers to extract and return
 * header challenge values that can be used outside the basic authorization flows.
 */
var AuthenticationHeaderParser = /** @class */ (function () {
    function AuthenticationHeaderParser(headers) {
        this.headers = headers;
    }
    /**
     * This method parses the SHR nonce value out of either the Authentication-Info or WWW-Authenticate authentication headers.
     * @returns
     */
    AuthenticationHeaderParser.prototype.getShrNonce = function () {
        // Attempt to parse nonce from Authentiacation-Info
        var authenticationInfo = this.headers[HeaderNames.AuthenticationInfo];
        if (authenticationInfo) {
            var authenticationInfoChallenges = this.parseChallenges(authenticationInfo);
            if (authenticationInfoChallenges.nextnonce) {
                return authenticationInfoChallenges.nextnonce;
            }
            throw ClientConfigurationError.createInvalidAuthenticationHeaderError(HeaderNames.AuthenticationInfo, "nextnonce challenge is missing.");
        }
        // Attempt to parse nonce from WWW-Authenticate
        var wwwAuthenticate = this.headers[HeaderNames.WWWAuthenticate];
        if (wwwAuthenticate) {
            var wwwAuthenticateChallenges = this.parseChallenges(wwwAuthenticate);
            if (wwwAuthenticateChallenges.nonce) {
                return wwwAuthenticateChallenges.nonce;
            }
            throw ClientConfigurationError.createInvalidAuthenticationHeaderError(HeaderNames.WWWAuthenticate, "nonce challenge is missing.");
        }
        // If neither header is present, throw missing headers error
        throw ClientConfigurationError.createMissingNonceAuthenticationHeadersError();
    };
    /**
     * Parses an HTTP header's challenge set into a key/value map.
     * @param header
     * @returns
     */
    AuthenticationHeaderParser.prototype.parseChallenges = function (header) {
        var schemeSeparator = header.indexOf(" ");
        var challenges = header.substr(schemeSeparator + 1).split(",");
        var challengeMap = {};
        challenges.forEach(function (challenge) {
            var _a = challenge.split("="), key = _a[0], value = _a[1];
            // Remove escaped quotation marks (', ") from challenge string to keep only the challenge value
            challengeMap[key] = unescape(value.replace(/['"]+/g, Constants.EMPTY_STRING));
        });
        return challengeMap;
    };
    return AuthenticationHeaderParser;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ServerTelemetryManager = /** @class */ (function () {
    function ServerTelemetryManager(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
    }
    /**
     * API to add MSER Telemetry to request
     */
    ServerTelemetryManager.prototype.generateCurrentRequestHeaderValue = function () {
        var request = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
        var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var regionDiscoveryFields = this.getRegionDiscoveryFields();
        var requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    };
    /**
     * API to add MSER Telemetry for the last failed request
     */
    ServerTelemetryManager.prototype.generateLastRequestHeaderValue = function () {
        var lastRequests = this.getLastRequests();
        var maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);
        var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errorCount = lastRequests.errors.length;
        // Indicate whether this header contains all data or partial data
        var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    };
    /**
     * API to cache token failures for MSER data capture
     * @param error
     */
    ServerTelemetryManager.prototype.cacheFailedRequest = function (error) {
        var lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
            // Remove a cached error to make room, first in first out
            lastRequests.failedRequests.shift(); // apiId
            lastRequests.failedRequests.shift(); // correlationId
            lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (!StringUtils.isEmpty(error.subError)) {
            lastRequests.errors.push(error.subError);
        }
        else if (!StringUtils.isEmpty(error.errorCode)) {
            lastRequests.errors.push(error.errorCode);
        }
        else if (!!error && error.toString()) {
            lastRequests.errors.push(error.toString());
        }
        else {
            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return;
    };
    /**
     * Update server telemetry cache entry by incrementing cache hit counter
     */
    ServerTelemetryManager.prototype.incrementCacheHits = function () {
        var lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return lastRequests.cacheHits;
    };
    /**
     * Get the server telemetry entity from cache or initialize a new one
     */
    ServerTelemetryManager.prototype.getLastRequests = function () {
        var initialValue = new ServerTelemetryEntity();
        var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
    };
    /**
     * Remove server telemetry cache entry
     */
    ServerTelemetryManager.prototype.clearTelemetryCache = function () {
        var lastRequests = this.getLastRequests();
        var numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);
        var errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
            // All errors were sent on last request, clear Telemetry cache
            this.cacheManager.removeItem(this.telemetryCacheKey);
        }
        else {
            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed
            var serverTelemEntity = new ServerTelemetryEntity();
            serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2); // failedRequests contains 2 items for each error
            serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
            this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
        }
    };
    /**
     * Returns the maximum number of errors that can be flushed to the server in the next network request
     * @param serverTelemetryEntity
     */
    ServerTelemetryManager.maxErrorsToSend = function (serverTelemetryEntity) {
        var i;
        var maxErrors = 0;
        var dataSize = 0;
        var errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs
            var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
            var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
            var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators
            dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
                // Adding this entry to the header would still keep header size below the limit
                maxErrors += 1;
            }
            else {
                break;
            }
        }
        return maxErrors;
    };
    /**
     * Get the region discovery fields
     *
     * @returns string
     */
    ServerTelemetryManager.prototype.getRegionDiscoveryFields = function () {
        var regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
    };
    /**
     * Update the region discovery metadata
     *
     * @param regionDiscoveryMetadata
     * @returns void
     */
    ServerTelemetryManager.prototype.updateRegionDiscoveryMetadata = function (regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
    };
    /**
     * Set cache outcome
     */
    ServerTelemetryManager.prototype.setCacheOutcome = function (cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
    };
    return ServerTelemetryManager;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var PerformanceClient = /** @class */ (function () {
    /**
     * Creates an instance of PerformanceClient,
     * an abstract class containing core performance telemetry logic.
     *
     * @constructor
     * @param {string} clientId Client ID of the application
     * @param {string} authority Authority used by the application
     * @param {Logger} logger Logger used by the application
     * @param {string} libraryName Name of the library
     * @param {string} libraryVersion Version of the library
     */
    function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {
        this.authority = authority;
        this.libraryName = libraryName;
        this.libraryVersion = libraryVersion;
        this.applicationTelemetry = applicationTelemetry;
        this.clientId = clientId;
        this.logger = logger;
        this.callbacks = new Map();
        this.eventsByCorrelationId = new Map();
        this.measurementsById = new Map();
    }
    /**
     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
     *
     * @param {PerformanceEvents} measureName
     * @param {?string} [correlationId]
     * @returns {InProgressPerformanceEvent}
     */
    PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {
        var _this = this;
        var _a, _b;
        // Generate a placeholder correlation if the request does not provide one
        var eventCorrelationId = correlationId || this.generateId();
        if (!correlationId) {
            this.logger.info("PerformanceClient: No correlation id provided for " + measureName + ", generating", eventCorrelationId);
        }
        this.logger.trace("PerformanceClient: Performance measurement started for " + measureName, eventCorrelationId);
        var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);
        performanceMeasurement.startMeasurement();
        var inProgressEvent = {
            eventId: this.generateId(),
            status: exports.PerformanceEventStatus.InProgress,
            authority: this.authority,
            libraryName: this.libraryName,
            libraryVersion: this.libraryVersion,
            appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,
            appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,
            clientId: this.clientId,
            name: measureName,
            startTimeMs: Date.now(),
            correlationId: eventCorrelationId,
        };
        // Store in progress events so they can be discarded if not ended properly
        this.cacheEventByCorrelationId(inProgressEvent);
        this.cacheMeasurement(inProgressEvent, performanceMeasurement);
        // Return the event and functions the caller can use to properly end/flush the measurement
        return {
            endMeasurement: function (event) {
                var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));
                if (completedEvent) {
                    // Cache event so that submeasurements can be added downstream
                    _this.cacheEventByCorrelationId(completedEvent);
                }
                return completedEvent;
            },
            flushMeasurement: function () {
                return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);
            },
            discardMeasurement: function () {
                return _this.discardMeasurements(inProgressEvent.correlationId);
            },
            measurement: performanceMeasurement,
            event: inProgressEvent
        };
    };
    /**
     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,
     * as consumers should instead use the function returned by startMeasurement.
     *
     * @param {PerformanceEvent} event
     * @returns {(PerformanceEvent | null)}
     */
    PerformanceClient.prototype.endMeasurement = function (event) {
        var performanceMeasurement = this.measurementsById.get(event.eventId);
        if (performanceMeasurement) {
            // Immediately delete so that the same event isnt ended twice
            this.measurementsById.delete(event.eventId);
            performanceMeasurement.endMeasurement();
            var durationMs = performanceMeasurement.flushMeasurement();
            // null indicates no measurement was taken (e.g. needed performance APIs not present)
            if (durationMs !== null) {
                this.logger.trace("PerformanceClient: Performance measurement ended for " + event.name + ": " + durationMs + " ms", event.correlationId);
                var completedEvent = __assign(__assign({ 
                    // Allow duration to be overwritten when event ends (e.g. testing), but not status
                    durationMs: Math.round(durationMs) }, event), { status: exports.PerformanceEventStatus.Completed });
                return completedEvent;
            }
            else {
                this.logger.trace("PerformanceClient: Performance measurement not taken", event.correlationId);
            }
        }
        else {
            this.logger.trace("PerformanceClient: Measurement not found for " + event.eventId, event.correlationId);
        }
        return null;
    };
    /**
     * Upserts event into event cache.
     * First key is the correlation id, second key is the event id.
     * Allows for events to be grouped by correlation id,
     * and to easily allow for properties on them to be updated.
     *
     * @private
     * @param {PerformanceEvent} event
     */
    PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {
        var existingEvents = this.eventsByCorrelationId.get(event.correlationId);
        if (existingEvents) {
            this.logger.trace("PerformanceClient: Performance measurement for " + event.name + " added/updated", event.correlationId);
            existingEvents.set(event.eventId, event);
        }
        else {
            this.logger.trace("PerformanceClient: Performance measurement for " + event.name + " started", event.correlationId);
            this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));
        }
    };
    /**
     * Cache measurements by their id.
     *
     * @private
     * @param {PerformanceEvent} event
     * @param {IPerformanceMeasurement} measurement
     */
    PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {
        this.measurementsById.set(event.eventId, measurement);
    };
    /**
     * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.
     *
     * @param {PerformanceEvents} measureName
     * @param {string} correlationId
     */
    PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {
        var _this = this;
        this.logger.trace("PerformanceClient: Performance measurements flushed for " + measureName, correlationId);
        var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);
        if (eventsForCorrelationId) {
            this.discardMeasurements(correlationId);
            /*
             * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.
             * Incomplete submeasurements are likely an instrumentation bug that should be fixed.
             * IE only supports Map.forEach.
             */
            var completedEvents_1 = [];
            eventsForCorrelationId.forEach(function (event) {
                if (event.name !== measureName && event.status !== exports.PerformanceEventStatus.Completed) {
                    _this.logger.trace("PerformanceClient: Incomplete submeasurement " + event.name + " found for " + measureName, correlationId);
                    var completedEvent = _this.endMeasurement(event);
                    if (completedEvent) {
                        completedEvents_1.push(completedEvent);
                    }
                }
                completedEvents_1.push(event);
            });
            // Sort events by start time (earliest first)
            var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) { return eventA.startTimeMs - eventB.startTimeMs; });
            // Take completed top level event and add completed submeasurements durations as properties
            var topLevelEvents = sortedCompletedEvents.filter(function (event) { return event.name === measureName && event.status === exports.PerformanceEventStatus.Completed; });
            if (topLevelEvents.length > 0) {
                /*
                 * Only take the first top-level event if there are multiple events with the same correlation id.
                 * This greatly simplifies logic for submeasurements.
                 */
                if (topLevelEvents.length > 1) {
                    this.logger.verbose("PerformanceClient: Multiple distinct top-level performance events found, using the first", correlationId);
                }
                var topLevelEvent = topLevelEvents[0];
                this.logger.verbose("PerformanceClient: Measurement found for " + measureName, correlationId);
                // Build event object with top level and sub measurements
                var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {
                    if (current.name !== measureName) {
                        _this.logger.trace("PerformanceClient: Complete submeasurement found for " + current.name, correlationId);
                        // TODO: Emit additional properties for each subMeasurement
                        var subMeasurementName = current.name + "DurationMs";
                        /*
                         * Some code paths, such as resolving an authority, can occur multiple times.
                         * Only take the first measurement, since the second could be read from the cache,
                         * or due to the same correlation id being used for two distinct requests.
                         */
                        if (!previous[subMeasurementName]) {
                            previous[subMeasurementName] = current.durationMs;
                        }
                        else {
                            _this.logger.verbose("PerformanceClient: Submeasurement for " + measureName + " already exists for " + current.name + ", ignoring", correlationId);
                        }
                        if (current.accessTokenSize) {
                            previous.accessTokenSize = current.accessTokenSize;
                        }
                        if (current.idTokenSize) {
                            previous.idTokenSize = current.idTokenSize;
                        }
                    }
                    return previous;
                }, topLevelEvent);
                this.emitEvents([eventToEmit], eventToEmit.correlationId);
            }
            else {
                this.logger.verbose("PerformanceClient: No completed top-level measurements found for " + measureName, correlationId);
            }
        }
        else {
            this.logger.verbose("PerformanceClient: No measurements found", correlationId);
        }
    };
    /**
     * Removes measurements for a given correlation id.
     *
     * @param {string} correlationId
     */
    PerformanceClient.prototype.discardMeasurements = function (correlationId) {
        this.logger.trace("PerformanceClient: Performance measurements discarded", correlationId);
        this.eventsByCorrelationId.delete(correlationId);
    };
    /**
     * Registers a callback function to receive performance events.
     *
     * @param {PerformanceCallbackFunction} callback
     * @returns {string}
     */
    PerformanceClient.prototype.addPerformanceCallback = function (callback) {
        var callbackId = this.generateId();
        this.callbacks.set(callbackId, callback);
        this.logger.verbose("PerformanceClient: Performance callback registered with id: " + callbackId);
        return callbackId;
    };
    /**
     * Removes a callback registered with addPerformanceCallback.
     *
     * @param {string} callbackId
     * @returns {boolean}
     */
    PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {
        var result = this.callbacks.delete(callbackId);
        if (result) {
            this.logger.verbose("PerformanceClient: Performance callback " + callbackId + " removed.");
        }
        else {
            this.logger.verbose("PerformanceClient: Performance callback " + callbackId + " not removed.");
        }
        return result;
    };
    /**
     * Emits events to all registered callbacks.
     *
     * @param {PerformanceEvent[]} events
     * @param {?string} [correlationId]
     */
    PerformanceClient.prototype.emitEvents = function (events, correlationId) {
        var _this = this;
        this.logger.verbose("PerformanceClient: Emitting performance events", correlationId);
        this.callbacks.forEach(function (callback, callbackId) {
            _this.logger.trace("PerformanceClient: Emitting event to callback " + callbackId, correlationId);
            callback.apply(null, [events]);
        });
    };
    return PerformanceClient;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var StubPerformanceMeasurement = /** @class */ (function () {
    function StubPerformanceMeasurement() {
    }
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    StubPerformanceMeasurement.prototype.startMeasurement = function () { };
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    StubPerformanceMeasurement.prototype.endMeasurement = function () { };
    StubPerformanceMeasurement.prototype.flushMeasurement = function () {
        return null;
    };
    return StubPerformanceMeasurement;
}());
var StubPerformanceClient = /** @class */ (function (_super) {
    __extends(StubPerformanceClient, _super);
    function StubPerformanceClient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StubPerformanceClient.prototype.generateId = function () {
        return "callback-id";
    };
    StubPerformanceClient.prototype.startPerformanceMeasuremeant = function () {
        return new StubPerformanceMeasurement();
    };
    return StubPerformanceClient;
}(PerformanceClient));

exports.AccessTokenEntity = AccessTokenEntity;
exports.AccountEntity = AccountEntity;
exports.AppMetadataEntity = AppMetadataEntity;
exports.AuthError = AuthError;
exports.AuthErrorMessage = AuthErrorMessage;
exports.AuthToken = AuthToken;
exports.AuthenticationHeaderParser = AuthenticationHeaderParser;
exports.Authority = Authority;
exports.AuthorityFactory = AuthorityFactory;
exports.AuthorityMetadataEntity = AuthorityMetadataEntity;
exports.AuthorizationCodeClient = AuthorizationCodeClient;
exports.CacheManager = CacheManager;
exports.ClientAuthError = ClientAuthError;
exports.ClientAuthErrorMessage = ClientAuthErrorMessage;
exports.ClientConfigurationError = ClientConfigurationError;
exports.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
exports.ClientCredentialClient = ClientCredentialClient;
exports.CodeChallengeMethodValues = CodeChallengeMethodValues;
exports.Constants = Constants;
exports.CredentialEntity = CredentialEntity;
exports.DEFAULT_CRYPTO_IMPLEMENTATION = DEFAULT_CRYPTO_IMPLEMENTATION;
exports.DEFAULT_SYSTEM_OPTIONS = DEFAULT_SYSTEM_OPTIONS;
exports.DefaultStorageClass = DefaultStorageClass;
exports.DeviceCodeClient = DeviceCodeClient;
exports.IdToken = AuthToken;
exports.IdTokenEntity = IdTokenEntity;
exports.InteractionRequiredAuthError = InteractionRequiredAuthError;
exports.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
exports.JoseHeader = JoseHeader;
exports.Logger = Logger;
exports.NetworkManager = NetworkManager;
exports.OIDC_DEFAULT_SCOPES = OIDC_DEFAULT_SCOPES;
exports.OnBehalfOfClient = OnBehalfOfClient;
exports.PerformanceClient = PerformanceClient;
exports.PopTokenGenerator = PopTokenGenerator;
exports.PromptValue = PromptValue;
exports.ProtocolUtils = ProtocolUtils;
exports.RefreshTokenClient = RefreshTokenClient;
exports.RefreshTokenEntity = RefreshTokenEntity;
exports.ScopeSet = ScopeSet;
exports.ServerError = ServerError;
exports.ServerTelemetryEntity = ServerTelemetryEntity;
exports.ServerTelemetryManager = ServerTelemetryManager;
exports.SilentFlowClient = SilentFlowClient;
exports.StringUtils = StringUtils;
exports.StubPerformanceClient = StubPerformanceClient;
exports.StubbedNetworkModule = StubbedNetworkModule;
exports.ThrottlingEntity = ThrottlingEntity;
exports.ThrottlingUtils = ThrottlingUtils;
exports.TimeUtils = TimeUtils;
exports.TokenCacheContext = TokenCacheContext;
exports.UrlString = UrlString;
exports.UsernamePasswordClient = UsernamePasswordClient;
exports.buildClientInfo = buildClientInfo;
exports.buildClientInfoFromHomeAccountId = buildClientInfoFromHomeAccountId;
exports.version = version;
//# sourceMappingURL=index.cjs.js.map


/***/ }),

/***/ 9941:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";



if (process.env.NODE_ENV === 'production') {
  module.exports = __nccwpck_require__(4)
} else {
  module.exports = __nccwpck_require__(3695)
}


/***/ }),

/***/ 3695:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var msalCommon = __nccwpck_require__(6849);
var http = __nccwpck_require__(3685);
var http__default = _interopDefault(http);
var https = _interopDefault(__nccwpck_require__(5687));
var uuid = __nccwpck_require__(5650);
var crypto = _interopDefault(__nccwpck_require__(6113));
var jsonwebtoken = __nccwpck_require__(3610);

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * http methods
 */
var HttpMethod;

(function (HttpMethod) {
  HttpMethod["GET"] = "get";
  HttpMethod["POST"] = "post";
})(HttpMethod || (HttpMethod = {}));

var HttpStatus;

(function (HttpStatus) {
  HttpStatus[HttpStatus["OK"] = 200] = "OK";
  HttpStatus[HttpStatus["REDIRECT"] = 302] = "REDIRECT";
})(HttpStatus || (HttpStatus = {}));
/**
 * Constants used for region discovery
 */


const REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
/**
 * Constant used for PKCE
 */

const RANDOM_OCTET_SIZE = 32;
/**
 * Constants used in PKCE
 */

const Hash = {
  SHA256: "sha256"
};
/**
 * Constants for encoding schemes
 */

const CharSet = {
  CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
};
/**
 * Constants
 */

const Constants = {
  MSAL_SKU: "msal.js.node",
  JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
  AUTHORIZATION_PENDING: "authorization_pending",
  HTTP_PROTOCOL: "http://",
  LOCALHOST: "localhost"
};
/**
 * API Codes for Telemetry purposes.
 * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs
 * 0-99 Silent Flow
 * 600-699 Device Code Flow
 * 800-899 Auth Code Flow
 */

var ApiId;

(function (ApiId) {
  ApiId[ApiId["acquireTokenSilent"] = 62] = "acquireTokenSilent";
  ApiId[ApiId["acquireTokenByUsernamePassword"] = 371] = "acquireTokenByUsernamePassword";
  ApiId[ApiId["acquireTokenByDeviceCode"] = 671] = "acquireTokenByDeviceCode";
  ApiId[ApiId["acquireTokenByClientCredential"] = 771] = "acquireTokenByClientCredential";
  ApiId[ApiId["acquireTokenByCode"] = 871] = "acquireTokenByCode";
  ApiId[ApiId["acquireTokenByRefreshToken"] = 872] = "acquireTokenByRefreshToken";
})(ApiId || (ApiId = {}));
/**
 * JWT  constants
 */


const JwtConstants = {
  ALGORITHM: "alg",
  RSA_256: "RS256",
  X5T: "x5t",
  X5C: "x5c",
  AUDIENCE: "aud",
  EXPIRATION_TIME: "exp",
  ISSUER: "iss",
  SUBJECT: "sub",
  NOT_BEFORE: "nbf",
  JWT_ID: "jti"
};
const LOOPBACK_SERVER_CONSTANTS = {
  INTERVAL_MS: 100,
  TIMEOUT_MS: 5000
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class implements the API for network requests.
 */

class HttpClient {
  /**
   * Http Get request
   * @param url
   * @param options
   */
  async sendGetRequestAsync(url, options) {
    if (options != null && options.proxyUrl) {
      return networkRequestViaProxy(url, HttpMethod.GET, options);
    } else {
      return networkRequestViaHttps(url, HttpMethod.GET, options);
    }
  }
  /**
   * Http Post request
   * @param url
   * @param options
   */


  async sendPostRequestAsync(url, options, cancellationToken) {
    if (options != null && options.proxyUrl) {
      return networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken);
    } else {
      return networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken);
    }
  }

}

const networkRequestViaProxy = (url, httpMethod, options, timeout) => {
  const headers = (options == null ? void 0 : options.headers) || {};
  const proxyUrl = new URL((options == null ? void 0 : options.proxyUrl) || "");
  const destinationUrl = new URL(url); // "method: connect" must be used to establish a connection to the proxy

  const tunnelRequestOptions = {
    host: proxyUrl.hostname,
    port: proxyUrl.port,
    method: "CONNECT",
    path: destinationUrl.hostname,
    headers: headers
  };

  if (timeout) {
    tunnelRequestOptions.timeout = timeout;
  } // compose a request string for the socket


  let postRequestStringContent = "";

  if (httpMethod === HttpMethod.POST) {
    const body = (options == null ? void 0 : options.body) || "";
    postRequestStringContent = "Content-Type: application/x-www-form-urlencoded\r\n" + `Content-Length: ${body.length}\r\n` + `\r\n${body}`;
  }

  const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r\n` + `Host: ${destinationUrl.host}\r\n` + "Connection: close\r\n" + postRequestStringContent + "\r\n";
  return new Promise((resolve, reject) => {
    const request = http__default.request(tunnelRequestOptions);

    if (tunnelRequestOptions.timeout) {
      request.on("timeout", () => {
        request.destroy();
        reject(new Error("Request time out"));
      });
    }

    request.end(); // establish connection to the proxy

    request.on("connect", (response, socket) => {
      const statusCode = (response == null ? void 0 : response.statusCode) || 500;

      if (statusCode < 200 || statusCode > 299) {
        request.destroy();
        socket.destroy();
        reject(new Error(`HTTP status code ${statusCode}`));
      }

      if (tunnelRequestOptions.timeout) {
        socket.setTimeout(tunnelRequestOptions.timeout);
        socket.on("timeout", () => {
          request.destroy();
          socket.destroy();
          reject(new Error("Request time out"));
        });
      } // make a request over an HTTP tunnel


      socket.write(outgoingRequestString);
      const data = [];
      socket.on("data", chunk => {
        data.push(chunk);
      });
      socket.on("end", () => {
        // combine all received buffer streams into one buffer, and then into a string
        const dataString = Buffer.concat([...data]).toString(); // separate each line into it's own entry in an arry

        const dataStringArray = dataString.split("\r\n"); // the first entry will contain the statusCode

        const statusCode = parseInt(dataStringArray[0].split(" ")[1]); // the last entry will contain the body

        const body = dataStringArray[dataStringArray.length - 1]; // everything in between the first and last entries are the headers

        const headersArray = dataStringArray.slice(1, dataStringArray.length - 2); // build an object out of all the headers

        const entries = new Map();
        headersArray.forEach(header => {
          /**
           * the header might look like "Content-Length: 1531", but that is just a string
           * it needs to be converted to a key/value pair
           * split the string at the first instance of ":"
           * there may be more than one ":" if the value of the header is supposed to be a JSON object
           */
          const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
          const headerKey = headerKeyValue[0];
          let headerValue = headerKeyValue[1]; // check if the value of the header is supposed to be a JSON object

          try {
            const object = JSON.parse(headerValue); // if it is, then convert it from a string to a JSON object

            if (object && typeof object === "object") {
              headerValue = object;
            }
          } catch (e) {// otherwise, leave it as a string
          }

          entries.set(headerKey, headerValue);
        });
        const headers = Object.fromEntries(entries);
        const networkResponse = {
          headers: headers,
          body: JSON.parse(body),
          status: statusCode
        };

        if ((statusCode < 200 || statusCode > 299) && // do not destroy the request for the device code flow
        networkResponse.body["error"] !== Constants.AUTHORIZATION_PENDING) {
          request.destroy();
          socket.destroy();
          reject(new Error(`HTTP status code ${statusCode}`));
        }

        resolve(networkResponse);
      });
      socket.on("error", chunk => {
        request.destroy();
        socket.destroy();
        reject(new Error(chunk.toString()));
      });
    });
    request.on("error", chunk => {
      request.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};

const networkRequestViaHttps = (url, httpMethod, options, timeout) => {
  const isPostRequest = httpMethod === HttpMethod.POST;
  const body = (options == null ? void 0 : options.body) || "";
  const emptyHeaders = {};
  const customOptions = {
    method: httpMethod,
    headers: (options == null ? void 0 : options.headers) || emptyHeaders
  };

  if (timeout) {
    customOptions.timeout = timeout;
  }

  if (isPostRequest) {
    // needed for post request to work
    customOptions.headers = { ...customOptions.headers,
      "Content-Length": body.length
    };
  }

  return new Promise((resolve, reject) => {
    const request = https.request(url, customOptions);

    if (timeout) {
      request.on("timeout", () => {
        request.destroy();
        reject(new Error("Request time out"));
      });
    }

    if (isPostRequest) {
      request.write(body);
    }

    request.end();
    request.on("response", response => {
      const headers = response.headers;
      const statusCode = response.statusCode;
      const data = [];
      response.on("data", chunk => {
        data.push(chunk);
      });
      response.on("end", () => {
        // combine all received buffer streams into one buffer, and then into a string
        const body = Buffer.concat([...data]).toString();
        const networkResponse = {
          headers: headers,
          body: JSON.parse(body),
          status: statusCode
        };

        if ((statusCode < 200 || statusCode > 299) && // do not destroy the request for the device code flow
        networkResponse.body["error"] !== Constants.AUTHORIZATION_PENDING) {
          request.destroy();
          reject(new Error(`HTTP status code ${statusCode}`));
        }

        resolve(networkResponse);
      });
    });
    request.on("error", chunk => {
      request.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class NetworkUtils {
  /**
   * Returns best compatible network client object.
   */
  static getNetworkClient() {
    return new HttpClient();
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const DEFAULT_AUTH_OPTIONS = {
  clientId: msalCommon.Constants.EMPTY_STRING,
  authority: msalCommon.Constants.DEFAULT_AUTHORITY,
  clientSecret: msalCommon.Constants.EMPTY_STRING,
  clientAssertion: msalCommon.Constants.EMPTY_STRING,
  clientCertificate: {
    thumbprint: msalCommon.Constants.EMPTY_STRING,
    privateKey: msalCommon.Constants.EMPTY_STRING,
    x5c: msalCommon.Constants.EMPTY_STRING
  },
  knownAuthorities: [],
  cloudDiscoveryMetadata: msalCommon.Constants.EMPTY_STRING,
  authorityMetadata: msalCommon.Constants.EMPTY_STRING,
  clientCapabilities: [],
  protocolMode: msalCommon.ProtocolMode.AAD,
  azureCloudOptions: {
    azureCloudInstance: msalCommon.AzureCloudInstance.None,
    tenant: msalCommon.Constants.EMPTY_STRING
  },
  skipAuthorityMetadataCache: false
};
const DEFAULT_CACHE_OPTIONS = {};
const DEFAULT_LOGGER_OPTIONS = {
  loggerCallback: () => {// allow users to not set logger call back
  },
  piiLoggingEnabled: false,
  logLevel: msalCommon.LogLevel.Info
};
const DEFAULT_SYSTEM_OPTIONS = {
  loggerOptions: DEFAULT_LOGGER_OPTIONS,
  networkClient: /*#__PURE__*/NetworkUtils.getNetworkClient(),
  proxyUrl: msalCommon.Constants.EMPTY_STRING
};
const DEFAULT_TELEMETRY_OPTIONS = {
  application: {
    appName: msalCommon.Constants.EMPTY_STRING,
    appVersion: msalCommon.Constants.EMPTY_STRING
  }
};
/**
 * Sets the default options when not explicitly configured from app developer
 *
 * @param auth - Authentication options
 * @param cache - Cache options
 * @param system - System options
 * @param telemetry - Telemetry options
 *
 * @returns Configuration
 * @public
 */

function buildAppConfiguration({
  auth,
  cache,
  system,
  telemetry
}) {
  return {
    auth: { ...DEFAULT_AUTH_OPTIONS,
      ...auth
    },
    cache: { ...DEFAULT_CACHE_OPTIONS,
      ...cache
    },
    system: { ...DEFAULT_SYSTEM_OPTIONS,
      ...system
    },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS,
      ...telemetry
    }
  };
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class GuidGenerator {
  /**
   *
   * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
   * uuidv4 generates guids from cryprtographically-string random
   */
  generateGuid() {
    return uuid.v4();
  }
  /**
   * verifies if a string is  GUID
   * @param guid
   */


  isGuid(guid) {
    const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return regexGuid.test(guid);
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class EncodingUtils {
  /**
   * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
   * 'base64': Base64 encoding.
   *
   * @param str text
   */
  static base64Encode(str, encoding) {
    return Buffer.from(str, encoding).toString("base64");
  }
  /**
   * encode a URL
   * @param str
   */


  static base64EncodeUrl(str, encoding) {
    return EncodingUtils.base64Encode(str, encoding).replace(/=/g, msalCommon.Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
  }
  /**
   * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
   * 'base64': Base64 encoding.
   *
   * @param base64Str Base64 encoded text
   */


  static base64Decode(base64Str) {
    return Buffer.from(base64Str, "base64").toString("utf8");
  }
  /**
   * @param base64Str Base64 encoded Url
   */


  static base64DecodeUrl(base64Str) {
    let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");

    while (str.length % 4) {
      str += "=";
    }

    return EncodingUtils.base64Decode(str);
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class HashUtils {
  /**
   * generate 'SHA256' hash
   * @param buffer
   */
  sha256(buffer) {
    return crypto.createHash(Hash.SHA256).update(buffer).digest();
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * https://tools.ietf.org/html/rfc7636#page-8
 */

class PkceGenerator {
  constructor() {
    this.hashUtils = new HashUtils();
  }
  /**
   * generates the codeVerfier and the challenge from the codeVerfier
   * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
   */


  async generatePkceCodes() {
    const verifier = this.generateCodeVerifier();
    const challenge = this.generateCodeChallengeFromVerifier(verifier);
    return {
      verifier,
      challenge
    };
  }
  /**
   * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
   */


  generateCodeVerifier() {
    const charArr = [];
    const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;

    while (charArr.length <= RANDOM_OCTET_SIZE) {
      const byte = crypto.randomBytes(1)[0];

      if (byte >= maxNumber) {
        /*
         * Ignore this number to maintain randomness.
         * Including it would result in an unequal distribution of characters after doing the modulo
         */
        continue;
      }

      const index = byte % CharSet.CV_CHARSET.length;
      charArr.push(CharSet.CV_CHARSET[index]);
    }

    const verifier = charArr.join(msalCommon.Constants.EMPTY_STRING);
    return EncodingUtils.base64EncodeUrl(verifier);
  }
  /**
   * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
   * @param codeVerifier
   */


  generateCodeChallengeFromVerifier(codeVerifier) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and
 * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).
 * @public
 */

class CryptoProvider {
  constructor() {
    // Browser crypto needs to be validated first before any other classes can be set.
    this.pkceGenerator = new PkceGenerator();
    this.guidGenerator = new GuidGenerator();
    this.hashUtils = new HashUtils();
  }
  /**
   * Creates a new random GUID - used to populate state and nonce.
   * @returns string (GUID)
   */


  createNewGuid() {
    return this.guidGenerator.generateGuid();
  }
  /**
   * Encodes input string to base64.
   * @param input - string to be encoded
   */


  base64Encode(input) {
    return EncodingUtils.base64Encode(input);
  }
  /**
   * Decodes input string from base64.
   * @param input - string to be decoded
   */


  base64Decode(input) {
    return EncodingUtils.base64Decode(input);
  }
  /**
   * Generates PKCE codes used in Authorization Code Flow.
   */


  generatePkceCodes() {
    return this.pkceGenerator.generatePkceCodes();
  }
  /**
   * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
   */


  getPublicKeyThumbprint() {
    throw new Error("Method not implemented.");
  }
  /**
   * Removes cryptographic keypair from key store matching the keyId passed in
   * @param kid
   */


  removeTokenBindingKey() {
    throw new Error("Method not implemented.");
  }
  /**
   * Removes all cryptographic keys from Keystore
   */


  clearKeystore() {
    throw new Error("Method not implemented.");
  }
  /**
   * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
   */


  signJwt() {
    throw new Error("Method not implemented.");
  }
  /**
   * Returns the SHA-256 hash of an input string
   */


  async hashString(plainText) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class deserializes cache entities read from the file into in memory object types defined internally
 */

class Deserializer {
  /**
   * Parse the JSON blob in memory and deserialize the content
   * @param cachedJson
   */
  static deserializeJSONBlob(jsonFile) {
    const deserializedCache = msalCommon.StringUtils.isEmpty(jsonFile) ? {} : JSON.parse(jsonFile);
    return deserializedCache;
  }
  /**
   * Deserializes accounts to AccountEntity objects
   * @param accounts
   */


  static deserializeAccounts(accounts) {
    const accountObjects = {};

    if (accounts) {
      Object.keys(accounts).map(function (key) {
        const serializedAcc = accounts[key];
        const mappedAcc = {
          homeAccountId: serializedAcc.home_account_id,
          environment: serializedAcc.environment,
          realm: serializedAcc.realm,
          localAccountId: serializedAcc.local_account_id,
          username: serializedAcc.username,
          authorityType: serializedAcc.authority_type,
          name: serializedAcc.name,
          clientInfo: serializedAcc.client_info,
          lastModificationTime: serializedAcc.last_modification_time,
          lastModificationApp: serializedAcc.last_modification_app
        };
        const account = new msalCommon.AccountEntity();
        msalCommon.CacheManager.toObject(account, mappedAcc);
        accountObjects[key] = account;
      });
    }

    return accountObjects;
  }
  /**
   * Deserializes id tokens to IdTokenEntity objects
   * @param idTokens
   */


  static deserializeIdTokens(idTokens) {
    const idObjects = {};

    if (idTokens) {
      Object.keys(idTokens).map(function (key) {
        const serializedIdT = idTokens[key];
        const mappedIdT = {
          homeAccountId: serializedIdT.home_account_id,
          environment: serializedIdT.environment,
          credentialType: serializedIdT.credential_type,
          clientId: serializedIdT.client_id,
          secret: serializedIdT.secret,
          realm: serializedIdT.realm
        };
        const idToken = new msalCommon.IdTokenEntity();
        msalCommon.CacheManager.toObject(idToken, mappedIdT);
        idObjects[key] = idToken;
      });
    }

    return idObjects;
  }
  /**
   * Deserializes access tokens to AccessTokenEntity objects
   * @param accessTokens
   */


  static deserializeAccessTokens(accessTokens) {
    const atObjects = {};

    if (accessTokens) {
      Object.keys(accessTokens).map(function (key) {
        const serializedAT = accessTokens[key];
        const mappedAT = {
          homeAccountId: serializedAT.home_account_id,
          environment: serializedAT.environment,
          credentialType: serializedAT.credential_type,
          clientId: serializedAT.client_id,
          secret: serializedAT.secret,
          realm: serializedAT.realm,
          target: serializedAT.target,
          cachedAt: serializedAT.cached_at,
          expiresOn: serializedAT.expires_on,
          extendedExpiresOn: serializedAT.extended_expires_on,
          refreshOn: serializedAT.refresh_on,
          keyId: serializedAT.key_id,
          tokenType: serializedAT.token_type,
          requestedClaims: serializedAT.requestedClaims,
          requestedClaimsHash: serializedAT.requestedClaimsHash
        };
        const accessToken = new msalCommon.AccessTokenEntity();
        msalCommon.CacheManager.toObject(accessToken, mappedAT);
        atObjects[key] = accessToken;
      });
    }

    return atObjects;
  }
  /**
   * Deserializes refresh tokens to RefreshTokenEntity objects
   * @param refreshTokens
   */


  static deserializeRefreshTokens(refreshTokens) {
    const rtObjects = {};

    if (refreshTokens) {
      Object.keys(refreshTokens).map(function (key) {
        const serializedRT = refreshTokens[key];
        const mappedRT = {
          homeAccountId: serializedRT.home_account_id,
          environment: serializedRT.environment,
          credentialType: serializedRT.credential_type,
          clientId: serializedRT.client_id,
          secret: serializedRT.secret,
          familyId: serializedRT.family_id,
          target: serializedRT.target,
          realm: serializedRT.realm
        };
        const refreshToken = new msalCommon.RefreshTokenEntity();
        msalCommon.CacheManager.toObject(refreshToken, mappedRT);
        rtObjects[key] = refreshToken;
      });
    }

    return rtObjects;
  }
  /**
   * Deserializes appMetadata to AppMetaData objects
   * @param appMetadata
   */


  static deserializeAppMetadata(appMetadata) {
    const appMetadataObjects = {};

    if (appMetadata) {
      Object.keys(appMetadata).map(function (key) {
        const serializedAmdt = appMetadata[key];
        const mappedAmd = {
          clientId: serializedAmdt.client_id,
          environment: serializedAmdt.environment,
          familyId: serializedAmdt.family_id
        };
        const amd = new msalCommon.AppMetadataEntity();
        msalCommon.CacheManager.toObject(amd, mappedAmd);
        appMetadataObjects[key] = amd;
      });
    }

    return appMetadataObjects;
  }
  /**
   * Deserialize an inMemory Cache
   * @param jsonCache
   */


  static deserializeAllCache(jsonCache) {
    return {
      accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
      idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
      accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
      refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
      appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
    };
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class Serializer {
  /**
   * serialize the JSON blob
   * @param data
   */
  static serializeJSONBlob(data) {
    return JSON.stringify(data);
  }
  /**
   * Serialize Accounts
   * @param accCache
   */


  static serializeAccounts(accCache) {
    const accounts = {};
    Object.keys(accCache).map(function (key) {
      const accountEntity = accCache[key];
      accounts[key] = {
        home_account_id: accountEntity.homeAccountId,
        environment: accountEntity.environment,
        realm: accountEntity.realm,
        local_account_id: accountEntity.localAccountId,
        username: accountEntity.username,
        authority_type: accountEntity.authorityType,
        name: accountEntity.name,
        client_info: accountEntity.clientInfo,
        last_modification_time: accountEntity.lastModificationTime,
        last_modification_app: accountEntity.lastModificationApp
      };
    });
    return accounts;
  }
  /**
   * Serialize IdTokens
   * @param idTCache
   */


  static serializeIdTokens(idTCache) {
    const idTokens = {};
    Object.keys(idTCache).map(function (key) {
      const idTEntity = idTCache[key];
      idTokens[key] = {
        home_account_id: idTEntity.homeAccountId,
        environment: idTEntity.environment,
        credential_type: idTEntity.credentialType,
        client_id: idTEntity.clientId,
        secret: idTEntity.secret,
        realm: idTEntity.realm
      };
    });
    return idTokens;
  }
  /**
   * Serializes AccessTokens
   * @param atCache
   */


  static serializeAccessTokens(atCache) {
    const accessTokens = {};
    Object.keys(atCache).map(function (key) {
      const atEntity = atCache[key];
      accessTokens[key] = {
        home_account_id: atEntity.homeAccountId,
        environment: atEntity.environment,
        credential_type: atEntity.credentialType,
        client_id: atEntity.clientId,
        secret: atEntity.secret,
        realm: atEntity.realm,
        target: atEntity.target,
        cached_at: atEntity.cachedAt,
        expires_on: atEntity.expiresOn,
        extended_expires_on: atEntity.extendedExpiresOn,
        refresh_on: atEntity.refreshOn,
        key_id: atEntity.keyId,
        token_type: atEntity.tokenType,
        requestedClaims: atEntity.requestedClaims,
        requestedClaimsHash: atEntity.requestedClaimsHash
      };
    });
    return accessTokens;
  }
  /**
   * Serialize refreshTokens
   * @param rtCache
   */


  static serializeRefreshTokens(rtCache) {
    const refreshTokens = {};
    Object.keys(rtCache).map(function (key) {
      const rtEntity = rtCache[key];
      refreshTokens[key] = {
        home_account_id: rtEntity.homeAccountId,
        environment: rtEntity.environment,
        credential_type: rtEntity.credentialType,
        client_id: rtEntity.clientId,
        secret: rtEntity.secret,
        family_id: rtEntity.familyId,
        target: rtEntity.target,
        realm: rtEntity.realm
      };
    });
    return refreshTokens;
  }
  /**
   * Serialize amdtCache
   * @param amdtCache
   */


  static serializeAppMetadata(amdtCache) {
    const appMetadata = {};
    Object.keys(amdtCache).map(function (key) {
      const amdtEntity = amdtCache[key];
      appMetadata[key] = {
        client_id: amdtEntity.clientId,
        environment: amdtEntity.environment,
        family_id: amdtEntity.familyId
      };
    });
    return appMetadata;
  }
  /**
   * Serialize the cache
   * @param jsonContent
   */


  static serializeAllCache(inMemCache) {
    return {
      Account: this.serializeAccounts(inMemCache.accounts),
      IdToken: this.serializeIdTokens(inMemCache.idTokens),
      AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
      RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
      AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
    };
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class implements Storage for node, reading cache from user specified storage location or an  extension library
 * @public
 */

class NodeStorage extends msalCommon.CacheManager {
  constructor(logger, clientId, cryptoImpl) {
    super(clientId, cryptoImpl);
    this.cache = {};
    this.changeEmitters = [];
    this.logger = logger;
  }
  /**
   * Queue up callbacks
   * @param func - a callback function for cache change indication
   */


  registerChangeEmitter(func) {
    this.changeEmitters.push(func);
  }
  /**
   * Invoke the callback when cache changes
   */


  emitChange() {
    this.changeEmitters.forEach(func => func.call(null));
  }
  /**
   * Converts cacheKVStore to InMemoryCache
   * @param cache - key value store
   */


  cacheToInMemoryCache(cache) {
    const inMemoryCache = {
      accounts: {},
      idTokens: {},
      accessTokens: {},
      refreshTokens: {},
      appMetadata: {}
    };

    for (const key in cache) {
      if (cache[key] instanceof msalCommon.AccountEntity) {
        inMemoryCache.accounts[key] = cache[key];
      } else if (cache[key] instanceof msalCommon.IdTokenEntity) {
        inMemoryCache.idTokens[key] = cache[key];
      } else if (cache[key] instanceof msalCommon.AccessTokenEntity) {
        inMemoryCache.accessTokens[key] = cache[key];
      } else if (cache[key] instanceof msalCommon.RefreshTokenEntity) {
        inMemoryCache.refreshTokens[key] = cache[key];
      } else if (cache[key] instanceof msalCommon.AppMetadataEntity) {
        inMemoryCache.appMetadata[key] = cache[key];
      } else {
        continue;
      }
    }

    return inMemoryCache;
  }
  /**
   * converts inMemoryCache to CacheKVStore
   * @param inMemoryCache - kvstore map for inmemory
   */


  inMemoryCacheToCache(inMemoryCache) {
    // convert in memory cache to a flat Key-Value map
    let cache = this.getCache();
    cache = { ...cache,
      ...inMemoryCache.accounts,
      ...inMemoryCache.idTokens,
      ...inMemoryCache.accessTokens,
      ...inMemoryCache.refreshTokens,
      ...inMemoryCache.appMetadata
    }; // convert in memory cache to a flat Key-Value map

    return cache;
  }
  /**
   * gets the current in memory cache for the client
   */


  getInMemoryCache() {
    this.logger.trace("Getting in-memory cache"); // convert the cache key value store to inMemoryCache

    const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
    return inMemoryCache;
  }
  /**
   * sets the current in memory cache for the client
   * @param inMemoryCache - key value map in memory
   */


  setInMemoryCache(inMemoryCache) {
    this.logger.trace("Setting in-memory cache"); // convert and append the inMemoryCache to cacheKVStore

    const cache = this.inMemoryCacheToCache(inMemoryCache);
    this.setCache(cache);
    this.emitChange();
  }
  /**
   * get the current cache key-value store
   */


  getCache() {
    this.logger.trace("Getting cache key-value store");
    return this.cache;
  }
  /**
   * sets the current cache (key value store)
   * @param cacheMap - key value map
   */


  setCache(cache) {
    this.logger.trace("Setting cache key value store");
    this.cache = cache; // mark change in cache

    this.emitChange();
  }
  /**
   * Gets cache item with given key.
   * @param key - lookup key for the cache entry
   */


  getItem(key) {
    this.logger.tracePii(`Item key: ${key}`); // read cache

    const cache = this.getCache();
    return cache[key];
  }
  /**
   * Gets cache item with given key-value
   * @param key - lookup key for the cache entry
   * @param value - value of the cache entry
   */


  setItem(key, value) {
    this.logger.tracePii(`Item key: ${key}`); // read cache

    const cache = this.getCache();
    cache[key] = value; // write to cache

    this.setCache(cache);
  }
  /**
   * fetch the account entity
   * @param accountKey - lookup key to fetch cache type AccountEntity
   */


  getAccount(accountKey) {
    const account = this.getItem(accountKey);

    if (msalCommon.AccountEntity.isAccountEntity(account)) {
      return account;
    }

    return null;
  }
  /**
   * set account entity
   * @param account - cache value to be set of type AccountEntity
   */


  setAccount(account) {
    const accountKey = account.generateAccountKey();
    this.setItem(accountKey, account);
  }
  /**
   * fetch the idToken credential
   * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
   */


  getIdTokenCredential(idTokenKey) {
    const idToken = this.getItem(idTokenKey);

    if (msalCommon.IdTokenEntity.isIdTokenEntity(idToken)) {
      return idToken;
    }

    return null;
  }
  /**
   * set idToken credential
   * @param idToken - cache value to be set of type IdTokenEntity
   */


  setIdTokenCredential(idToken) {
    const idTokenKey = idToken.generateCredentialKey();
    this.setItem(idTokenKey, idToken);
  }
  /**
   * fetch the accessToken credential
   * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
   */


  getAccessTokenCredential(accessTokenKey) {
    const accessToken = this.getItem(accessTokenKey);

    if (msalCommon.AccessTokenEntity.isAccessTokenEntity(accessToken)) {
      return accessToken;
    }

    return null;
  }
  /**
   * set accessToken credential
   * @param accessToken -  cache value to be set of type AccessTokenEntity
   */


  setAccessTokenCredential(accessToken) {
    const accessTokenKey = accessToken.generateCredentialKey();
    this.setItem(accessTokenKey, accessToken);
  }
  /**
   * fetch the refreshToken credential
   * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
   */


  getRefreshTokenCredential(refreshTokenKey) {
    const refreshToken = this.getItem(refreshTokenKey);

    if (msalCommon.RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {
      return refreshToken;
    }

    return null;
  }
  /**
   * set refreshToken credential
   * @param refreshToken - cache value to be set of type RefreshTokenEntity
   */


  setRefreshTokenCredential(refreshToken) {
    const refreshTokenKey = refreshToken.generateCredentialKey();
    this.setItem(refreshTokenKey, refreshToken);
  }
  /**
   * fetch appMetadata entity from the platform cache
   * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
   */


  getAppMetadata(appMetadataKey) {
    const appMetadata = this.getItem(appMetadataKey);

    if (msalCommon.AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {
      return appMetadata;
    }

    return null;
  }
  /**
   * set appMetadata entity to the platform cache
   * @param appMetadata - cache value to be set of type AppMetadataEntity
   */


  setAppMetadata(appMetadata) {
    const appMetadataKey = appMetadata.generateAppMetadataKey();
    this.setItem(appMetadataKey, appMetadata);
  }
  /**
   * fetch server telemetry entity from the platform cache
   * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
   */


  getServerTelemetry(serverTelemetrykey) {
    const serverTelemetryEntity = this.getItem(serverTelemetrykey);

    if (serverTelemetryEntity && msalCommon.ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
      return serverTelemetryEntity;
    }

    return null;
  }
  /**
   * set server telemetry entity to the platform cache
   * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
   * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
   */


  setServerTelemetry(serverTelemetryKey, serverTelemetry) {
    this.setItem(serverTelemetryKey, serverTelemetry);
  }
  /**
   * fetch authority metadata entity from the platform cache
   * @param key - lookup key to fetch cache type AuthorityMetadataEntity
   */


  getAuthorityMetadata(key) {
    const authorityMetadataEntity = this.getItem(key);

    if (authorityMetadataEntity && msalCommon.AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
      return authorityMetadataEntity;
    }

    return null;
  }
  /**
   * Get all authority metadata keys
   */


  getAuthorityMetadataKeys() {
    return this.getKeys().filter(key => {
      return this.isAuthorityMetadata(key);
    });
  }
  /**
   * set authority metadata entity to the platform cache
   * @param key - lookup key to fetch cache type AuthorityMetadataEntity
   * @param metadata - cache value to be set of type AuthorityMetadataEntity
   */


  setAuthorityMetadata(key, metadata) {
    this.setItem(key, metadata);
  }
  /**
   * fetch throttling entity from the platform cache
   * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
   */


  getThrottlingCache(throttlingCacheKey) {
    const throttlingCache = this.getItem(throttlingCacheKey);

    if (throttlingCache && msalCommon.ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
      return throttlingCache;
    }

    return null;
  }
  /**
   * set throttling entity to the platform cache
   * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
   * @param throttlingCache - cache value to be set of type ThrottlingEntity
   */


  setThrottlingCache(throttlingCacheKey, throttlingCache) {
    this.setItem(throttlingCacheKey, throttlingCache);
  }
  /**
   * Removes the cache item from memory with the given key.
   * @param key - lookup key to remove a cache entity
   * @param inMemory - key value map of the cache
   */


  removeItem(key) {
    this.logger.tracePii(`Item key: ${key}`); // read inMemoryCache

    let result = false;
    const cache = this.getCache();

    if (!!cache[key]) {
      delete cache[key];
      result = true;
    } // write to the cache after removal


    if (result) {
      this.setCache(cache);
      this.emitChange();
    }

    return result;
  }
  /**
   * Checks whether key is in cache.
   * @param key - look up key for a cache entity
   */


  containsKey(key) {
    return this.getKeys().includes(key);
  }
  /**
   * Gets all keys in window.
   */


  getKeys() {
    this.logger.trace("Retrieving all cache keys"); // read cache

    const cache = this.getCache();
    return [...Object.keys(cache)];
  }
  /**
   * Clears all cache entries created by MSAL (except tokens).
   */


  async clear() {
    this.logger.trace("Clearing cache entries created by MSAL"); // read inMemoryCache

    const cacheKeys = this.getKeys(); // delete each element

    cacheKeys.forEach(key => {
      this.removeItem(key);
    });
    this.emitChange();
  }
  /**
   * Initialize in memory cache from an exisiting cache vault
   * @param cache - blob formatted cache (JSON)
   */


  static generateInMemoryCache(cache) {
    return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
  }
  /**
   * retrieves the final JSON
   * @param inMemoryCache - itemised cache read from the JSON
   */


  static generateJsonCache(inMemoryCache) {
    return Serializer.serializeAllCache(inMemoryCache);
  }
  /**
   * Updates a credential's cache key if the current cache key is outdated
   */


  updateCredentialCacheKey(currentCacheKey, credential) {
    const updatedCacheKey = credential.generateCredentialKey();

    if (currentCacheKey !== updatedCacheKey) {
      const cacheItem = this.getItem(currentCacheKey);

      if (cacheItem) {
        this.removeItem(currentCacheKey);
        this.setItem(updatedCacheKey, cacheItem);
        this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
        return updatedCacheKey;
      } else {
        this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
      }
    }

    return currentCacheKey;
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const defaultSerializedCache = {
  Account: {},
  IdToken: {},
  AccessToken: {},
  RefreshToken: {},
  AppMetadata: {}
};
/**
 * In-memory token cache manager
 * @public
 */

class TokenCache {
  constructor(storage, logger, cachePlugin) {
    this.cacheHasChanged = false;
    this.storage = storage;
    this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));

    if (cachePlugin) {
      this.persistence = cachePlugin;
    }

    this.logger = logger;
  }
  /**
   * Set to true if cache state has changed since last time serialize or writeToPersistence was called
   */


  hasChanged() {
    return this.cacheHasChanged;
  }
  /**
   * Serializes in memory cache to JSON
   */


  serialize() {
    this.logger.trace("Serializing in-memory cache");
    let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache()); // if cacheSnapshot not null or empty, merge

    if (!msalCommon.StringUtils.isEmpty(this.cacheSnapshot)) {
      this.logger.trace("Reading cache snapshot from disk");
      finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
    } else {
      this.logger.trace("No cache snapshot to merge");
    }

    this.cacheHasChanged = false;
    return JSON.stringify(finalState);
  }
  /**
   * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
   * @param cache - blob formatted cache
   */


  deserialize(cache) {
    this.logger.trace("Deserializing JSON to in-memory cache");
    this.cacheSnapshot = cache;

    if (!msalCommon.StringUtils.isEmpty(this.cacheSnapshot)) {
      this.logger.trace("Reading cache snapshot from disk");
      const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
      this.storage.setInMemoryCache(deserializedCache);
    } else {
      this.logger.trace("No cache snapshot to deserialize");
    }
  }
  /**
   * Fetches the cache key-value map
   */


  getKVStore() {
    return this.storage.getCache();
  }
  /**
   * API that retrieves all accounts currently in cache to the user
   */


  async getAllAccounts() {
    this.logger.trace("getAllAccounts called");
    let cacheContext;

    try {
      if (this.persistence) {
        cacheContext = new msalCommon.TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
      }

      return this.storage.getAllAccounts();
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  /**
   * Returns the signed in account matching homeAccountId.
   * (the account object is created at the time of successful login)
   * or null when no matching account is found
   * @param homeAccountId - unique identifier for an account (uid.utid)
   */


  async getAccountByHomeId(homeAccountId) {
    const allAccounts = await this.getAllAccounts();

    if (!msalCommon.StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {
      return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;
    } else {
      return null;
    }
  }
  /**
   * Returns the signed in account matching localAccountId.
   * (the account object is created at the time of successful login)
   * or null when no matching account is found
   * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
   */


  async getAccountByLocalId(localAccountId) {
    const allAccounts = await this.getAllAccounts();

    if (!msalCommon.StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {
      return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;
    } else {
      return null;
    }
  }
  /**
   * API to remove a specific account and the relevant data from cache
   * @param account - AccountInfo passed by the user
   */


  async removeAccount(account) {
    this.logger.trace("removeAccount called");
    let cacheContext;

    try {
      if (this.persistence) {
        cacheContext = new msalCommon.TokenCacheContext(this, true);
        await this.persistence.beforeCacheAccess(cacheContext);
      }

      await this.storage.removeAccount(msalCommon.AccountEntity.generateAccountCacheKey(account));
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  /**
   * Called when the cache has changed state.
   */


  handleChangeEvent() {
    this.cacheHasChanged = true;
  }
  /**
   * Merge in memory cache with the cache snapshot.
   * @param oldState - cache before changes
   * @param currentState - current cache state in the library
   */


  mergeState(oldState, currentState) {
    this.logger.trace("Merging in-memory cache with cache snapshot");
    const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
    return this.mergeUpdates(stateAfterRemoval, currentState);
  }
  /**
   * Deep update of oldState based on newState values
   * @param oldState - cache before changes
   * @param newState - updated cache
   */


  mergeUpdates(oldState, newState) {
    Object.keys(newState).forEach(newKey => {
      const newValue = newState[newKey]; // if oldState does not contain value but newValue does, add it

      if (!oldState.hasOwnProperty(newKey)) {
        if (newValue !== null) {
          oldState[newKey] = newValue;
        }
      } else {
        // both oldState and newState contain the key, do deep update
        const newValueNotNull = newValue !== null;
        const newValueIsObject = typeof newValue === "object";
        const newValueIsNotArray = !Array.isArray(newValue);
        const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;

        if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
          this.mergeUpdates(oldState[newKey], newValue);
        } else {
          oldState[newKey] = newValue;
        }
      }
    });
    return oldState;
  }
  /**
   * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
   * oldState that are not recognized, they are left untouched.
   * @param oldState - cache before changes
   * @param newState - updated cache
   */


  mergeRemovals(oldState, newState) {
    this.logger.trace("Remove updated entries in cache");
    const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
    const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
    const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
    const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
    const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
    return { ...oldState,
      Account: accounts,
      AccessToken: accessTokens,
      RefreshToken: refreshTokens,
      IdToken: idTokens,
      AppMetadata: appMetadata
    };
  }
  /**
   * Helper to merge new cache with the old one
   * @param oldState - cache before changes
   * @param newState - updated cache
   */


  mergeRemovalsDict(oldState, newState) {
    const finalState = { ...oldState
    };
    Object.keys(oldState).forEach(oldKey => {
      if (!newState || !newState.hasOwnProperty(oldKey)) {
        delete finalState[oldKey];
      }
    });
    return finalState;
  }
  /**
   * Helper to overlay as a part of cache merge
   * @param passedInCache - cache read from the blob
   */


  overlayDefaults(passedInCache) {
    this.logger.trace("Overlaying input cache with the default cache");
    return {
      Account: { ...defaultSerializedCache.Account,
        ...passedInCache.Account
      },
      IdToken: { ...defaultSerializedCache.IdToken,
        ...passedInCache.IdToken
      },
      AccessToken: { ...defaultSerializedCache.AccessToken,
        ...passedInCache.AccessToken
      },
      RefreshToken: { ...defaultSerializedCache.RefreshToken,
        ...passedInCache.RefreshToken
      },
      AppMetadata: { ...defaultSerializedCache.AppMetadata,
        ...passedInCache.AppMetadata
      }
    };
  }

}

/* eslint-disable header/header */
const name = "@azure/msal-node";
const version = "1.13.0";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Base abstract class for all ClientApplications - public and confidential
 * @public
 */

class ClientApplication {
  /**
   * Constructor for the ClientApplication
   */
  constructor(configuration) {
    this.config = buildAppConfiguration(configuration);
    this.cryptoProvider = new CryptoProvider();
    this.logger = new msalCommon.Logger(this.config.system.loggerOptions, name, version);
    this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);
    this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
  }
  /**
   * Creates the URL of the authorization request, letting the user input credentials and consent to the
   * application. The URL targets the /authorize endpoint of the authority configured in the
   * application object.
   *
   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
   * `acquireTokenByCode(AuthorizationCodeRequest)`.
   */


  async getAuthCodeUrl(request) {
    this.logger.info("getAuthCodeUrl called", request.correlationId);
    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request)),
      responseMode: request.responseMode || msalCommon.ResponseMode.QUERY,
      authenticationScheme: msalCommon.AuthenticationScheme.BEARER
    };
    const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, undefined, undefined, request.azureCloudOptions);
    const authorizationCodeClient = new msalCommon.AuthorizationCodeClient(authClientConfig);
    this.logger.verbose("Auth code client created", validRequest.correlationId);
    return authorizationCodeClient.getAuthCodeUrl(validRequest);
  }
  /**
   * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
   * Authorization Code flow.
   *
   * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
   * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
   * AuthorizationCodeRequest are the same.
   */


  async acquireTokenByCode(request, authCodePayLoad) {
    this.logger.info("acquireTokenByCode called", request.correlationId);
    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request)),
      authenticationScheme: msalCommon.AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);

    try {
      const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);
      const authorizationCodeClient = new msalCommon.AuthorizationCodeClient(authClientConfig);
      this.logger.verbose("Auth code client created", validRequest.correlationId);
      return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token by exchanging the refresh token provided for a new set of tokens.
   *
   * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
   * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
   * handle the caching and refreshing of tokens automatically.
   */


  async acquireTokenByRefreshToken(request) {
    this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request)),
      authenticationScheme: msalCommon.AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);

    try {
      const refreshTokenClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);
      const refreshTokenClient = new msalCommon.RefreshTokenClient(refreshTokenClientConfig);
      this.logger.verbose("Refresh token client created", validRequest.correlationId);
      return refreshTokenClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token silently when a user specifies the account the token is requested for.
   *
   * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
   * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
   * In case the refresh_token is expired or not found, an error is thrown
   * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
   */


  async acquireTokenSilent(request) {
    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request)),
      forceRefresh: request.forceRefresh || false
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);

    try {
      const silentFlowClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);
      const silentFlowClient = new msalCommon.SilentFlowClient(silentFlowClientConfig);
      this.logger.verbose("Silent flow client created", validRequest.correlationId);
      return silentFlowClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires tokens with password grant by exchanging client applications username and password for credentials
   *
   * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
   * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
   * Microsoft's documentation and recommendations are at:
   * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
   *
   * @param request - UsenamePasswordRequest
   */


  async acquireTokenByUsernamePassword(request) {
    this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request))
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);

    try {
      const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);
      const usernamePasswordClient = new msalCommon.UsernamePasswordClient(usernamePasswordClientConfig);
      this.logger.verbose("Username password client created", validRequest.correlationId);
      return usernamePasswordClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Gets the token cache for the application.
   */


  getTokenCache() {
    this.logger.info("getTokenCache called");
    return this.tokenCache;
  }
  /**
   * Returns the logger instance
   */


  getLogger() {
    return this.logger;
  }
  /**
   * Replaces the default logger set in configurations with new Logger with new configurations
   * @param logger - Logger instance
   */


  setLogger(logger) {
    this.logger = logger;
  }
  /**
   * Builds the common configuration to be passed to the common component based on the platform configurarion
   * @param authority - user passed authority in configuration
   * @param serverTelemetryManager - initializes servertelemetry if passed
   */


  async buildOauthClientConfiguration(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {
    this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId); // precedence - azureCloudInstance + tenant >> authority and request  >> config

    const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions; // using null assertion operator as we ensure that all config values have default values in buildConfiguration()

    this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);
    const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);
    serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
    const clientConfiguration = {
      authOptions: {
        clientId: this.config.auth.clientId,
        authority: discoveredAuthority,
        clientCapabilities: this.config.auth.clientCapabilities
      },
      systemOptions: {
        proxyUrl: this.config.system.proxyUrl
      },
      loggerOptions: {
        logLevel: this.config.system.loggerOptions.logLevel,
        loggerCallback: this.config.system.loggerOptions.loggerCallback,
        piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
        correlationId: requestCorrelationId
      },
      cryptoInterface: this.cryptoProvider,
      networkInterface: this.config.system.networkClient,
      storageInterface: this.storage,
      serverTelemetryManager: serverTelemetryManager,
      clientCredentials: {
        clientSecret: this.clientSecret,
        clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined
      },
      libraryInfo: {
        sku: Constants.MSAL_SKU,
        version: version,
        cpu: process.arch || msalCommon.Constants.EMPTY_STRING,
        os: process.platform || msalCommon.Constants.EMPTY_STRING
      },
      telemetry: this.config.telemetry,
      persistencePlugin: this.config.cache.cachePlugin,
      serializableCache: this.tokenCache
    };
    return clientConfiguration;
  }

  getClientAssertion(authority) {
    return {
      assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
      assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
    };
  }
  /**
   * Generates a request with the default scopes & generates a correlationId.
   * @param authRequest - BaseAuthRequest for initialization
   */


  async initializeBaseRequest(authRequest) {
    this.logger.verbose("initializeRequestScopes called", authRequest.correlationId); // Default authenticationScheme to Bearer, log that POP isn't supported yet

    if (authRequest.authenticationScheme && authRequest.authenticationScheme === msalCommon.AuthenticationScheme.POP) {
      this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
    }

    authRequest.authenticationScheme = msalCommon.AuthenticationScheme.BEARER; // Set requested claims hash if claims were requested

    if (authRequest.claims && !msalCommon.StringUtils.isEmpty(authRequest.claims)) {
      authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
    }

    return { ...authRequest,
      scopes: [...(authRequest && authRequest.scopes || []), ...msalCommon.OIDC_DEFAULT_SCOPES],
      correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
      authority: authRequest.authority || this.config.auth.authority
    };
  }
  /**
   * Initializes the server telemetry payload
   * @param apiId - Id for a specific request
   * @param correlationId - GUID
   * @param forceRefresh - boolean to indicate network call
   */


  initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
    const telemetryPayload = {
      clientId: this.config.auth.clientId,
      correlationId: correlationId,
      apiId: apiId,
      forceRefresh: forceRefresh || false
    };
    return new msalCommon.ServerTelemetryManager(telemetryPayload, this.storage);
  }
  /**
   * Create authority instance. If authority not passed in request, default to authority set on the application
   * object. If no authority set in application object, then default to common authority.
   * @param authorityString - authority from user configuration
   */


  async createAuthority(authorityString, azureRegionConfiguration, requestCorrelationId, azureCloudOptions) {
    this.logger.verbose("createAuthority called", requestCorrelationId); // build authority string based on auth params - azureCloudInstance is prioritized if provided

    const authorityUrl = msalCommon.Authority.generateAuthority(authorityString, azureCloudOptions);
    const authorityOptions = {
      protocolMode: this.config.auth.protocolMode,
      knownAuthorities: this.config.auth.knownAuthorities,
      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
      authorityMetadata: this.config.auth.authorityMetadata,
      azureRegionConfiguration,
      skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
    };
    return await msalCommon.AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.config.system.proxyUrl);
  }
  /**
   * Clear the cache
   */


  clearCache() {
    this.storage.clear();
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * NodeAuthErrorMessage class containing string constants used by error codes and messages.
 */

const NodeAuthErrorMessage = {
  invalidLoopbackAddressType: {
    code: "invalid_loopback_server_address_type",
    desc: "Loopback server address is not type string. This is unexpected."
  },
  unableToLoadRedirectUri: {
    code: "unable_to_load_redirectUrl",
    desc: "Loopback server callback was invoked without a url. This is unexpected."
  },
  noAuthCodeInResponse: {
    code: "no_auth_code_in_response",
    desc: "No auth code found in the server response. Please check your network trace to determine what happened."
  },
  noLoopbackServerExists: {
    code: "no_loopback_server_exists",
    desc: "No loopback server exists yet."
  },
  loopbackServerAlreadyExists: {
    code: "loopback_server_already_exists",
    desc: "Loopback server already exists. Cannot create another."
  },
  loopbackServerTimeout: {
    code: "loopback_server_timeout",
    desc: "Timed out waiting for auth code listener to be registered."
  }
};
class NodeAuthError extends msalCommon.AuthError {
  constructor(errorCode, errorMessage) {
    super(errorCode, errorMessage);
    this.name = "NodeAuthError";
  }
  /**
   * Creates an error thrown if loopback server address is of type string.
   */


  static createInvalidLoopbackAddressTypeError() {
    return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server is unable to get a url.
   */


  static createUnableToLoadRedirectUrlError() {
    return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
  }
  /**
   * Creates an error thrown if the server response does not contain an auth code.
   */


  static createNoAuthCodeInResponseError() {
    return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server has not been spun up yet.
   */


  static createNoLoopbackServerExistsError() {
    return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
  }
  /**
   * Creates an error thrown if a loopback server already exists when attempting to create another one.
   */


  static createLoopbackServerAlreadyExistsError() {
    return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server times out registering the auth code listener.
   */


  static createLoopbackServerTimeoutError() {
    return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class LoopbackClient {
  /**
   * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
   * @param successTemplate
   * @param errorTemplate
   * @returns
   */
  async listenForAuthCode(successTemplate, errorTemplate) {
    if (!!this.server) {
      throw NodeAuthError.createLoopbackServerAlreadyExistsError();
    }

    const authCodeListener = new Promise((resolve, reject) => {
      this.server = http.createServer(async (req, res) => {
        const url = req.url;

        if (!url) {
          res.end(errorTemplate || "Error occurred loading redirectUrl");
          reject(NodeAuthError.createUnableToLoadRedirectUrlError());
          return;
        } else if (url === msalCommon.Constants.FORWARD_SLASH) {
          res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
          return;
        }

        const authCodeResponse = msalCommon.UrlString.getDeserializedQueryString(url);

        if (authCodeResponse.code) {
          const redirectUri = await this.getRedirectUri();
          res.writeHead(HttpStatus.REDIRECT, {
            location: redirectUri
          }); // Prevent auth code from being saved in the browser history

          res.end();
        }

        resolve(authCodeResponse);
      });
      this.server.listen(0); // Listen on any available port
    }); // Wait for server to be listening

    await new Promise(resolve => {
      let ticks = 0;
      const id = setInterval(() => {
        if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
          throw NodeAuthError.createLoopbackServerTimeoutError();
        }

        if (this.server.listening) {
          clearInterval(id);
          resolve();
        }

        ticks++;
      }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
    });
    return authCodeListener;
  }
  /**
   * Get the port that the loopback server is running on
   * @returns
   */


  getRedirectUri() {
    if (!this.server) {
      throw NodeAuthError.createNoLoopbackServerExistsError();
    }

    const address = this.server.address();

    if (!address || typeof address === "string" || !address.port) {
      this.closeServer();
      throw NodeAuthError.createInvalidLoopbackAddressTypeError();
    }

    const port = address && address.port;
    return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;
  }
  /**
   * Close the loopback server
   */


  closeServer() {
    if (!!this.server) {
      this.server.close();
    }
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications
 * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.
 * @public
 */

class PublicClientApplication extends ClientApplication {
  /**
   * Important attributes in the Configuration object for auth are:
   * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
   * - authority: the authority URL for your application.
   *
   * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
   * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
   * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
   * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
   * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
   *
   * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
   * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
   * construction.
   *
   * ADFS authorities are of the form https://\{instance\}/adfs.
   */
  constructor(configuration) {
    super(configuration);
  }
  /**
   * Acquires a token from the authority using OAuth2.0 device code flow.
   * This flow is designed for devices that do not have access to a browser or have input constraints.
   * The authorization server issues a DeviceCode object with a verification code, an end-user code,
   * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
   * instructed to use another device to navigate to the verification URI to input credentials.
   * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
   * until the end-user completes input of credentials.
   */


  async acquireTokenByDeviceCode(request) {
    this.logger.info("acquireTokenByDeviceCode called", request.correlationId);
    const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);

    try {
      const deviceCodeConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);
      const deviceCodeClient = new msalCommon.DeviceCodeClient(deviceCodeConfig);
      this.logger.verbose("Device code client created", validRequest.correlationId);
      return deviceCodeClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token by requesting an Authorization code then exchanging it for a token.
   */


  async acquireTokenInteractive(request) {
    const {
      verifier,
      challenge
    } = await this.cryptoProvider.generatePkceCodes();
    const {
      openBrowser,
      successTemplate,
      errorTemplate,
      ...remainingProperties
    } = request;
    const loopbackClient = new LoopbackClient();
    const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);
    const redirectUri = loopbackClient.getRedirectUri();
    const validRequest = { ...remainingProperties,
      scopes: request.scopes || [],
      redirectUri: redirectUri,
      responseMode: msalCommon.ResponseMode.QUERY,
      codeChallenge: challenge,
      codeChallengeMethod: msalCommon.CodeChallengeMethodValues.S256
    };
    const authCodeUrl = await this.getAuthCodeUrl(validRequest);
    await openBrowser(authCodeUrl);
    const authCodeResponse = await authCodeListener.finally(() => {
      loopbackClient.closeServer();
    });

    if (authCodeResponse.error) {
      throw new msalCommon.ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
    } else if (!authCodeResponse.code) {
      throw NodeAuthError.createNoAuthCodeInResponseError();
    }

    const clientInfo = authCodeResponse.client_info;
    const tokenRequest = {
      code: authCodeResponse.code,
      scopes: msalCommon.OIDC_DEFAULT_SCOPES,
      redirectUri: validRequest.redirectUri,
      codeVerifier: verifier,
      clientInfo: clientInfo || msalCommon.Constants.EMPTY_STRING
    };
    return this.acquireTokenByCode(tokenRequest);
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Client assertion of type jwt-bearer used in confidential client flows
 * @public
 */

class ClientAssertion {
  /**
   * Initialize the ClientAssertion class from the clientAssertion passed by the user
   * @param assertion - refer https://tools.ietf.org/html/rfc7521
   */
  static fromAssertion(assertion) {
    const clientAssertion = new ClientAssertion();
    clientAssertion.jwt = assertion;
    return clientAssertion;
  }
  /**
   * Initialize the ClientAssertion class from the certificate passed by the user
   * @param thumbprint - identifier of a certificate
   * @param privateKey - secret key
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */


  static fromCertificate(thumbprint, privateKey, publicCertificate) {
    const clientAssertion = new ClientAssertion();
    clientAssertion.privateKey = privateKey;
    clientAssertion.thumbprint = thumbprint;

    if (publicCertificate) {
      clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
    }

    return clientAssertion;
  }
  /**
   * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
   * @param cryptoProvider - library's crypto helper
   * @param issuer - iss claim
   * @param jwtAudience - aud claim
   */


  getJwt(cryptoProvider, issuer, jwtAudience) {
    // if assertion was created from certificate, check if jwt is expired and create new one.
    if (this.privateKey && this.thumbprint) {
      if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
        return this.jwt;
      }

      return this.createJwt(cryptoProvider, issuer, jwtAudience);
    }
    /*
     * if assertion was created by caller, then we just append it. It is up to the caller to
     * ensure that it contains necessary claims and that it is not expired.
     */


    if (this.jwt) {
      return this.jwt;
    }

    throw msalCommon.ClientAuthError.createInvalidAssertionError();
  }
  /**
   * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
   */


  createJwt(cryptoProvider, issuer, jwtAudience) {
    this.issuer = issuer;
    this.jwtAudience = jwtAudience;
    const issuedAt = msalCommon.TimeUtils.nowSeconds();
    this.expirationTime = issuedAt + 600;
    const header = {
      alg: JwtConstants.RSA_256,
      x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, "hex")
    };

    if (this.publicCertificate) {
      Object.assign(header, {
        x5c: this.publicCertificate
      });
    }

    const payload = {
      [JwtConstants.AUDIENCE]: this.jwtAudience,
      [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
      [JwtConstants.ISSUER]: this.issuer,
      [JwtConstants.SUBJECT]: this.issuer,
      [JwtConstants.NOT_BEFORE]: issuedAt,
      [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
    };
    this.jwt = jsonwebtoken.sign(payload, this.privateKey, {
      header
    });
    return this.jwt;
  }
  /**
   * Utility API to check expiration
   */


  isExpired() {
    return this.expirationTime < msalCommon.TimeUtils.nowSeconds();
  }
  /**
   * Extracts the raw certs from a given certificate string and returns them in an array.
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */


  static parseCertificate(publicCertificate) {
    /**
     * This is regex to identify the certs in a given certificate string.
     * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.
     * The information in parens "(.+?)" is the capture group to represent the cert we want isolated.
     * "." means any string character, "+" means match 1 or more times, and "?" means the shortest match.
     * The "g" at the end of the regex means search the string globally, and the "s" enables the "." to match newlines.
     */
    const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
    const certs = [];
    let matches;

    while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
      // matches[1] represents the first parens capture group in the regex.
      certs.push(matches[1].replace(/\r*\n/g, msalCommon.Constants.EMPTY_STRING));
    }

    return certs;
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications
 *  will configure application secrets, client certificates/assertions as applicable
 * @public
 */

class ConfidentialClientApplication extends ClientApplication {
  /**
   * Constructor for the ConfidentialClientApplication
   *
   * Required attributes in the Configuration object are:
   * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
   * - authority: the authority URL for your application.
   * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
   *
   * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
   * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
   * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
   * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
   *
   * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
   * Full B2C functionality will be available in this library in future versions.
   *
   * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
   */
  constructor(configuration) {
    super(configuration);
    this.setClientCredential(this.config);
    this.appTokenProvider = undefined;
  }
  /**
   * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
   * is meant for Azure SDK to enhance Managed Identity support.
   *
   * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
   */


  SetAppTokenProvider(provider) {
    this.appTokenProvider = provider;
  }
  /**
   * Acquires tokens from the authority for the application (not for an end user).
   */


  async acquireTokenByClientCredential(request) {
    this.logger.info("acquireTokenByClientCredential called", request.correlationId); // If there is a client assertion present in the request, it overrides the one present in the client configuration

    let clientAssertion;

    if (request.clientAssertion) {
      clientAssertion = {
        assertion: request.clientAssertion,
        assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
      };
    }

    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request)),
      clientAssertion
    };
    const azureRegionConfiguration = {
      azureRegion: validRequest.azureRegion,
      environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);

    try {
      const clientCredentialConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, azureRegionConfiguration, request.azureCloudOptions);
      const clientCredentialClient = new msalCommon.ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
      this.logger.verbose("Client credential client created", validRequest.correlationId);
      return clientCredentialClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires tokens from the authority for the application.
   *
   * Used in scenarios where the current app is a middle-tier service which was called with a token
   * representing an end user. The current app can use the token (oboAssertion) to request another
   * token to access downstream web API, on behalf of that user.
   *
   * The current middle-tier app has no user interaction to obtain consent.
   * See how to gain consent upfront for your middle-tier app from this article.
   * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
   */


  async acquireTokenOnBehalfOf(request) {
    this.logger.info("acquireTokenOnBehalfOf called", request.correlationId);
    const validRequest = { ...request,
      ...(await this.initializeBaseRequest(request))
    };

    try {
      const onBehalfOfConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, undefined, undefined, request.azureCloudOptions);
      const oboClient = new msalCommon.OnBehalfOfClient(onBehalfOfConfig);
      this.logger.verbose("On behalf of client created", validRequest.correlationId);
      return oboClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof msalCommon.AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }

      throw e;
    }
  }

  setClientCredential(configuration) {
    const clientSecretNotEmpty = !msalCommon.StringUtils.isEmpty(configuration.auth.clientSecret);
    const clientAssertionNotEmpty = !msalCommon.StringUtils.isEmpty(configuration.auth.clientAssertion);
    const certificate = configuration.auth.clientCertificate || {
      thumbprint: msalCommon.Constants.EMPTY_STRING,
      privateKey: msalCommon.Constants.EMPTY_STRING
    };
    const certificateNotEmpty = !msalCommon.StringUtils.isEmpty(certificate.thumbprint) || !msalCommon.StringUtils.isEmpty(certificate.privateKey);
    /*
     * If app developer configures this callback, they don't need a credential
     * i.e. AzureSDK can get token from Managed Identity without a cert / secret
     */

    if (this.appTokenProvider) {
      return;
    } // Check that at most one credential is set on the application


    if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
      throw msalCommon.ClientAuthError.createInvalidCredentialError();
    }

    if (configuration.auth.clientSecret) {
      this.clientSecret = configuration.auth.clientSecret;
      return;
    }

    if (configuration.auth.clientAssertion) {
      this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);
      return;
    }

    if (!certificateNotEmpty) {
      throw msalCommon.ClientAuthError.createInvalidCredentialError();
    } else {
      var _configuration$auth$c;

      this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, (_configuration$auth$c = configuration.auth.clientCertificate) == null ? void 0 : _configuration$auth$c.x5c);
    }
  }

}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class DistributedCachePlugin {
  constructor(client, partitionManager) {
    this.client = client;
    this.partitionManager = partitionManager;
  }

  async beforeCacheAccess(cacheContext) {
    const partitionKey = await this.partitionManager.getKey();
    const cacheData = await this.client.get(partitionKey);
    cacheContext.tokenCache.deserialize(cacheData);
  }

  async afterCacheAccess(cacheContext) {
    if (cacheContext.cacheHasChanged) {
      const kvStore = cacheContext.tokenCache.getKVStore();
      const accountEntities = Object.values(kvStore).filter(value => msalCommon.AccountEntity.isAccountEntity(value));

      if (accountEntities.length > 0) {
        const accountEntity = accountEntities[0];
        const partitionKey = await this.partitionManager.extractKey(accountEntity);
        await this.client.set(partitionKey, cacheContext.tokenCache.serialize());
      }
    }
  }

}

Object.defineProperty(exports, "AuthError", ({
    enumerable: true,
    get: function () {
        return msalCommon.AuthError;
    }
}));
Object.defineProperty(exports, "AuthErrorMessage", ({
    enumerable: true,
    get: function () {
        return msalCommon.AuthErrorMessage;
    }
}));
Object.defineProperty(exports, "AzureCloudInstance", ({
    enumerable: true,
    get: function () {
        return msalCommon.AzureCloudInstance;
    }
}));
Object.defineProperty(exports, "ClientAuthError", ({
    enumerable: true,
    get: function () {
        return msalCommon.ClientAuthError;
    }
}));
Object.defineProperty(exports, "ClientAuthErrorMessage", ({
    enumerable: true,
    get: function () {
        return msalCommon.ClientAuthErrorMessage;
    }
}));
Object.defineProperty(exports, "ClientConfigurationError", ({
    enumerable: true,
    get: function () {
        return msalCommon.ClientConfigurationError;
    }
}));
Object.defineProperty(exports, "ClientConfigurationErrorMessage", ({
    enumerable: true,
    get: function () {
        return msalCommon.ClientConfigurationErrorMessage;
    }
}));
Object.defineProperty(exports, "InteractionRequiredAuthError", ({
    enumerable: true,
    get: function () {
        return msalCommon.InteractionRequiredAuthError;
    }
}));
Object.defineProperty(exports, "InteractionRequiredAuthErrorMessage", ({
    enumerable: true,
    get: function () {
        return msalCommon.InteractionRequiredAuthErrorMessage;
    }
}));
Object.defineProperty(exports, "LogLevel", ({
    enumerable: true,
    get: function () {
        return msalCommon.LogLevel;
    }
}));
Object.defineProperty(exports, "Logger", ({
    enumerable: true,
    get: function () {
        return msalCommon.Logger;
    }
}));
Object.defineProperty(exports, "PromptValue", ({
    enumerable: true,
    get: function () {
        return msalCommon.PromptValue;
    }
}));
Object.defineProperty(exports, "ProtocolMode", ({
    enumerable: true,
    get: function () {
        return msalCommon.ProtocolMode;
    }
}));
Object.defineProperty(exports, "ResponseMode", ({
    enumerable: true,
    get: function () {
        return msalCommon.ResponseMode;
    }
}));
Object.defineProperty(exports, "ServerError", ({
    enumerable: true,
    get: function () {
        return msalCommon.ServerError;
    }
}));
Object.defineProperty(exports, "TokenCacheContext", ({
    enumerable: true,
    get: function () {
        return msalCommon.TokenCacheContext;
    }
}));
exports.ClientApplication = ClientApplication;
exports.ClientAssertion = ClientAssertion;
exports.ConfidentialClientApplication = ConfidentialClientApplication;
exports.CryptoProvider = CryptoProvider;
exports.DistributedCachePlugin = DistributedCachePlugin;
exports.NodeStorage = NodeStorage;
exports.PublicClientApplication = PublicClientApplication;
exports.TokenCache = TokenCache;
exports.buildAppConfiguration = buildAppConfiguration;
exports.version = version;
//# sourceMappingURL=msal-node.cjs.development.js.map


/***/ }),

/***/ 4:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports, "__esModule", ({value:!0}));var t,r,n=__nccwpck_require__(6849),i=__nccwpck_require__(3685),o=e(i),s=e(__nccwpck_require__(5687)),a=__nccwpck_require__(5650),c=e(__nccwpck_require__(6113)),l=__nccwpck_require__(3610);!function(e){e.GET="get",e.POST="post"}(t||(t={})),function(e){e[e.OK=200]="OK",e[e.REDIRECT=302]="REDIRECT"}(r||(r={}));const h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";var u;!function(e){e[e.acquireTokenSilent=62]="acquireTokenSilent",e[e.acquireTokenByUsernamePassword=371]="acquireTokenByUsernamePassword",e[e.acquireTokenByDeviceCode=671]="acquireTokenByDeviceCode",e[e.acquireTokenByClientCredential=771]="acquireTokenByClientCredential",e[e.acquireTokenByCode=871]="acquireTokenByCode",e[e.acquireTokenByRefreshToken=872]="acquireTokenByRefreshToken"}(u||(u={}));class d{async sendGetRequestAsync(e,r){return null!=r&&r.proxyUrl?g(e,t.GET,r):p(e,t.GET,r)}async sendPostRequestAsync(e,r,n){return null!=r&&r.proxyUrl?g(e,t.POST,r,n):p(e,t.POST,r,n)}}const g=(e,r,n,i)=>{const s=(null==n?void 0:n.headers)||{},a=new URL((null==n?void 0:n.proxyUrl)||""),c=new URL(e),l={host:a.hostname,port:a.port,method:"CONNECT",path:c.hostname,headers:s};i&&(l.timeout=i);let h="";if(r===t.POST){const e=(null==n?void 0:n.body)||"";h=`Content-Type: application/x-www-form-urlencoded\r\nContent-Length: ${e.length}\r\n\r\n`+e}const u=`${r.toUpperCase()} ${c.href} HTTP/1.1\r\nHost: ${c.host}\r\nConnection: close\r\n`+h+"\r\n";return new Promise((e,t)=>{const r=o.request(l);l.timeout&&r.on("timeout",()=>{r.destroy(),t(new Error("Request time out"))}),r.end(),r.on("connect",(n,i)=>{const o=(null==n?void 0:n.statusCode)||500;(o<200||o>299)&&(r.destroy(),i.destroy(),t(new Error("HTTP status code "+o))),l.timeout&&(i.setTimeout(l.timeout),i.on("timeout",()=>{r.destroy(),i.destroy(),t(new Error("Request time out"))})),i.write(u);const s=[];i.on("data",e=>{s.push(e)}),i.on("end",()=>{const n=Buffer.concat([...s]).toString().split("\r\n"),o=parseInt(n[0].split(" ")[1]),a=n[n.length-1],c=n.slice(1,n.length-2),l=new Map;c.forEach(e=>{const t=e.split(new RegExp(/:\s(.*)/s)),r=t[0];let n=t[1];try{const e=JSON.parse(n);e&&"object"==typeof e&&(n=e)}catch(e){}l.set(r,n)});const h={headers:Object.fromEntries(l),body:JSON.parse(a),status:o};(o<200||o>299)&&"authorization_pending"!==h.body.error&&(r.destroy(),i.destroy(),t(new Error("HTTP status code "+o))),e(h)}),i.on("error",e=>{r.destroy(),i.destroy(),t(new Error(e.toString()))})}),r.on("error",e=>{r.destroy(),t(new Error(e.toString()))})})},p=(e,r,n,i)=>{const o=r===t.POST,a=(null==n?void 0:n.body)||"",c={method:r,headers:(null==n?void 0:n.headers)||{}};return i&&(c.timeout=i),o&&(c.headers={...c.headers,"Content-Length":a.length}),new Promise((t,r)=>{const n=s.request(e,c);i&&n.on("timeout",()=>{n.destroy(),r(new Error("Request time out"))}),o&&n.write(a),n.end(),n.on("response",e=>{const i=e.headers,o=e.statusCode,s=[];e.on("data",e=>{s.push(e)}),e.on("end",()=>{const e=Buffer.concat([...s]).toString(),a={headers:i,body:JSON.parse(e),status:o};(o<200||o>299)&&"authorization_pending"!==a.body.error&&(n.destroy(),r(new Error("HTTP status code "+o))),t(a)})}),n.on("error",e=>{n.destroy(),r(new Error(e.toString()))})})},y={clientId:n.Constants.EMPTY_STRING,authority:n.Constants.DEFAULT_AUTHORITY,clientSecret:n.Constants.EMPTY_STRING,clientAssertion:n.Constants.EMPTY_STRING,clientCertificate:{thumbprint:n.Constants.EMPTY_STRING,privateKey:n.Constants.EMPTY_STRING,x5c:n.Constants.EMPTY_STRING},knownAuthorities:[],cloudDiscoveryMetadata:n.Constants.EMPTY_STRING,authorityMetadata:n.Constants.EMPTY_STRING,clientCapabilities:[],protocolMode:n.ProtocolMode.AAD,azureCloudOptions:{azureCloudInstance:n.AzureCloudInstance.None,tenant:n.Constants.EMPTY_STRING},skipAuthorityMetadataCache:!1},m={},f={loggerOptions:{loggerCallback:()=>{},piiLoggingEnabled:!1,logLevel:n.LogLevel.Info},networkClient:class{static getNetworkClient(){return new d}}.getNetworkClient(),proxyUrl:n.Constants.EMPTY_STRING},C={application:{appName:n.Constants.EMPTY_STRING,appVersion:n.Constants.EMPTY_STRING}};function T({auth:e,cache:t,system:r,telemetry:n}){return{auth:{...y,...e},cache:{...m,...t},system:{...f,...r},telemetry:{...C,...n}}}class A{generateGuid(){return a.v4()}isGuid(e){return/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e)}}class k{static base64Encode(e,t){return Buffer.from(e,t).toString("base64")}static base64EncodeUrl(e,t){return k.base64Encode(e,t).replace(/=/g,n.Constants.EMPTY_STRING).replace(/\+/g,"-").replace(/\//g,"_")}static base64Decode(e){return Buffer.from(e,"base64").toString("utf8")}static base64DecodeUrl(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";return k.base64Decode(t)}}class I{sha256(e){return c.createHash("sha256").update(e).digest()}}class E{constructor(){this.hashUtils=new I}async generatePkceCodes(){const e=this.generateCodeVerifier();return{verifier:e,challenge:this.generateCodeChallengeFromVerifier(e)}}generateCodeVerifier(){const e=[],t=256-256%h.length;for(;e.length<=32;){const r=c.randomBytes(1)[0];r>=t||e.push(h[r%h.length])}const r=e.join(n.Constants.EMPTY_STRING);return k.base64EncodeUrl(r)}generateCodeChallengeFromVerifier(e){return k.base64EncodeUrl(this.hashUtils.sha256(e).toString("base64"),"base64")}}class v{constructor(){this.pkceGenerator=new E,this.guidGenerator=new A,this.hashUtils=new I}createNewGuid(){return this.guidGenerator.generateGuid()}base64Encode(e){return k.base64Encode(e)}base64Decode(e){return k.base64Decode(e)}generatePkceCodes(){return this.pkceGenerator.generatePkceCodes()}getPublicKeyThumbprint(){throw new Error("Method not implemented.")}removeTokenBindingKey(){throw new Error("Method not implemented.")}clearKeystore(){throw new Error("Method not implemented.")}signJwt(){throw new Error("Method not implemented.")}async hashString(e){return k.base64EncodeUrl(this.hashUtils.sha256(e).toString("base64"),"base64")}}class w{static deserializeJSONBlob(e){return n.StringUtils.isEmpty(e)?{}:JSON.parse(e)}static deserializeAccounts(e){const t={};return e&&Object.keys(e).map((function(r){const i=e[r],o={homeAccountId:i.home_account_id,environment:i.environment,realm:i.realm,localAccountId:i.local_account_id,username:i.username,authorityType:i.authority_type,name:i.name,clientInfo:i.client_info,lastModificationTime:i.last_modification_time,lastModificationApp:i.last_modification_app},s=new n.AccountEntity;n.CacheManager.toObject(s,o),t[r]=s})),t}static deserializeIdTokens(e){const t={};return e&&Object.keys(e).map((function(r){const i=e[r],o={homeAccountId:i.home_account_id,environment:i.environment,credentialType:i.credential_type,clientId:i.client_id,secret:i.secret,realm:i.realm},s=new n.IdTokenEntity;n.CacheManager.toObject(s,o),t[r]=s})),t}static deserializeAccessTokens(e){const t={};return e&&Object.keys(e).map((function(r){const i=e[r],o={homeAccountId:i.home_account_id,environment:i.environment,credentialType:i.credential_type,clientId:i.client_id,secret:i.secret,realm:i.realm,target:i.target,cachedAt:i.cached_at,expiresOn:i.expires_on,extendedExpiresOn:i.extended_expires_on,refreshOn:i.refresh_on,keyId:i.key_id,tokenType:i.token_type,requestedClaims:i.requestedClaims,requestedClaimsHash:i.requestedClaimsHash},s=new n.AccessTokenEntity;n.CacheManager.toObject(s,o),t[r]=s})),t}static deserializeRefreshTokens(e){const t={};return e&&Object.keys(e).map((function(r){const i=e[r],o={homeAccountId:i.home_account_id,environment:i.environment,credentialType:i.credential_type,clientId:i.client_id,secret:i.secret,familyId:i.family_id,target:i.target,realm:i.realm},s=new n.RefreshTokenEntity;n.CacheManager.toObject(s,o),t[r]=s})),t}static deserializeAppMetadata(e){const t={};return e&&Object.keys(e).map((function(r){const i=e[r],o={clientId:i.client_id,environment:i.environment,familyId:i.family_id},s=new n.AppMetadataEntity;n.CacheManager.toObject(s,o),t[r]=s})),t}static deserializeAllCache(e){return{accounts:e.Account?this.deserializeAccounts(e.Account):{},idTokens:e.IdToken?this.deserializeIdTokens(e.IdToken):{},accessTokens:e.AccessToken?this.deserializeAccessTokens(e.AccessToken):{},refreshTokens:e.RefreshToken?this.deserializeRefreshTokens(e.RefreshToken):{},appMetadata:e.AppMetadata?this.deserializeAppMetadata(e.AppMetadata):{}}}}class b{static serializeJSONBlob(e){return JSON.stringify(e)}static serializeAccounts(e){const t={};return Object.keys(e).map((function(r){const n=e[r];t[r]={home_account_id:n.homeAccountId,environment:n.environment,realm:n.realm,local_account_id:n.localAccountId,username:n.username,authority_type:n.authorityType,name:n.name,client_info:n.clientInfo,last_modification_time:n.lastModificationTime,last_modification_app:n.lastModificationApp}})),t}static serializeIdTokens(e){const t={};return Object.keys(e).map((function(r){const n=e[r];t[r]={home_account_id:n.homeAccountId,environment:n.environment,credential_type:n.credentialType,client_id:n.clientId,secret:n.secret,realm:n.realm}})),t}static serializeAccessTokens(e){const t={};return Object.keys(e).map((function(r){const n=e[r];t[r]={home_account_id:n.homeAccountId,environment:n.environment,credential_type:n.credentialType,client_id:n.clientId,secret:n.secret,realm:n.realm,target:n.target,cached_at:n.cachedAt,expires_on:n.expiresOn,extended_expires_on:n.extendedExpiresOn,refresh_on:n.refreshOn,key_id:n.keyId,token_type:n.tokenType,requestedClaims:n.requestedClaims,requestedClaimsHash:n.requestedClaimsHash}})),t}static serializeRefreshTokens(e){const t={};return Object.keys(e).map((function(r){const n=e[r];t[r]={home_account_id:n.homeAccountId,environment:n.environment,credential_type:n.credentialType,client_id:n.clientId,secret:n.secret,family_id:n.familyId,target:n.target,realm:n.realm}})),t}static serializeAppMetadata(e){const t={};return Object.keys(e).map((function(r){const n=e[r];t[r]={client_id:n.clientId,environment:n.environment,family_id:n.familyId}})),t}static serializeAllCache(e){return{Account:this.serializeAccounts(e.accounts),IdToken:this.serializeIdTokens(e.idTokens),AccessToken:this.serializeAccessTokens(e.accessTokens),RefreshToken:this.serializeRefreshTokens(e.refreshTokens),AppMetadata:this.serializeAppMetadata(e.appMetadata)}}}class S extends n.CacheManager{constructor(e,t,r){super(t,r),this.cache={},this.changeEmitters=[],this.logger=e}registerChangeEmitter(e){this.changeEmitters.push(e)}emitChange(){this.changeEmitters.forEach(e=>e.call(null))}cacheToInMemoryCache(e){const t={accounts:{},idTokens:{},accessTokens:{},refreshTokens:{},appMetadata:{}};for(const r in e)if(e[r]instanceof n.AccountEntity)t.accounts[r]=e[r];else if(e[r]instanceof n.IdTokenEntity)t.idTokens[r]=e[r];else if(e[r]instanceof n.AccessTokenEntity)t.accessTokens[r]=e[r];else if(e[r]instanceof n.RefreshTokenEntity)t.refreshTokens[r]=e[r];else{if(!(e[r]instanceof n.AppMetadataEntity))continue;t.appMetadata[r]=e[r]}return t}inMemoryCacheToCache(e){let t=this.getCache();return t={...t,...e.accounts,...e.idTokens,...e.accessTokens,...e.refreshTokens,...e.appMetadata},t}getInMemoryCache(){return this.logger.trace("Getting in-memory cache"),this.cacheToInMemoryCache(this.getCache())}setInMemoryCache(e){this.logger.trace("Setting in-memory cache");const t=this.inMemoryCacheToCache(e);this.setCache(t),this.emitChange()}getCache(){return this.logger.trace("Getting cache key-value store"),this.cache}setCache(e){this.logger.trace("Setting cache key value store"),this.cache=e,this.emitChange()}getItem(e){return this.logger.tracePii("Item key: "+e),this.getCache()[e]}setItem(e,t){this.logger.tracePii("Item key: "+e);const r=this.getCache();r[e]=t,this.setCache(r)}getAccount(e){const t=this.getItem(e);return n.AccountEntity.isAccountEntity(t)?t:null}setAccount(e){const t=e.generateAccountKey();this.setItem(t,e)}getIdTokenCredential(e){const t=this.getItem(e);return n.IdTokenEntity.isIdTokenEntity(t)?t:null}setIdTokenCredential(e){const t=e.generateCredentialKey();this.setItem(t,e)}getAccessTokenCredential(e){const t=this.getItem(e);return n.AccessTokenEntity.isAccessTokenEntity(t)?t:null}setAccessTokenCredential(e){const t=e.generateCredentialKey();this.setItem(t,e)}getRefreshTokenCredential(e){const t=this.getItem(e);return n.RefreshTokenEntity.isRefreshTokenEntity(t)?t:null}setRefreshTokenCredential(e){const t=e.generateCredentialKey();this.setItem(t,e)}getAppMetadata(e){const t=this.getItem(e);return n.AppMetadataEntity.isAppMetadataEntity(e,t)?t:null}setAppMetadata(e){const t=e.generateAppMetadataKey();this.setItem(t,e)}getServerTelemetry(e){const t=this.getItem(e);return t&&n.ServerTelemetryEntity.isServerTelemetryEntity(e,t)?t:null}setServerTelemetry(e,t){this.setItem(e,t)}getAuthorityMetadata(e){const t=this.getItem(e);return t&&n.AuthorityMetadataEntity.isAuthorityMetadataEntity(e,t)?t:null}getAuthorityMetadataKeys(){return this.getKeys().filter(e=>this.isAuthorityMetadata(e))}setAuthorityMetadata(e,t){this.setItem(e,t)}getThrottlingCache(e){const t=this.getItem(e);return t&&n.ThrottlingEntity.isThrottlingEntity(e,t)?t:null}setThrottlingCache(e,t){this.setItem(e,t)}removeItem(e){this.logger.tracePii("Item key: "+e);let t=!1;const r=this.getCache();return r[e]&&(delete r[e],t=!0),t&&(this.setCache(r),this.emitChange()),t}containsKey(e){return this.getKeys().includes(e)}getKeys(){this.logger.trace("Retrieving all cache keys");const e=this.getCache();return[...Object.keys(e)]}async clear(){this.logger.trace("Clearing cache entries created by MSAL"),this.getKeys().forEach(e=>{this.removeItem(e)}),this.emitChange()}static generateInMemoryCache(e){return w.deserializeAllCache(w.deserializeJSONBlob(e))}static generateJsonCache(e){return b.serializeAllCache(e)}updateCredentialCacheKey(e,t){const r=t.generateCredentialKey();if(e!==r){const n=this.getItem(e);if(n)return this.removeItem(e),this.setItem(r,n),this.logger.verbose(`Updated an outdated ${t.credentialType} cache key`),r;this.logger.error(`Attempted to update an outdated ${t.credentialType} cache key but no item matching the outdated key was found in storage`)}return e}}const R={},M={},_={},O={},P={};class q{constructor(e,t,r){this.cacheHasChanged=!1,this.storage=e,this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this)),r&&(this.persistence=r),this.logger=t}hasChanged(){return this.cacheHasChanged}serialize(){this.logger.trace("Serializing in-memory cache");let e=b.serializeAllCache(this.storage.getInMemoryCache());return n.StringUtils.isEmpty(this.cacheSnapshot)?this.logger.trace("No cache snapshot to merge"):(this.logger.trace("Reading cache snapshot from disk"),e=this.mergeState(JSON.parse(this.cacheSnapshot),e)),this.cacheHasChanged=!1,JSON.stringify(e)}deserialize(e){if(this.logger.trace("Deserializing JSON to in-memory cache"),this.cacheSnapshot=e,n.StringUtils.isEmpty(this.cacheSnapshot))this.logger.trace("No cache snapshot to deserialize");else{this.logger.trace("Reading cache snapshot from disk");const e=w.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));this.storage.setInMemoryCache(e)}}getKVStore(){return this.storage.getCache()}async getAllAccounts(){let e;this.logger.trace("getAllAccounts called");try{return this.persistence&&(e=new n.TokenCacheContext(this,!1),await this.persistence.beforeCacheAccess(e)),this.storage.getAllAccounts()}finally{this.persistence&&e&&await this.persistence.afterCacheAccess(e)}}async getAccountByHomeId(e){const t=await this.getAllAccounts();return!n.StringUtils.isEmpty(e)&&t&&t.length&&t.filter(t=>t.homeAccountId===e)[0]||null}async getAccountByLocalId(e){const t=await this.getAllAccounts();return!n.StringUtils.isEmpty(e)&&t&&t.length&&t.filter(t=>t.localAccountId===e)[0]||null}async removeAccount(e){let t;this.logger.trace("removeAccount called");try{this.persistence&&(t=new n.TokenCacheContext(this,!0),await this.persistence.beforeCacheAccess(t)),await this.storage.removeAccount(n.AccountEntity.generateAccountCacheKey(e))}finally{this.persistence&&t&&await this.persistence.afterCacheAccess(t)}}handleChangeEvent(){this.cacheHasChanged=!0}mergeState(e,t){this.logger.trace("Merging in-memory cache with cache snapshot");const r=this.mergeRemovals(e,t);return this.mergeUpdates(r,t)}mergeUpdates(e,t){return Object.keys(t).forEach(r=>{const n=t[r];if(e.hasOwnProperty(r)){const t=null!==n,i="object"==typeof n,o=!Array.isArray(n),s=null!=e[r];t&&i&&o&&s?this.mergeUpdates(e[r],n):e[r]=n}else null!==n&&(e[r]=n)}),e}mergeRemovals(e,t){this.logger.trace("Remove updated entries in cache");const r=e.Account?this.mergeRemovalsDict(e.Account,t.Account):e.Account,n=e.AccessToken?this.mergeRemovalsDict(e.AccessToken,t.AccessToken):e.AccessToken,i=e.RefreshToken?this.mergeRemovalsDict(e.RefreshToken,t.RefreshToken):e.RefreshToken,o=e.IdToken?this.mergeRemovalsDict(e.IdToken,t.IdToken):e.IdToken,s=e.AppMetadata?this.mergeRemovalsDict(e.AppMetadata,t.AppMetadata):e.AppMetadata;return{...e,Account:r,AccessToken:n,RefreshToken:i,IdToken:o,AppMetadata:s}}mergeRemovalsDict(e,t){const r={...e};return Object.keys(e).forEach(e=>{t&&t.hasOwnProperty(e)||delete r[e]}),r}overlayDefaults(e){return this.logger.trace("Overlaying input cache with the default cache"),{Account:{...R,...e.Account},IdToken:{...M,...e.IdToken},AccessToken:{..._,...e.AccessToken},RefreshToken:{...O,...e.RefreshToken},AppMetadata:{...P,...e.AppMetadata}}}}class x{constructor(e){this.config=T(e),this.cryptoProvider=new v,this.logger=new n.Logger(this.config.system.loggerOptions,"@azure/msal-node","1.13.0"),this.storage=new S(this.logger,this.config.auth.clientId,this.cryptoProvider),this.tokenCache=new q(this.storage,this.logger,this.config.cache.cachePlugin)}async getAuthCodeUrl(e){this.logger.info("getAuthCodeUrl called",e.correlationId);const t={...e,...await this.initializeBaseRequest(e),responseMode:e.responseMode||n.ResponseMode.QUERY,authenticationScheme:n.AuthenticationScheme.BEARER},r=await this.buildOauthClientConfiguration(t.authority,t.correlationId,void 0,void 0,e.azureCloudOptions),i=new n.AuthorizationCodeClient(r);return this.logger.verbose("Auth code client created",t.correlationId),i.getAuthCodeUrl(t)}async acquireTokenByCode(e,t){this.logger.info("acquireTokenByCode called",e.correlationId);const r={...e,...await this.initializeBaseRequest(e),authenticationScheme:n.AuthenticationScheme.BEARER},i=this.initializeServerTelemetryManager(u.acquireTokenByCode,r.correlationId);try{const o=await this.buildOauthClientConfiguration(r.authority,r.correlationId,i,void 0,e.azureCloudOptions),s=new n.AuthorizationCodeClient(o);return this.logger.verbose("Auth code client created",r.correlationId),s.acquireToken(r,t)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(r.correlationId),i.cacheFailedRequest(e),e}}async acquireTokenByRefreshToken(e){this.logger.info("acquireTokenByRefreshToken called",e.correlationId);const t={...e,...await this.initializeBaseRequest(e),authenticationScheme:n.AuthenticationScheme.BEARER},r=this.initializeServerTelemetryManager(u.acquireTokenByRefreshToken,t.correlationId);try{const i=await this.buildOauthClientConfiguration(t.authority,t.correlationId,r,void 0,e.azureCloudOptions),o=new n.RefreshTokenClient(i);return this.logger.verbose("Refresh token client created",t.correlationId),o.acquireToken(t)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(t.correlationId),r.cacheFailedRequest(e),e}}async acquireTokenSilent(e){const t={...e,...await this.initializeBaseRequest(e),forceRefresh:e.forceRefresh||!1},r=this.initializeServerTelemetryManager(u.acquireTokenSilent,t.correlationId,t.forceRefresh);try{const i=await this.buildOauthClientConfiguration(t.authority,t.correlationId,r,void 0,e.azureCloudOptions),o=new n.SilentFlowClient(i);return this.logger.verbose("Silent flow client created",t.correlationId),o.acquireToken(t)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(t.correlationId),r.cacheFailedRequest(e),e}}async acquireTokenByUsernamePassword(e){this.logger.info("acquireTokenByUsernamePassword called",e.correlationId);const t={...e,...await this.initializeBaseRequest(e)},r=this.initializeServerTelemetryManager(u.acquireTokenByUsernamePassword,t.correlationId);try{const i=await this.buildOauthClientConfiguration(t.authority,t.correlationId,r,void 0,e.azureCloudOptions),o=new n.UsernamePasswordClient(i);return this.logger.verbose("Username password client created",t.correlationId),o.acquireToken(t)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(t.correlationId),r.cacheFailedRequest(e),e}}getTokenCache(){return this.logger.info("getTokenCache called"),this.tokenCache}getLogger(){return this.logger}setLogger(e){this.logger=e}async buildOauthClientConfiguration(e,t,r,i,o){this.logger.verbose("buildOauthClientConfiguration called",t);const s=o||this.config.auth.azureCloudOptions;this.logger.verbose("building oauth client configuration with the authority: "+e,t);const a=await this.createAuthority(e,i,t,s);return null==r||r.updateRegionDiscoveryMetadata(a.regionDiscoveryMetadata),{authOptions:{clientId:this.config.auth.clientId,authority:a,clientCapabilities:this.config.auth.clientCapabilities},systemOptions:{proxyUrl:this.config.system.proxyUrl},loggerOptions:{logLevel:this.config.system.loggerOptions.logLevel,loggerCallback:this.config.system.loggerOptions.loggerCallback,piiLoggingEnabled:this.config.system.loggerOptions.piiLoggingEnabled,correlationId:t},cryptoInterface:this.cryptoProvider,networkInterface:this.config.system.networkClient,storageInterface:this.storage,serverTelemetryManager:r,clientCredentials:{clientSecret:this.clientSecret,clientAssertion:this.clientAssertion?this.getClientAssertion(a):void 0},libraryInfo:{sku:"msal.js.node",version:"1.13.0",cpu:process.arch||n.Constants.EMPTY_STRING,os:process.platform||n.Constants.EMPTY_STRING},telemetry:this.config.telemetry,persistencePlugin:this.config.cache.cachePlugin,serializableCache:this.tokenCache}}getClientAssertion(e){return{assertion:this.clientAssertion.getJwt(this.cryptoProvider,this.config.auth.clientId,e.tokenEndpoint),assertionType:"urn:ietf:params:oauth:client-assertion-type:jwt-bearer"}}async initializeBaseRequest(e){return this.logger.verbose("initializeRequestScopes called",e.correlationId),e.authenticationScheme&&e.authenticationScheme===n.AuthenticationScheme.POP&&this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request",e.correlationId),e.authenticationScheme=n.AuthenticationScheme.BEARER,e.claims&&!n.StringUtils.isEmpty(e.claims)&&(e.requestedClaimsHash=await this.cryptoProvider.hashString(e.claims)),{...e,scopes:[...e&&e.scopes||[],...n.OIDC_DEFAULT_SCOPES],correlationId:e&&e.correlationId||this.cryptoProvider.createNewGuid(),authority:e.authority||this.config.auth.authority}}initializeServerTelemetryManager(e,t,r){return new n.ServerTelemetryManager({clientId:this.config.auth.clientId,correlationId:t,apiId:e,forceRefresh:r||!1},this.storage)}async createAuthority(e,t,r,i){this.logger.verbose("createAuthority called",r);const o=n.Authority.generateAuthority(e,i),s={protocolMode:this.config.auth.protocolMode,knownAuthorities:this.config.auth.knownAuthorities,cloudDiscoveryMetadata:this.config.auth.cloudDiscoveryMetadata,authorityMetadata:this.config.auth.authorityMetadata,azureRegionConfiguration:t,skipAuthorityMetadataCache:this.config.auth.skipAuthorityMetadataCache};return await n.AuthorityFactory.createDiscoveredInstance(o,this.config.system.networkClient,this.storage,s,this.config.system.proxyUrl)}clearCache(){this.storage.clear()}}class z extends n.AuthError{constructor(e,t){super(e,t),this.name="NodeAuthError"}static createInvalidLoopbackAddressTypeError(){return new z("invalid_loopback_server_address_type","Loopback server address is not type string. This is unexpected.")}static createUnableToLoadRedirectUrlError(){return new z("unable_to_load_redirectUrl","Loopback server callback was invoked without a url. This is unexpected.")}static createNoAuthCodeInResponseError(){return new z("no_auth_code_in_response","No auth code found in the server response. Please check your network trace to determine what happened.")}static createNoLoopbackServerExistsError(){return new z("no_loopback_server_exists","No loopback server exists yet.")}static createLoopbackServerAlreadyExistsError(){return new z("loopback_server_already_exists","Loopback server already exists. Cannot create another.")}static createLoopbackServerTimeoutError(){return new z("loopback_server_timeout","Timed out waiting for auth code listener to be registered.")}}class U{async listenForAuthCode(e,t){if(this.server)throw z.createLoopbackServerAlreadyExistsError();const o=new Promise((o,s)=>{this.server=i.createServer(async(i,a)=>{const c=i.url;if(!c)return a.end(t||"Error occurred loading redirectUrl"),void s(z.createUnableToLoadRedirectUrlError());if(c===n.Constants.FORWARD_SLASH)return void a.end(e||"Auth code was successfully acquired. You can close this window now.");const l=n.UrlString.getDeserializedQueryString(c);if(l.code){const e=await this.getRedirectUri();a.writeHead(r.REDIRECT,{location:e}),a.end()}o(l)}),this.server.listen(0)});return await new Promise(e=>{let t=0;const r=setInterval(()=>{if(50<t)throw z.createLoopbackServerTimeoutError();this.server.listening&&(clearInterval(r),e()),t++},100)}),o}getRedirectUri(){if(!this.server)throw z.createNoLoopbackServerExistsError();const e=this.server.address();if(!e||"string"==typeof e||!e.port)throw this.closeServer(),z.createInvalidLoopbackAddressTypeError();return"http://localhost:"+(e&&e.port)}closeServer(){this.server&&this.server.close()}}class j{static fromAssertion(e){const t=new j;return t.jwt=e,t}static fromCertificate(e,t,r){const n=new j;return n.privateKey=t,n.thumbprint=e,r&&(n.publicCertificate=this.parseCertificate(r)),n}getJwt(e,t,r){if(this.privateKey&&this.thumbprint)return this.jwt&&!this.isExpired()&&t===this.issuer&&r===this.jwtAudience?this.jwt:this.createJwt(e,t,r);if(this.jwt)return this.jwt;throw n.ClientAuthError.createInvalidAssertionError()}createJwt(e,t,r){this.issuer=t,this.jwtAudience=r;const i=n.TimeUtils.nowSeconds();this.expirationTime=i+600;const o={alg:"RS256",x5t:k.base64EncodeUrl(this.thumbprint,"hex")};this.publicCertificate&&Object.assign(o,{x5c:this.publicCertificate});const s={aud:this.jwtAudience,exp:this.expirationTime,iss:this.issuer,sub:this.issuer,nbf:i,jti:e.createNewGuid()};return this.jwt=l.sign(s,this.privateKey,{header:o}),this.jwt}isExpired(){return this.expirationTime<n.TimeUtils.nowSeconds()}static parseCertificate(e){const t=/-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs,r=[];let i;for(;null!==(i=t.exec(e));)r.push(i[1].replace(/\r*\n/g,n.Constants.EMPTY_STRING));return r}}Object.defineProperty(exports, "AuthError", ({enumerable:!0,get:function(){return n.AuthError}})),Object.defineProperty(exports, "AuthErrorMessage", ({enumerable:!0,get:function(){return n.AuthErrorMessage}})),Object.defineProperty(exports, "AzureCloudInstance", ({enumerable:!0,get:function(){return n.AzureCloudInstance}})),Object.defineProperty(exports, "ClientAuthError", ({enumerable:!0,get:function(){return n.ClientAuthError}})),Object.defineProperty(exports, "ClientAuthErrorMessage", ({enumerable:!0,get:function(){return n.ClientAuthErrorMessage}})),Object.defineProperty(exports, "ClientConfigurationError", ({enumerable:!0,get:function(){return n.ClientConfigurationError}})),Object.defineProperty(exports, "ClientConfigurationErrorMessage", ({enumerable:!0,get:function(){return n.ClientConfigurationErrorMessage}})),Object.defineProperty(exports, "InteractionRequiredAuthError", ({enumerable:!0,get:function(){return n.InteractionRequiredAuthError}})),Object.defineProperty(exports, "InteractionRequiredAuthErrorMessage", ({enumerable:!0,get:function(){return n.InteractionRequiredAuthErrorMessage}})),Object.defineProperty(exports, "LogLevel", ({enumerable:!0,get:function(){return n.LogLevel}})),Object.defineProperty(exports, "Logger", ({enumerable:!0,get:function(){return n.Logger}})),Object.defineProperty(exports, "PromptValue", ({enumerable:!0,get:function(){return n.PromptValue}})),Object.defineProperty(exports, "ProtocolMode", ({enumerable:!0,get:function(){return n.ProtocolMode}})),Object.defineProperty(exports, "ResponseMode", ({enumerable:!0,get:function(){return n.ResponseMode}})),Object.defineProperty(exports, "ServerError", ({enumerable:!0,get:function(){return n.ServerError}})),Object.defineProperty(exports, "TokenCacheContext", ({enumerable:!0,get:function(){return n.TokenCacheContext}})),exports.ClientApplication=x,exports.ClientAssertion=j,exports.ConfidentialClientApplication=class extends x{constructor(e){super(e),this.setClientCredential(this.config),this.appTokenProvider=void 0}SetAppTokenProvider(e){this.appTokenProvider=e}async acquireTokenByClientCredential(e){let t;this.logger.info("acquireTokenByClientCredential called",e.correlationId),e.clientAssertion&&(t={assertion:e.clientAssertion,assertionType:"urn:ietf:params:oauth:client-assertion-type:jwt-bearer"});const r={...e,...await this.initializeBaseRequest(e),clientAssertion:t},i={azureRegion:r.azureRegion,environmentRegion:process.env.REGION_NAME},o=this.initializeServerTelemetryManager(u.acquireTokenByClientCredential,r.correlationId,r.skipCache);try{const t=await this.buildOauthClientConfiguration(r.authority,r.correlationId,o,i,e.azureCloudOptions),s=new n.ClientCredentialClient(t,this.appTokenProvider);return this.logger.verbose("Client credential client created",r.correlationId),s.acquireToken(r)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(r.correlationId),o.cacheFailedRequest(e),e}}async acquireTokenOnBehalfOf(e){this.logger.info("acquireTokenOnBehalfOf called",e.correlationId);const t={...e,...await this.initializeBaseRequest(e)};try{const r=await this.buildOauthClientConfiguration(t.authority,t.correlationId,void 0,void 0,e.azureCloudOptions),i=new n.OnBehalfOfClient(r);return this.logger.verbose("On behalf of client created",t.correlationId),i.acquireToken(t)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(t.correlationId),e}}setClientCredential(e){const t=!n.StringUtils.isEmpty(e.auth.clientSecret),r=!n.StringUtils.isEmpty(e.auth.clientAssertion),i=e.auth.clientCertificate||{thumbprint:n.Constants.EMPTY_STRING,privateKey:n.Constants.EMPTY_STRING},o=!n.StringUtils.isEmpty(i.thumbprint)||!n.StringUtils.isEmpty(i.privateKey);if(!this.appTokenProvider){if(t&&r||r&&o||t&&o)throw n.ClientAuthError.createInvalidCredentialError();if(e.auth.clientSecret)this.clientSecret=e.auth.clientSecret;else if(e.auth.clientAssertion)this.clientAssertion=j.fromAssertion(e.auth.clientAssertion);else{if(!o)throw n.ClientAuthError.createInvalidCredentialError();var s;this.clientAssertion=j.fromCertificate(i.thumbprint,i.privateKey,null==(s=e.auth.clientCertificate)?void 0:s.x5c)}}}},exports.CryptoProvider=v,exports.DistributedCachePlugin=class{constructor(e,t){this.client=e,this.partitionManager=t}async beforeCacheAccess(e){const t=await this.partitionManager.getKey(),r=await this.client.get(t);e.tokenCache.deserialize(r)}async afterCacheAccess(e){if(e.cacheHasChanged){const t=e.tokenCache.getKVStore(),r=Object.values(t).filter(e=>n.AccountEntity.isAccountEntity(e));if(r.length>0){const t=r[0],n=await this.partitionManager.extractKey(t);await this.client.set(n,e.tokenCache.serialize())}}}},exports.NodeStorage=S,exports.PublicClientApplication=class extends x{constructor(e){super(e)}async acquireTokenByDeviceCode(e){this.logger.info("acquireTokenByDeviceCode called",e.correlationId);const t=Object.assign(e,await this.initializeBaseRequest(e)),r=this.initializeServerTelemetryManager(u.acquireTokenByDeviceCode,t.correlationId);try{const i=await this.buildOauthClientConfiguration(t.authority,t.correlationId,r,void 0,e.azureCloudOptions),o=new n.DeviceCodeClient(i);return this.logger.verbose("Device code client created",t.correlationId),o.acquireToken(t)}catch(e){throw e instanceof n.AuthError&&e.setCorrelationId(t.correlationId),r.cacheFailedRequest(e),e}}async acquireTokenInteractive(e){const{verifier:t,challenge:r}=await this.cryptoProvider.generatePkceCodes(),{openBrowser:i,successTemplate:o,errorTemplate:s,...a}=e,c=new U,l=c.listenForAuthCode(o,s),h=c.getRedirectUri(),u={...a,scopes:e.scopes||[],redirectUri:h,responseMode:n.ResponseMode.QUERY,codeChallenge:r,codeChallengeMethod:n.CodeChallengeMethodValues.S256},d=await this.getAuthCodeUrl(u);await i(d);const g=await l.finally(()=>{c.closeServer()});if(g.error)throw new n.ServerError(g.error,g.error_description,g.suberror);if(!g.code)throw z.createNoAuthCodeInResponseError();return this.acquireTokenByCode({code:g.code,scopes:n.OIDC_DEFAULT_SCOPES,redirectUri:u.redirectUri,codeVerifier:t,clientInfo:g.client_info||n.Constants.EMPTY_STRING})}},exports.TokenCache=q,exports.buildAppConfiguration=T,exports.version="1.13.0";
//# sourceMappingURL=msal-node.cjs.production.min.js.map


/***/ }),

/***/ 9457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function once(emitter, name, { signal } = {}) {
    return new Promise((resolve, reject) => {
        function cleanup() {
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', cleanup);
            emitter.removeListener(name, onEvent);
            emitter.removeListener('error', onError);
        }
        function onEvent(...args) {
            cleanup();
            resolve(args);
        }
        function onError(err) {
            cleanup();
            reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', cleanup);
        emitter.on(name, onEvent);
        emitter.on('error', onError);
    });
}
exports["default"] = once;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5033:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const events_1 = __nccwpck_require__(2361);
const debug_1 = __importDefault(__nccwpck_require__(7606));
const promisify_1 = __importDefault(__nccwpck_require__(3997));
const debug = debug_1.default('agent-base');
function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string')
        return false;
    return stack.split('\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function (createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */
    class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
            super();
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            }
            else if (callback) {
                opts = callback;
            }
            // Timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            // These aren't actually used by `agent-base`, but are required
            // for the TypeScript definition files in `@types/node` :/
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.maxTotalSockets = Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
            this.options = {};
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            return isSecureEndpoint() ? 'https:' : 'http:';
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
            const opts = Object.assign({}, _opts);
            if (typeof opts.secureEndpoint !== 'boolean') {
                opts.secureEndpoint = isSecureEndpoint();
            }
            if (opts.host == null) {
                opts.host = 'localhost';
            }
            if (opts.port == null) {
                opts.port = opts.secureEndpoint ? 443 : 80;
            }
            if (opts.protocol == null) {
                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
            }
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most
                // likely the result of a `url.parse()` call... we need to
                // remove the `path` portion so that `net.connect()` doesn't
                // attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts.timeout || this.timeout;
            const onerror = (err) => {
                if (req._hadError)
                    return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            };
            const ontimeout = () => {
                timeoutId = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            };
            const callbackError = (err) => {
                if (timedOut)
                    return;
                if (timeoutId !== null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                onerror(err);
            };
            const onsocket = (socket) => {
                if (timedOut)
                    return;
                if (timeoutId != null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                if (isAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    debug('Callback returned another Agent instance %o', socket.constructor.name);
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    socket.once('free', () => {
                        this.freeSocket(socket, opts);
                    });
                    req.onSocket(socket);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            };
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    debug('Converting legacy callback function to promise');
                    this.promisifiedCallback = promisify_1.default(this.callback);
                }
                else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            }
            catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            debug('Freeing socket %o %o', socket.constructor.name, opts);
            socket.destroy();
        }
        destroy() {
            debug('Destroying agent %o', this.constructor.name);
        }
    }
    createAgent.Agent = Agent;
    // So that `instanceof` works correctly
    createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));
module.exports = createAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3997:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function promisify(fn) {
    return function (req, opts) {
        return new Promise((resolve, reject) => {
            fn.call(this, req, opts, (err, rtn) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports["default"] = promisify;
//# sourceMappingURL=promisify.js.map

/***/ }),

/***/ 8690:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports =
{
  parallel      : __nccwpck_require__(5232),
  serial        : __nccwpck_require__(265),
  serialOrdered : __nccwpck_require__(741)
};


/***/ }),

/***/ 3380:
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ 8712:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var defer = __nccwpck_require__(7016);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ 7016:
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ 3347:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var async = __nccwpck_require__(8712)
  , abort = __nccwpck_require__(3380)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ 3882:
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ 4636:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var abort = __nccwpck_require__(3380)
  , async = __nccwpck_require__(8712)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ 5232:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(3347)
  , initState  = __nccwpck_require__(3882)
  , terminator = __nccwpck_require__(4636)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ 265:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var serialOrdered = __nccwpck_require__(741);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ 741:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(3347)
  , initState  = __nccwpck_require__(3882)
  , terminator = __nccwpck_require__(4636)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ 4558:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*jshint node:true */

var Buffer = (__nccwpck_require__(4300).Buffer); // browserify
var SlowBuffer = (__nccwpck_require__(4300).SlowBuffer);

module.exports = bufferEq;

function bufferEq(a, b) {

  // shortcutting on type is necessary for correctness
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    return false;
  }

  // buffer sizes should be well-known information, so despite this
  // shortcutting, it doesn't leak any information about the *contents* of the
  // buffers.
  if (a.length !== b.length) {
    return false;
  }

  var c = 0;
  for (var i = 0; i < a.length; i++) {
    /*jshint bitwise:false */
    c |= a[i] ^ b[i]; // XOR
  }
  return c === 0;
}

bufferEq.install = function() {
  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
    return bufferEq(this, that);
  };
};

var origBufEqual = Buffer.prototype.equal;
var origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer.prototype.equal = origBufEqual;
  SlowBuffer.prototype.equal = origSlowBufEqual;
};


/***/ }),

/***/ 5742:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(3837);
var Stream = (__nccwpck_require__(2781).Stream);
var DelayedStream = __nccwpck_require__(2065);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ 7887:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(3735)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 3735:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(725);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 7606:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(7887);
} else {
	module.exports = __nccwpck_require__(4350);
}


/***/ }),

/***/ 4350:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(6224);
const util = __nccwpck_require__(3837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(3259);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(3735)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 2159:
/***/ ((module) => {

"use strict";

module.exports = (object, propertyName, fn) => {
	const define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});

	Object.defineProperty(object, propertyName, {
		configurable: true,
		enumerable: true,
		get() {
			const result = fn();
			define(result);
			return result;
		},
		set(value) {
			define(value);
		}
	});

	return object;
};


/***/ }),

/***/ 2065:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stream = (__nccwpck_require__(2781).Stream);
var util = __nccwpck_require__(3837);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ 328:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Buffer = (__nccwpck_require__(7931).Buffer);

var getParamBytesForAlg = __nccwpck_require__(9140);

var MAX_OCTET = 0x80,
	CLASS_UNIVERSAL = 0,
	PRIMITIVE_BIT = 0x20,
	TAG_SEQ = 0x10,
	TAG_INT = 0x02,
	ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
	ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

function base64Url(base64) {
	return base64
		.replace(/=/g, '')
		.replace(/\+/g, '-')
		.replace(/\//g, '_');
}

function signatureAsBuffer(signature) {
	if (Buffer.isBuffer(signature)) {
		return signature;
	} else if ('string' === typeof signature) {
		return Buffer.from(signature, 'base64');
	}

	throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
}

function derToJose(signature, alg) {
	signature = signatureAsBuffer(signature);
	var paramBytes = getParamBytesForAlg(alg);

	// the DER encoded param should at most be the param size, plus a padding
	// zero, since due to being a signed integer
	var maxEncodedParamLength = paramBytes + 1;

	var inputLength = signature.length;

	var offset = 0;
	if (signature[offset++] !== ENCODED_TAG_SEQ) {
		throw new Error('Could not find expected "seq"');
	}

	var seqLength = signature[offset++];
	if (seqLength === (MAX_OCTET | 1)) {
		seqLength = signature[offset++];
	}

	if (inputLength - offset < seqLength) {
		throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
	}

	if (signature[offset++] !== ENCODED_TAG_INT) {
		throw new Error('Could not find expected "int" for "r"');
	}

	var rLength = signature[offset++];

	if (inputLength - offset - 2 < rLength) {
		throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
	}

	if (maxEncodedParamLength < rLength) {
		throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
	}

	var rOffset = offset;
	offset += rLength;

	if (signature[offset++] !== ENCODED_TAG_INT) {
		throw new Error('Could not find expected "int" for "s"');
	}

	var sLength = signature[offset++];

	if (inputLength - offset !== sLength) {
		throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
	}

	if (maxEncodedParamLength < sLength) {
		throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
	}

	var sOffset = offset;
	offset += sLength;

	if (offset !== inputLength) {
		throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
	}

	var rPadding = paramBytes - rLength,
		sPadding = paramBytes - sLength;

	var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);

	for (offset = 0; offset < rPadding; ++offset) {
		dst[offset] = 0;
	}
	signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

	offset = paramBytes;

	for (var o = offset; offset < o + sPadding; ++offset) {
		dst[offset] = 0;
	}
	signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

	dst = dst.toString('base64');
	dst = base64Url(dst);

	return dst;
}

function countPadding(buf, start, stop) {
	var padding = 0;
	while (start + padding < stop && buf[start + padding] === 0) {
		++padding;
	}

	var needsSign = buf[start + padding] >= MAX_OCTET;
	if (needsSign) {
		--padding;
	}

	return padding;
}

function joseToDer(signature, alg) {
	signature = signatureAsBuffer(signature);
	var paramBytes = getParamBytesForAlg(alg);

	var signatureBytes = signature.length;
	if (signatureBytes !== paramBytes * 2) {
		throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
	}

	var rPadding = countPadding(signature, 0, paramBytes);
	var sPadding = countPadding(signature, paramBytes, signature.length);
	var rLength = paramBytes - rPadding;
	var sLength = paramBytes - sPadding;

	var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

	var shortLength = rsBytes < MAX_OCTET;

	var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

	var offset = 0;
	dst[offset++] = ENCODED_TAG_SEQ;
	if (shortLength) {
		// Bit 8 has value "0"
		// bits 7-1 give the length.
		dst[offset++] = rsBytes;
	} else {
		// Bit 8 of first octet has value "1"
		// bits 7-1 give the number of additional length octets.
		dst[offset++] = MAX_OCTET	| 1;
		// length, base 256
		dst[offset++] = rsBytes & 0xff;
	}
	dst[offset++] = ENCODED_TAG_INT;
	dst[offset++] = rLength;
	if (rPadding < 0) {
		dst[offset++] = 0;
		offset += signature.copy(dst, offset, 0, paramBytes);
	} else {
		offset += signature.copy(dst, offset, rPadding, paramBytes);
	}
	dst[offset++] = ENCODED_TAG_INT;
	dst[offset++] = sLength;
	if (sPadding < 0) {
		dst[offset++] = 0;
		signature.copy(dst, offset, paramBytes);
	} else {
		signature.copy(dst, offset, paramBytes + sPadding);
	}

	return dst;
}

module.exports = {
	derToJose: derToJose,
	joseToDer: joseToDer
};


/***/ }),

/***/ 9140:
/***/ ((module) => {

"use strict";


function getParamSize(keySize) {
	var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
	return result;
}

var paramBytesForAlg = {
	ES256: getParamSize(256),
	ES384: getParamSize(384),
	ES512: getParamSize(521)
};

function getParamBytesForAlg(alg) {
	var paramBytes = paramBytesForAlg[alg];
	if (paramBytes) {
		return paramBytes;
	}

	throw new Error('Unknown algorithm "' + alg + '"');
}

module.exports = getParamBytesForAlg;


/***/ }),

/***/ 489:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var CombinedStream = __nccwpck_require__(5742);
var util = __nccwpck_require__(3837);
var path = __nccwpck_require__(1017);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var parseUrl = (__nccwpck_require__(7310).parse);
var fs = __nccwpck_require__(7147);
var Stream = (__nccwpck_require__(2781).Stream);
var mime = __nccwpck_require__(1051);
var asynckit = __nccwpck_require__(8690);
var populate = __nccwpck_require__(7864);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ 7864:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 2579:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __importDefault(__nccwpck_require__(1808));
const tls_1 = __importDefault(__nccwpck_require__(4404));
const url_1 = __importDefault(__nccwpck_require__(7310));
const debug_1 = __importDefault(__nccwpck_require__(7606));
const once_1 = __importDefault(__nccwpck_require__(9457));
const agent_base_1 = __nccwpck_require__(5033);
const debug = (0, debug_1.default)('http-proxy-agent');
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
/**
 * The `HttpProxyAgent` implements an HTTP Agent subclass that connects
 * to the specified "HTTP proxy server" in order to proxy HTTP requests.
 *
 * @api public
 */
class HttpProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('Creating new HttpProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            const parsed = url_1.default.parse(req.path);
            if (!parsed.protocol) {
                parsed.protocol = 'http:';
            }
            if (!parsed.hostname) {
                parsed.hostname = opts.hostname || opts.host || null;
            }
            if (parsed.port == null && typeof opts.port) {
                parsed.port = String(opts.port);
            }
            if (parsed.port === '80') {
                // if port is 80, then we can remove the port so that the
                // ":80" portion is not on the produced URL
                parsed.port = '';
            }
            // Change the `http.ClientRequest` instance's "path" field
            // to the absolute path of the URL that will be requested.
            req.path = url_1.default.format(parsed);
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                req.setHeader('Proxy-Authorization', `Basic ${Buffer.from(proxy.auth).toString('base64')}`);
            }
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            // At this point, the http ClientRequest's internal `_header` field
            // might have already been set. If this is the case then we'll need
            // to re-generate the string since we just changed the `req.path`.
            if (req._header) {
                let first;
                let endOfHeaders;
                debug('Regenerating stored HTTP header string for request');
                req._header = null;
                req._implicitHeader();
                if (req.output && req.output.length > 0) {
                    // Node < 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.output[0];
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.output[0] = req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.output);
                }
                else if (req.outputData && req.outputData.length > 0) {
                    // Node >= 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.outputData[0].data;
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.outputData[0].data =
                        req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.outputData[0].data);
                }
            }
            // Wait for the socket's `connect` event, so that this `callback()`
            // function throws instead of the `http` request machinery. This is
            // important for i.e. `PacProxyAgent` which determines a failed proxy
            // connection via the `callback()` function throwing.
            yield (0, once_1.default)(socket, 'connect');
            return socket;
        });
    }
}
exports["default"] = HttpProxyAgent;
//# sourceMappingURL=agent.js.map

/***/ }),

/***/ 9242:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__nccwpck_require__(2579));
function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpProxyAgent) {
    createHttpProxyAgent.HttpProxyAgent = agent_1.default;
    createHttpProxyAgent.prototype = agent_1.default.prototype;
})(createHttpProxyAgent || (createHttpProxyAgent = {}));
module.exports = createHttpProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1430:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __importDefault(__nccwpck_require__(1808));
const tls_1 = __importDefault(__nccwpck_require__(4404));
const url_1 = __importDefault(__nccwpck_require__(7310));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const debug_1 = __importDefault(__nccwpck_require__(7606));
const agent_base_1 = __nccwpck_require__(5033);
const parse_proxy_response_1 = __importDefault(__nccwpck_require__(8238));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */
class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) {
            proxy.ALPNProtocols = ['http 1.1'];
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts.host}:${opts.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;
            }
            // The `Host` header should only include the port
            // number when it is not the default port.
            let { host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) {
                host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)) {
                payload += `${name}: ${headers[name]}\r\n`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r\n`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
                req.once('socket', resume);
                if (opts.secureEndpoint) {
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    const servername = opts.servername || opts.host;
                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,
                        servername }));
                }
                return socket;
            }
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket({ writable: false });
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s) => {
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
            });
            return fakeSocket;
        });
    }
}
exports["default"] = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function isDefaultPort(port, secure) {
    return Boolean((!secure && port === 80) || (secure && port === 443));
}
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
}
//# sourceMappingURL=agent.js.map

/***/ }),

/***/ 5557:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__nccwpck_require__(1430));
function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent.prototype = agent_1.default.prototype;
})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
module.exports = createHttpsProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8238:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__nccwpck_require__(7606));
const debug = debug_1.default('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b)
                ondata(b);
            else
                socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('close', onclose);
            socket.removeListener('readable', read);
        }
        function onclose(err) {
            debug('onclose had error %o', err);
        }
        function onend() {
            debug('onend');
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\r\n'));
            const statusCode = +firstLine.split(' ')[1];
            debug('got proxy server response: %o', firstLine);
            resolve({
                statusCode,
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('close', onclose);
        socket.on('end', onend);
        read();
    });
}
exports["default"] = parseProxyResponse;
//# sourceMappingURL=parse-proxy-response.js.map

/***/ }),

/***/ 106:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const fs = __nccwpck_require__(7147);

let isDocker;

function hasDockerEnv() {
	try {
		fs.statSync('/.dockerenv');
		return true;
	} catch (_) {
		return false;
	}
}

function hasDockerCGroup() {
	try {
		return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
	} catch (_) {
		return false;
	}
}

module.exports = () => {
	if (isDocker === undefined) {
		isDocker = hasDockerEnv() || hasDockerCGroup();
	}

	return isDocker;
};


/***/ }),

/***/ 9407:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2037);
const fs = __nccwpck_require__(7147);
const isDocker = __nccwpck_require__(106);

const isWsl = () => {
	if (process.platform !== 'linux') {
		return false;
	}

	if (os.release().toLowerCase().includes('microsoft')) {
		if (isDocker()) {
			return false;
		}

		return true;
	}

	try {
		return fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ?
			!isDocker() : false;
	} catch (_) {
		return false;
	}
};

if (process.env.__IS_WSL_TEST__) {
	module.exports = isWsl;
} else {
	module.exports = isWsl();
}


/***/ }),

/***/ 3497:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var jws = __nccwpck_require__(3579);

module.exports = function (jwt, options) {
  options = options || {};
  var decoded = jws.decode(jwt, options);
  if (!decoded) { return null; }
  var payload = decoded.payload;

  //try parse the payload
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(obj !== null && typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }

  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (options.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  return payload;
};


/***/ }),

/***/ 3610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
  decode: __nccwpck_require__(3497),
  verify: __nccwpck_require__(5898),
  sign: __nccwpck_require__(4849),
  JsonWebTokenError: __nccwpck_require__(9528),
  NotBeforeError: __nccwpck_require__(2536),
  TokenExpiredError: __nccwpck_require__(2178),
};


/***/ }),

/***/ 9528:
/***/ ((module) => {

var JsonWebTokenError = function (message, error) {
  Error.call(this, message);
  if(Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
};

JsonWebTokenError.prototype = Object.create(Error.prototype);
JsonWebTokenError.prototype.constructor = JsonWebTokenError;

module.exports = JsonWebTokenError;


/***/ }),

/***/ 2536:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var JsonWebTokenError = __nccwpck_require__(9528);

var NotBeforeError = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
};

NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

NotBeforeError.prototype.constructor = NotBeforeError;

module.exports = NotBeforeError;

/***/ }),

/***/ 2178:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var JsonWebTokenError = __nccwpck_require__(9528);

var TokenExpiredError = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
};

TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

TokenExpiredError.prototype.constructor = TokenExpiredError;

module.exports = TokenExpiredError;

/***/ }),

/***/ 6029:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var semver = __nccwpck_require__(9681);

module.exports = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');


/***/ }),

/***/ 9357:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ms = __nccwpck_require__(725);

module.exports = function (time, iat) {
  var timestamp = iat || Math.floor(Date.now() / 1000);

  if (typeof time === 'string') {
    var milliseconds = ms(time);
    if (typeof milliseconds === 'undefined') {
      return;
    }
    return Math.floor(timestamp + milliseconds / 1000);
  } else if (typeof time === 'number') {
    return timestamp + time;
  } else {
    return;
  }

};

/***/ }),

/***/ 9789:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var bufferEqual = __nccwpck_require__(4558);
var Buffer = (__nccwpck_require__(7931).Buffer);
var crypto = __nccwpck_require__(6113);
var formatEcdsa = __nccwpck_require__(328);
var util = __nccwpck_require__(3837);

var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".'
var MSG_INVALID_SECRET = 'secret must be a string or buffer';
var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
if (supportsKeyObjects) {
  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
  MSG_INVALID_SECRET += 'or a KeyObject';
}

function checkIsPublicKey(key) {
  if (Buffer.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return;
  }

  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key !== 'object') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.type !== 'string') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.asymmetricKeyType !== 'string') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.export !== 'function') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
};

function checkIsPrivateKey(key) {
  if (Buffer.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return;
  }

  if (typeof key === 'object') {
    return;
  }

  throw typeError(MSG_INVALID_SIGNER_KEY);
};

function checkIsSecretKey(key) {
  if (Buffer.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return key;
  }

  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (typeof key !== 'object') {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (key.type !== 'secret') {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (typeof key.export !== 'function') {
    throw typeError(MSG_INVALID_SECRET);
  }
}

function fromBase64(base64) {
  return base64
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function toBase64(base64url) {
  base64url = base64url.toString();

  var padding = 4 - base64url.length % 4;
  if (padding !== 4) {
    for (var i = 0; i < padding; ++i) {
      base64url += '=';
    }
  }

  return base64url
    .replace(/\-/g, '+')
    .replace(/_/g, '/');
}

function typeError(template) {
  var args = [].slice.call(arguments, 1);
  var errMsg = util.format.bind(util, template).apply(null, args);
  return new TypeError(errMsg);
}

function bufferOrString(obj) {
  return Buffer.isBuffer(obj) || typeof obj === 'string';
}

function normalizeInput(thing) {
  if (!bufferOrString(thing))
    thing = JSON.stringify(thing);
  return thing;
}

function createHmacSigner(bits) {
  return function sign(thing, secret) {
    checkIsSecretKey(secret);
    thing = normalizeInput(thing);
    var hmac = crypto.createHmac('sha' + bits, secret);
    var sig = (hmac.update(thing), hmac.digest('base64'))
    return fromBase64(sig);
  }
}

function createHmacVerifier(bits) {
  return function verify(thing, signature, secret) {
    var computedSig = createHmacSigner(bits)(thing, secret);
    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));
  }
}

function createKeySigner(bits) {
 return function sign(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    // Even though we are specifying "RSA" here, this works with ECDSA
    // keys as well.
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
    return fromBase64(sig);
  }
}

function createKeyVerifier(bits) {
  return function verify(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify(publicKey, signature, 'base64');
  }
}

function createPSSKeySigner(bits) {
  return function sign(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign({
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, 'base64'));
    return fromBase64(sig);
  }
}

function createPSSKeyVerifier(bits) {
  return function verify(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify({
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, signature, 'base64');
  }
}

function createECDSASigner(bits) {
  var inner = createKeySigner(bits);
  return function sign() {
    var signature = inner.apply(null, arguments);
    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
    return signature;
  };
}

function createECDSAVerifer(bits) {
  var inner = createKeyVerifier(bits);
  return function verify(thing, signature, publicKey) {
    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
    var result = inner(thing, signature, publicKey);
    return result;
  };
}

function createNoneSigner() {
  return function sign() {
    return '';
  }
}

function createNoneVerifier() {
  return function verify(thing, signature) {
    return signature === '';
  }
}

module.exports = function jwa(algorithm) {
  var signerFactories = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner,
  }
  var verifierFactories = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier,
  }
  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!match)
    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
  var algo = (match[1] || match[3]).toLowerCase();
  var bits = match[2];

  return {
    sign: signerFactories[algo](bits),
    verify: verifierFactories[algo](bits),
  }
};


/***/ }),

/***/ 3579:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/*global exports*/
var SignStream = __nccwpck_require__(5701);
var VerifyStream = __nccwpck_require__(3790);

var ALGORITHMS = [
  'HS256', 'HS384', 'HS512',
  'RS256', 'RS384', 'RS512',
  'PS256', 'PS384', 'PS512',
  'ES256', 'ES384', 'ES512'
];

exports.ALGORITHMS = ALGORITHMS;
exports.sign = SignStream.sign;
exports.verify = VerifyStream.verify;
exports.decode = VerifyStream.decode;
exports.isValid = VerifyStream.isValid;
exports.createSign = function createSign(opts) {
  return new SignStream(opts);
};
exports.createVerify = function createVerify(opts) {
  return new VerifyStream(opts);
};


/***/ }),

/***/ 8585:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*global module, process*/
var Buffer = (__nccwpck_require__(7931).Buffer);
var Stream = __nccwpck_require__(2781);
var util = __nccwpck_require__(3837);

function DataStream(data) {
  this.buffer = null;
  this.writable = true;
  this.readable = true;

  // No input
  if (!data) {
    this.buffer = Buffer.alloc(0);
    return this;
  }

  // Stream
  if (typeof data.pipe === 'function') {
    this.buffer = Buffer.alloc(0);
    data.pipe(this);
    return this;
  }

  // Buffer or String
  // or Object (assumedly a passworded key)
  if (data.length || typeof data === 'object') {
    this.buffer = data;
    this.writable = false;
    process.nextTick(function () {
      this.emit('end', data);
      this.readable = false;
      this.emit('close');
    }.bind(this));
    return this;
  }

  throw new TypeError('Unexpected data type ('+ typeof data + ')');
}
util.inherits(DataStream, Stream);

DataStream.prototype.write = function write(data) {
  this.buffer = Buffer.concat([this.buffer, Buffer.from(data)]);
  this.emit('data', data);
};

DataStream.prototype.end = function end(data) {
  if (data)
    this.write(data);
  this.emit('end', data);
  this.emit('close');
  this.writable = false;
  this.readable = false;
};

module.exports = DataStream;


/***/ }),

/***/ 5701:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*global module*/
var Buffer = (__nccwpck_require__(7931).Buffer);
var DataStream = __nccwpck_require__(8585);
var jwa = __nccwpck_require__(9789);
var Stream = __nccwpck_require__(2781);
var toString = __nccwpck_require__(6144);
var util = __nccwpck_require__(3837);

function base64url(string, encoding) {
  return Buffer
    .from(string, encoding)
    .toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function jwsSecuredInput(header, payload, encoding) {
  encoding = encoding || 'utf8';
  var encodedHeader = base64url(toString(header), 'binary');
  var encodedPayload = base64url(toString(payload), encoding);
  return util.format('%s.%s', encodedHeader, encodedPayload);
}

function jwsSign(opts) {
  var header = opts.header;
  var payload = opts.payload;
  var secretOrKey = opts.secret || opts.privateKey;
  var encoding = opts.encoding;
  var algo = jwa(header.alg);
  var securedInput = jwsSecuredInput(header, payload, encoding);
  var signature = algo.sign(securedInput, secretOrKey);
  return util.format('%s.%s', securedInput, signature);
}

function SignStream(opts) {
  var secret = opts.secret||opts.privateKey||opts.key;
  var secretStream = new DataStream(secret);
  this.readable = true;
  this.header = opts.header;
  this.encoding = opts.encoding;
  this.secret = this.privateKey = this.key = secretStream;
  this.payload = new DataStream(opts.payload);
  this.secret.once('close', function () {
    if (!this.payload.writable && this.readable)
      this.sign();
  }.bind(this));

  this.payload.once('close', function () {
    if (!this.secret.writable && this.readable)
      this.sign();
  }.bind(this));
}
util.inherits(SignStream, Stream);

SignStream.prototype.sign = function sign() {
  try {
    var signature = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    this.emit('done', signature);
    this.emit('data', signature);
    this.emit('end');
    this.readable = false;
    return signature;
  } catch (e) {
    this.readable = false;
    this.emit('error', e);
    this.emit('close');
  }
};

SignStream.sign = jwsSign;

module.exports = SignStream;


/***/ }),

/***/ 6144:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*global module*/
var Buffer = (__nccwpck_require__(4300).Buffer);

module.exports = function toString(obj) {
  if (typeof obj === 'string')
    return obj;
  if (typeof obj === 'number' || Buffer.isBuffer(obj))
    return obj.toString();
  return JSON.stringify(obj);
};


/***/ }),

/***/ 3790:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*global module*/
var Buffer = (__nccwpck_require__(7931).Buffer);
var DataStream = __nccwpck_require__(8585);
var jwa = __nccwpck_require__(9789);
var Stream = __nccwpck_require__(2781);
var toString = __nccwpck_require__(6144);
var util = __nccwpck_require__(3837);
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

function isObject(thing) {
  return Object.prototype.toString.call(thing) === '[object Object]';
}

function safeJsonParse(thing) {
  if (isObject(thing))
    return thing;
  try { return JSON.parse(thing); }
  catch (e) { return undefined; }
}

function headerFromJWS(jwsSig) {
  var encodedHeader = jwsSig.split('.', 1)[0];
  return safeJsonParse(Buffer.from(encodedHeader, 'base64').toString('binary'));
}

function securedInputFromJWS(jwsSig) {
  return jwsSig.split('.', 2).join('.');
}

function signatureFromJWS(jwsSig) {
  return jwsSig.split('.')[2];
}

function payloadFromJWS(jwsSig, encoding) {
  encoding = encoding || 'utf8';
  var payload = jwsSig.split('.')[1];
  return Buffer.from(payload, 'base64').toString(encoding);
}

function isValidJws(string) {
  return JWS_REGEX.test(string) && !!headerFromJWS(string);
}

function jwsVerify(jwsSig, algorithm, secretOrKey) {
  if (!algorithm) {
    var err = new Error("Missing algorithm parameter for jws.verify");
    err.code = "MISSING_ALGORITHM";
    throw err;
  }
  jwsSig = toString(jwsSig);
  var signature = signatureFromJWS(jwsSig);
  var securedInput = securedInputFromJWS(jwsSig);
  var algo = jwa(algorithm);
  return algo.verify(securedInput, signature, secretOrKey);
}

function jwsDecode(jwsSig, opts) {
  opts = opts || {};
  jwsSig = toString(jwsSig);

  if (!isValidJws(jwsSig))
    return null;

  var header = headerFromJWS(jwsSig);

  if (!header)
    return null;

  var payload = payloadFromJWS(jwsSig);
  if (header.typ === 'JWT' || opts.json)
    payload = JSON.parse(payload, opts.encoding);

  return {
    header: header,
    payload: payload,
    signature: signatureFromJWS(jwsSig)
  };
}

function VerifyStream(opts) {
  opts = opts || {};
  var secretOrKey = opts.secret||opts.publicKey||opts.key;
  var secretStream = new DataStream(secretOrKey);
  this.readable = true;
  this.algorithm = opts.algorithm;
  this.encoding = opts.encoding;
  this.secret = this.publicKey = this.key = secretStream;
  this.signature = new DataStream(opts.signature);
  this.secret.once('close', function () {
    if (!this.signature.writable && this.readable)
      this.verify();
  }.bind(this));

  this.signature.once('close', function () {
    if (!this.secret.writable && this.readable)
      this.verify();
  }.bind(this));
}
util.inherits(VerifyStream, Stream);
VerifyStream.prototype.verify = function verify() {
  try {
    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
    var obj = jwsDecode(this.signature.buffer, this.encoding);
    this.emit('done', valid, obj);
    this.emit('data', valid);
    this.emit('end');
    this.readable = false;
    return valid;
  } catch (e) {
    this.readable = false;
    this.emit('error', e);
    this.emit('close');
  }
};

VerifyStream.decode = jwsDecode;
VerifyStream.isValid = isValidJws;
VerifyStream.verify = jwsVerify;

module.exports = VerifyStream;


/***/ }),

/***/ 4849:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var timespan = __nccwpck_require__(9357);
var PS_SUPPORTED = __nccwpck_require__(6029);
var jws = __nccwpck_require__(3579);
var includes = __nccwpck_require__(7300);
var isBoolean = __nccwpck_require__(8672);
var isInteger = __nccwpck_require__(5394);
var isNumber = __nccwpck_require__(4341);
var isPlainObject = __nccwpck_require__(9822);
var isString = __nccwpck_require__(3604);
var once = __nccwpck_require__(4183);

var SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none']
if (PS_SUPPORTED) {
  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
}

var sign_options_schema = {
  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject, message: '"header" must be an object' },
  encoding: { isValid: isString, message: '"encoding" must be a string' },
  issuer: { isValid: isString, message: '"issuer" must be a string' },
  subject: { isValid: isString, message: '"subject" must be a string' },
  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
};

var registered_claims_schema = {
  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
};

function validate(schema, allowUnknown, object, parameterName) {
  if (!isPlainObject(object)) {
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
  }
  Object.keys(object)
    .forEach(function(key) {
      var validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
}

function validateOptions(options) {
  return validate(sign_options_schema, false, options, 'options');
}

function validatePayload(payload) {
  return validate(registered_claims_schema, true, payload, 'payload');
}

var options_to_payload = {
  'audience': 'aud',
  'issuer': 'iss',
  'subject': 'sub',
  'jwtid': 'jti'
};

var options_for_objects = [
  'expiresIn',
  'notBefore',
  'noTimestamp',
  'audience',
  'issuer',
  'subject',
  'jwtid',
];

module.exports = function (payload, secretOrPrivateKey, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }

  var isObjectPayload = typeof payload === 'object' &&
                        !Buffer.isBuffer(payload);

  var header = Object.assign({
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
  }, options.header);

  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }

  if (!secretOrPrivateKey && options.algorithm !== 'none') {
    return failure(new Error('secretOrPrivateKey must have a value'));
  }

  if (typeof payload === 'undefined') {
    return failure(new Error('payload is required'));
  } else if (isObjectPayload) {
    try {
      validatePayload(payload);
    }
    catch (error) {
      return failure(error);
    }
    if (!options.mutatePayload) {
      payload = Object.assign({},payload);
    }
  } else {
    var invalid_options = options_for_objects.filter(function (opt) {
      return typeof options[opt] !== 'undefined';
    });

    if (invalid_options.length > 0) {
      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
    }
  }

  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }

  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }

  try {
    validateOptions(options);
  }
  catch (error) {
    return failure(error);
  }

  var timestamp = payload.iat || Math.floor(Date.now() / 1000);

  if (options.noTimestamp) {
    delete payload.iat;
  } else if (isObjectPayload) {
    payload.iat = timestamp;
  }

  if (typeof options.notBefore !== 'undefined') {
    try {
      payload.nbf = timespan(options.notBefore, timestamp);
    }
    catch (err) {
      return failure(err);
    }
    if (typeof payload.nbf === 'undefined') {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
    try {
      payload.exp = timespan(options.expiresIn, timestamp);
    }
    catch (err) {
      return failure(err);
    }
    if (typeof payload.exp === 'undefined') {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  Object.keys(options_to_payload).forEach(function (key) {
    var claim = options_to_payload[key];
    if (typeof options[key] !== 'undefined') {
      if (typeof payload[claim] !== 'undefined') {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key];
    }
  });

  var encoding = options.encoding || 'utf8';

  if (typeof callback === 'function') {
    callback = callback && once(callback);

    jws.createSign({
      header: header,
      privateKey: secretOrPrivateKey,
      payload: payload,
      encoding: encoding
    }).once('error', callback)
      .once('done', function (signature) {
        callback(null, signature);
      });
  } else {
    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
  }
};


/***/ }),

/***/ 5898:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var JsonWebTokenError = __nccwpck_require__(9528);
var NotBeforeError    = __nccwpck_require__(2536);
var TokenExpiredError = __nccwpck_require__(2178);
var decode            = __nccwpck_require__(3497);
var timespan          = __nccwpck_require__(9357);
var PS_SUPPORTED      = __nccwpck_require__(6029);
var jws               = __nccwpck_require__(3579);

var PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
var RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
var HS_ALGS = ['HS256', 'HS384', 'HS512'];

if (PS_SUPPORTED) {
  PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
  RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
}

module.exports = function (jwtString, secretOrPublicKey, options, callback) {
  if ((typeof options === 'function') && !callback) {
    callback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  //clone this object since we are going to mutate it.
  options = Object.assign({}, options);

  var done;

  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }

  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
    return done(new JsonWebTokenError('clockTimestamp must be a number'));
  }

  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
    return done(new JsonWebTokenError('nonce must be a non-empty string'));
  }

  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString){
    return done(new JsonWebTokenError('jwt must be provided'));
  }

  if (typeof jwtString !== 'string') {
    return done(new JsonWebTokenError('jwt must be a string'));
  }

  var parts = jwtString.split('.');

  if (parts.length !== 3){
    return done(new JsonWebTokenError('jwt malformed'));
  }

  var decodedToken;

  try {
    decodedToken = decode(jwtString, { complete: true });
  } catch(err) {
    return done(err);
  }

  if (!decodedToken) {
    return done(new JsonWebTokenError('invalid token'));
  }

  var header = decodedToken.header;
  var getSecret;

  if(typeof secretOrPublicKey === 'function') {
    if(!callback) {
      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
    }

    getSecret = secretOrPublicKey;
  }
  else {
    getSecret = function(header, secretCallback) {
      return secretCallback(null, secretOrPublicKey);
    };
  }

  return getSecret(header, function(err, secretOrPublicKey) {
    if(err) {
      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
    }

    var hasSignature = parts[2].trim() !== '';

    if (!hasSignature && secretOrPublicKey){
      return done(new JsonWebTokenError('jwt signature is required'));
    }

    if (hasSignature && !secretOrPublicKey) {
      return done(new JsonWebTokenError('secret or public key must be provided'));
    }

    if (!hasSignature && !options.algorithms) {
      options.algorithms = ['none'];
    }

    if (!options.algorithms) {
      options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||
        ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :
        ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;

    }

    if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
      return done(new JsonWebTokenError('invalid algorithm'));
    }

    var valid;

    try {
      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
    } catch (e) {
      return done(e);
    }

    if (!valid) {
      return done(new JsonWebTokenError('invalid signature'));
    }

    var payload = decodedToken.payload;

    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
      if (typeof payload.nbf !== 'number') {
        return done(new JsonWebTokenError('invalid nbf value'));
      }
      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
      }
    }

    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
      if (typeof payload.exp !== 'number') {
        return done(new JsonWebTokenError('invalid exp value'));
      }
      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
      }
    }

    if (options.audience) {
      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

      var match = target.some(function (targetAudience) {
        return audiences.some(function (audience) {
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
        });
      });

      if (!match) {
        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
      }
    }

    if (options.issuer) {
      var invalid_issuer =
              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

      if (invalid_issuer) {
        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
      }
    }

    if (options.subject) {
      if (payload.sub !== options.subject) {
        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
      }
    }

    if (options.jwtid) {
      if (payload.jti !== options.jwtid) {
        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
      }
    }

    if (options.nonce) {
      if (payload.nonce !== options.nonce) {
        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
      }
    }

    if (options.maxAge) {
      if (typeof payload.iat !== 'number') {
        return done(new JsonWebTokenError('iat required when maxAge is specified'));
      }

      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === 'undefined') {
        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
      }
    }

    if (options.complete === true) {
      var signature = decodedToken.signature;

      return done(null, {
        header: header,
        payload: payload,
        signature: signature
      });
    }

    return done(null, payload);
  });
};


/***/ }),

/***/ 7300:
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}

module.exports = includes;


/***/ }),

/***/ 8672:
/***/ ((module) => {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && objectToString.call(value) == boolTag);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isBoolean;


/***/ }),

/***/ 5394:
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = isInteger;


/***/ }),

/***/ 4341:
/***/ ((module) => {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && objectToString.call(value) == numberTag);
}

module.exports = isNumber;


/***/ }),

/***/ 9822:
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

module.exports = isPlainObject;


/***/ }),

/***/ 3604:
/***/ ((module) => {

/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ 4183:
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = once;


/***/ }),

/***/ 6852:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __nccwpck_require__(3765)


/***/ }),

/***/ 1051:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __nccwpck_require__(6852)
var extname = (__nccwpck_require__(1017).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 725:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 395:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const path = __nccwpck_require__(1017);
const childProcess = __nccwpck_require__(2081);
const {promises: fs, constants: fsConstants} = __nccwpck_require__(7147);
const isWsl = __nccwpck_require__(9407);
const isDocker = __nccwpck_require__(106);
const defineLazyProperty = __nccwpck_require__(2159);

// Path to included `xdg-open`.
const localXdgOpenPath = __nccwpck_require__.ab + "xdg-open";

const {platform, arch} = process;

/**
Get the mount point for fixed drives in WSL.

@inner
@returns {string} The mount point.
*/
const getWslDrivesMountPoint = (() => {
	// Default value for "root" param
	// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config
	const defaultMountPoint = '/mnt/';

	let mountPoint;

	return async function () {
		if (mountPoint) {
			// Return memoized mount point value
			return mountPoint;
		}

		const configFilePath = '/etc/wsl.conf';

		let isConfigFileExists = false;
		try {
			await fs.access(configFilePath, fsConstants.F_OK);
			isConfigFileExists = true;
		} catch {}

		if (!isConfigFileExists) {
			return defaultMountPoint;
		}

		const configContent = await fs.readFile(configFilePath, {encoding: 'utf8'});
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);

		if (!configMountPoint) {
			return defaultMountPoint;
		}

		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;

		return mountPoint;
	};
})();

const pTryEach = async (array, mapper) => {
	let latestError;

	for (const item of array) {
		try {
			return await mapper(item); // eslint-disable-line no-await-in-loop
		} catch (error) {
			latestError = error;
		}
	}

	throw latestError;
};

const baseOpen = async options => {
	options = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options
	};

	if (Array.isArray(options.app)) {
		return pTryEach(options.app, singleApp => baseOpen({
			...options,
			app: singleApp
		}));
	}

	let {name: app, arguments: appArguments = []} = options.app || {};
	appArguments = [...appArguments];

	if (Array.isArray(app)) {
		return pTryEach(app, appName => baseOpen({
			...options,
			app: {
				name: appName,
				arguments: appArguments
			}
		}));
	}

	let command;
	const cliArguments = [];
	const childProcessOptions = {};

	if (platform === 'darwin') {
		command = 'open';

		if (options.wait) {
			cliArguments.push('--wait-apps');
		}

		if (options.background) {
			cliArguments.push('--background');
		}

		if (options.newInstance) {
			cliArguments.push('--new');
		}

		if (app) {
			cliArguments.push('-a', app);
		}
	} else if (platform === 'win32' || (isWsl && !isDocker())) {
		const mountPoint = await getWslDrivesMountPoint();

		command = isWsl ?
			`${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` :
			`${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;

		cliArguments.push(
			'-NoProfile',
			'-NonInteractive',
			'–ExecutionPolicy',
			'Bypass',
			'-EncodedCommand'
		);

		if (!isWsl) {
			childProcessOptions.windowsVerbatimArguments = true;
		}

		const encodedArguments = ['Start'];

		if (options.wait) {
			encodedArguments.push('-Wait');
		}

		if (app) {
			// Double quote with double quotes to ensure the inner quotes are passed through.
			// Inner quotes are delimited for PowerShell interpretation with backticks.
			encodedArguments.push(`"\`"${app}\`""`, '-ArgumentList');
			if (options.target) {
				appArguments.unshift(options.target);
			}
		} else if (options.target) {
			encodedArguments.push(`"${options.target}"`);
		}

		if (appArguments.length > 0) {
			appArguments = appArguments.map(arg => `"\`"${arg}\`""`);
			encodedArguments.push(appArguments.join(','));
		}

		// Using Base64-encoded command, accepted by PowerShell, to allow special characters.
		options.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
	} else {
		if (app) {
			command = app;
		} else {
			// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
			const isBundled = !__dirname || __dirname === '/';

			// Check if local `xdg-open` exists and is executable.
			let exeLocalXdgOpen = false;
			try {
				await fs.access(__nccwpck_require__.ab + "xdg-open", fsConstants.X_OK);
				exeLocalXdgOpen = true;
			} catch {}

			const useSystemXdgOpen = process.versions.electron ||
				platform === 'android' || isBundled || !exeLocalXdgOpen;
			command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;
		}

		if (appArguments.length > 0) {
			cliArguments.push(...appArguments);
		}

		if (!options.wait) {
			// `xdg-open` will block the process unless stdio is ignored
			// and it's detached from the parent even if it's unref'd.
			childProcessOptions.stdio = 'ignore';
			childProcessOptions.detached = true;
		}
	}

	if (options.target) {
		cliArguments.push(options.target);
	}

	if (platform === 'darwin' && appArguments.length > 0) {
		cliArguments.push('--args', ...appArguments);
	}

	const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);

	if (options.wait) {
		return new Promise((resolve, reject) => {
			subprocess.once('error', reject);

			subprocess.once('close', exitCode => {
				if (options.allowNonzeroExitCode && exitCode > 0) {
					reject(new Error(`Exited with code ${exitCode}`));
					return;
				}

				resolve(subprocess);
			});
		});
	}

	subprocess.unref();

	return subprocess;
};

const open = (target, options) => {
	if (typeof target !== 'string') {
		throw new TypeError('Expected a `target`');
	}

	return baseOpen({
		...options,
		target
	});
};

const openApp = (name, options) => {
	if (typeof name !== 'string') {
		throw new TypeError('Expected a `name`');
	}

	const {arguments: appArguments = []} = options || {};
	if (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {
		throw new TypeError('Expected `appArguments` as Array type');
	}

	return baseOpen({
		...options,
		app: {
			name,
			arguments: appArguments
		}
	});
};

function detectArchBinary(binary) {
	if (typeof binary === 'string' || Array.isArray(binary)) {
		return binary;
	}

	const {[arch]: archBinary} = binary;

	if (!archBinary) {
		throw new Error(`${arch} is not supported`);
	}

	return archBinary;
}

function detectPlatformBinary({[platform]: platformBinary}, {wsl}) {
	if (wsl && isWsl) {
		return detectArchBinary(wsl);
	}

	if (!platformBinary) {
		throw new Error(`${platform} is not supported`);
	}

	return detectArchBinary(platformBinary);
}

const apps = {};

defineLazyProperty(apps, 'chrome', () => detectPlatformBinary({
	darwin: 'google chrome',
	win32: 'chrome',
	linux: ['google-chrome', 'google-chrome-stable', 'chromium']
}, {
	wsl: {
		ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
		x64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe']
	}
}));

defineLazyProperty(apps, 'firefox', () => detectPlatformBinary({
	darwin: 'firefox',
	win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
	linux: 'firefox'
}, {
	wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
}));

defineLazyProperty(apps, 'edge', () => detectPlatformBinary({
	darwin: 'microsoft edge',
	win32: 'msedge',
	linux: ['microsoft-edge', 'microsoft-edge-dev']
}, {
	wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
}));

open.apps = apps;
open.openApp = openApp;

module.exports = open;


/***/ }),

/***/ 7931:
/***/ ((module, exports, __nccwpck_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(4300)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 9681:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ 1207:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const https = __nccwpck_require__(5687)

module.exports = (server, grace) => {
  grace = typeof grace === 'undefined' ? Infinity : grace
  const reqsPerSocket = new Map()
  let stopped = false
  let gracefully = true

  if (server instanceof https.Server) {
    server.on('secureConnection', onConnection)
  } else {
    server.on('connection', onConnection)
  }

  server.on('request', onRequest)
  server.stop = stop
  server._pendingSockets = reqsPerSocket
  return server

  function onConnection (socket) {
    reqsPerSocket.set(socket, 0)
    socket.once('close', () => reqsPerSocket.delete(socket))
  }

  function onRequest (req, res) {
    reqsPerSocket.set(req.socket, reqsPerSocket.get(req.socket) + 1)
    res.once('finish', () => {
      const pending = reqsPerSocket.get(req.socket) - 1
      reqsPerSocket.set(req.socket, pending)
      if (stopped && pending === 0) {
        req.socket.end()
      }
    })
  }

  function stop (callback) {
    // allow request handlers to update state before we act on that state
    setImmediate(() => {
      stopped = true
      if (grace < Infinity) {
        setTimeout(destroyAll, grace).unref()
      }
      server.close(e => {
        if (callback) {
          callback(e, gracefully)
        }
      })
      reqsPerSocket.forEach(endIfIdle)
    })
  }

  function endIfIdle (requests, socket) {
    if (requests === 0) socket.end()
  }

  function destroyAll () {
    gracefully = false
    reqsPerSocket.forEach((reqs, socket) => socket.end())
    setImmediate(() => {
      reqsPerSocket.forEach((reqs, socket) => socket.destroy())
    })
  }
}


/***/ }),

/***/ 1861:
/***/ ((module) => {

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});


/***/ }),

/***/ 9866:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(3908);


/***/ }),

/***/ 3908:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 5650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(5879));

var _v2 = _interopRequireDefault(__nccwpck_require__(7221));

var _v3 = _interopRequireDefault(__nccwpck_require__(854));

var _v4 = _interopRequireDefault(__nccwpck_require__(4666));

var _nil = _interopRequireDefault(__nccwpck_require__(9438));

var _version = _interopRequireDefault(__nccwpck_require__(3340));

var _validate = _interopRequireDefault(__nccwpck_require__(8575));

var _stringify = _interopRequireDefault(__nccwpck_require__(1659));

var _parse = _interopRequireDefault(__nccwpck_require__(1129));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 681:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 9438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 1129:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(8575));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 2801:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 6098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 1554:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 1659:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(8575));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 5879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(6098));

var _stringify = _interopRequireDefault(__nccwpck_require__(1659));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 7221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(3978));

var _md = _interopRequireDefault(__nccwpck_require__(681));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 3978:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(1659));

var _parse = _interopRequireDefault(__nccwpck_require__(1129));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 854:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(6098));

var _stringify = _interopRequireDefault(__nccwpck_require__(1659));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 4666:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(3978));

var _sha = _interopRequireDefault(__nccwpck_require__(1554));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 8575:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(2801));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 3340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(8575));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 3259:
/***/ ((module) => {

module.exports = eval("require")("supports-color");


/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 4300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 6224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 3765:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
const core = __nccwpck_require__(3722);
const appservices = __nccwpck_require__(5550);
const identity = __nccwpck_require__(5671);

async function createResourceGroup() {
  try {
    const subscriptionId = process.env.AZURE_SUBSCRIPTION_ID;
    const credential = new identity.DefaultAzureCredential();
    const appservicesClient = new appservices.WebSiteManagementClient(credential, subscriptionId);

    const appServicePlan = await appservicesClient.appServicePlans.beginCreateOrUpdateAndWait(
      "TEST-GROUP-DEV",
      "TEST-PLAN-DEV",
      { location: "westeurope", sku: {name: "F1"}, reserved: true}
    );

    core.info(`The resource group was created successfully.`);
    core.info(JSON.stringify(appServicePlan));
  }
  catch (error) {
    core.setFailed(error.message);
  }
}

createResourceGroup();
})();

module.exports = __webpack_exports__;
/******/ })()
;